<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="LvYang">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;page&#x2F;4&#x2F;index.html">
<meta property="og:site_name" content="LvYang">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/4/"/>





  <title>LvYang</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LvYang</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/10/15%20%7C%20Python%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AF%94%E8%BE%83%E3%80%81%E6%8B%B7%E8%B4%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/10/15%20%7C%20Python%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AF%94%E8%BE%83%E3%80%81%E6%8B%B7%E8%B4%9D/" itemprop="url">15 | Python对象的比较、拷贝</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-10T21:13:07+08:00">
                2019-12-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/" itemprop="url" rel="index">
                    <span itemprop="name">python核心技术与实战</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/10/15%20%7C%20Python%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AF%94%E8%BE%83%E3%80%81%E6%8B%B7%E8%B4%9D/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/12/10/15%20%7C%20Python%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AF%94%E8%BE%83%E3%80%81%E6%8B%B7%E8%B4%9D/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">l2 = list(l1)</span><br><span class="line">l1 <span class="keyword">is</span> l2</span><br></pre></td></tr></table></figure>




<pre><code>False</code></pre><p>但你可能并不清楚，这些语句的背后发生了什么。比如，</p>
<ul>
<li>l2 是 l1 的浅拷贝（shallow copy）还是深度拷贝（deep copy）呢？</li>
<li>a == b是比较两个对象的值相等，还是两个对象完全相等呢？<br>关于这些的种种知识，我希望通过这节课的学习，让你有个全面的了解。</li>
</ul>
<p>‘==’ VS ‘is’<br>等于（==）和 is 是 Python 中对象比较常用的两种方式。简单来说，’==’操作符比较对象之间的值是否相等，比如下面的例子，表示比较变量 a 和 b 所指向的值是否相等。<br>而’is’操作符比较的是对象的身份标识是否相等，即它们是否是同一个对象，是否指向同一个内存地址。</p>
<p>在 Python 中，每个对象的身份标识，都能通过函数 id(object) 获得。因此，’is’操作符，相当于比较对象之间的 ID 是否相等，我们来看下面的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line"> </span><br><span class="line">a == b</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"> </span><br><span class="line">id(a)</span><br><span class="line"><span class="number">4427562448</span></span><br><span class="line"> </span><br><span class="line">id(b)</span><br><span class="line"><span class="number">4427562448</span></span><br><span class="line"> </span><br><span class="line">a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>这里，首先 Python 会为 10 这个值开辟一块内存，然后变量 a 和 b 同时指向这块内存区域，即 a 和 b 都是指向 10 这个变量，因此 a 和 b 的值相等，id 也相等，a == b和a is b都返回 True。</p>
<p>不过，需要注意，对于整型数字来说，以上a is b为 True 的结论，只适用于 -5 到 256 范围内的数字。比如下面这个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">257</span></span><br><span class="line">b = <span class="number">257</span></span><br><span class="line"> </span><br><span class="line">a == b</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"> </span><br><span class="line">id(a)</span><br><span class="line"><span class="number">4473417552</span></span><br><span class="line"> </span><br><span class="line">id(b)</span><br><span class="line"><span class="number">4473417584</span></span><br><span class="line"> </span><br><span class="line">a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>这里我们把 257 同时赋值给了 a 和 b，可以看到a == b仍然返回 True，因为 a 和 b 指向的值相等。但奇怪的是，a is b返回了 false，并且我们发现，a 和 b 的 ID 不一样了，这是为什么呢？</p>
<p>事实上，出于对性能优化的考虑，Python 内部会对 -5 到 256 的整型维持一个数组，起到一个缓存的作用。这样，每次你试图创建一个 -5 到 256 范围内的整型数字时，Python 都会从这个数组中返回相对应的引用，而不是重新开辟一块新的内存空间。</p>
<p>但是，如果整型数字超过了这个范围，比如上述例子中的 257，Python 则会为两个 257 开辟两块内存区域，因此 a 和 b 的 ID 不一样，a is b就会返回 False 了。</p>
<p>通常来说，在实际工作中，当我们比较变量时，使用’==’的次数会比’is’多得多，因为我们一般更关心两个变量的值，而不是它们内部的存储地址。但是，当我们比较一个变量与一个单例（singleton）时，通常会使用’is’。一个典型的例子，就是检查一个变量是否为 None：</p>
<h3 id="is-None-一个单例（singleton）"><a href="#is-None-一个单例（singleton）" class="headerlink" title="is None,一个单例（singleton）"></a>is None,一个单例（singleton）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      ...</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure>

<p>这里注意，比较操作符’is’的速度效率，通常要优于’==’。因为’is’操作符不能被重载，这样，Python 就不需要去寻找，程序中是否有其他地方重载了比较操作符，并去调用。执行比较操作符’is’，就仅仅是比较两个变量的 ID 而已。</p>
<p>但是’==’操作符却不同，执行a == b相当于是去执行a.<strong>eq</strong>(b)，而 Python 大部分的数据类型都会去重载<strong>eq</strong>这个函数，其内部的处理通常会复杂一些。比如，对于列表，<strong>eq</strong>函数会去遍历列表中的元素，比较它们的顺序和值是否相等。</p>
<p>不过，对于不可变（immutable）的变量，如果我们之前用’==’或者’is’比较过，结果是不是就一直不变了呢？</p>
<p>答案自然是否定的。我们来看下面一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不可变的元祖, list里面最加5.</span></span><br><span class="line">t1 = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">t2 = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">t1 == t2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"> </span><br><span class="line">t1[<span class="number">-1</span>].append(<span class="number">5</span>)</span><br><span class="line">t1 == t2</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们知道元组是不可变的，但元组可以嵌套，它里面的元素可以是列表类型，列表是可变的，所以如果我们修改了元组中的某个可变元素，那么元组本身也就改变了，之前用<span class="string">'is'</span>或者<span class="string">'=='</span>操作符取得的结果，可能就不适用了。</span><br><span class="line"></span><br><span class="line">这一点，你在日常写程序时一定要注意，在必要的地方请不要省略条件检查。</span><br></pre></td></tr></table></figure>

<h3 id="浅拷贝和深度拷贝"><a href="#浅拷贝和深度拷贝" class="headerlink" title="浅拷贝和深度拷贝"></a>浅拷贝和深度拷贝</h3><p>接下来，我们一起来看看 Python 中的浅拷贝（shallow copy）和深度拷贝（deep copy）。</p>
<p>对于这两个熟悉的操作，我并不想一上来先抛概念让你死记硬背来区分，我们不妨先从它们的操作方法说起，通过代码来理解两者的不同。</p>
<p>先来看浅拷贝。常见的浅拷贝的方法，是使用数据类型本身的构造器，比如下面两个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构造器,生成新的地址,浅拷贝.</span></span><br><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">l2 = list(l1)</span><br><span class="line"> </span><br><span class="line">l2</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"> </span><br><span class="line">l1 == l2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"> </span><br><span class="line">l1 <span class="keyword">is</span> l2</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"> </span><br><span class="line">s1 = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">s2 = set(s1)</span><br><span class="line"> </span><br><span class="line">s2</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"> </span><br><span class="line">s1 == s2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"> </span><br><span class="line">s1 <span class="keyword">is</span> s2</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>这里，l2 就是 l1 的浅拷贝，s2 是 s1 的浅拷贝。当然，对于可变的序列，我们还可以通过切片操作符’:’完成浅拷贝，比如下面这个列表的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">l2 = l1[:]</span><br><span class="line"> </span><br><span class="line">l1 == l2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"> </span><br><span class="line">l1 <span class="keyword">is</span> l2</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>不过，需要注意的是，对于元组，使用 tuple() 或者切片操作符’:’不会创建一份浅拷贝，相反，它会返回一个指向相同元组的引用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">t2 = tuple(t1)</span><br><span class="line"> </span><br><span class="line">t1 == t2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"> </span><br><span class="line">t1 <span class="keyword">is</span> t2</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>这里，元组 (1, 2, 3) 只被创建一次，t1 和 t2 同时指向这个元组。</p>
<p>到这里，对于浅拷贝你应该很清楚了。浅拷贝，是指重新分配一块内存，创建一个新的对象，里面的元素是原对象中子对象的引用。因此，如果原对象中的元素不可变，那倒无所谓；但如果元素可变，浅拷贝通常会带来一些副作用，尤其需要注意。我们来看下面的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">l1 = [[<span class="number">1</span>, <span class="number">2</span>], (<span class="number">30</span>, <span class="number">40</span>)]</span><br><span class="line">l2 = list(l1)</span><br><span class="line">l1.append(<span class="number">100</span>)</span><br><span class="line">l1[<span class="number">0</span>].append(<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line">l1</span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (<span class="number">30</span>, <span class="number">40</span>), <span class="number">100</span>]</span><br><span class="line"> </span><br><span class="line">l2</span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (<span class="number">30</span>, <span class="number">40</span>)]</span><br><span class="line"> </span><br><span class="line">l1[<span class="number">1</span>] += (<span class="number">50</span>, <span class="number">60</span>)</span><br><span class="line">l1</span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (<span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>), <span class="number">100</span>]</span><br><span class="line"> </span><br><span class="line">l2</span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (<span class="number">30</span>, <span class="number">40</span>)]</span><br></pre></td></tr></table></figure>

<p>这个例子中，我们首先初始化了一个列表 l1，里面的元素是一个列表和一个元组；然后对 l1 执行浅拷贝，赋予 l2。因为浅拷贝里的元素是对原对象元素的引用，因此 l2 中的元素和 l1 指向同一个列表和元组对象。</p>
<p>接着往下看。l1.append(100)，表示对 l1 的列表新增元素 100。这个操作不会对 l2 产生任何影响，因为 l2 和 l1 作为整体是两个不同的对象，并不共享内存地址。操作过后 l2 不变，l1 会发生改变：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (<span class="number">30</span>, <span class="number">40</span>), <span class="number">100</span>]</span><br></pre></td></tr></table></figure>

<p>再来看，l1[0].append(3)，这里表示对 l1 中的第一个列表新增元素 3。因为 l2 是 l1 的浅拷贝，l2 中的第一个元素和 l1 中的第一个元素，共同指向同一个列表，因此 l2 中的第一个列表也会相对应的新增元素 3。操作后 l1 和 l2 都会改变：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l1: [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (<span class="number">30</span>, <span class="number">40</span>), <span class="number">100</span>]</span><br><span class="line">l2: [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (<span class="number">30</span>, <span class="number">40</span>)]</span><br></pre></td></tr></table></figure>

<p>最后是l1[1] += (50, 60)，因为元组是不可变的，这里表示对 l1 中的第二个元组拼接，然后重新创建了一个新元组作为 l1 中的第二个元素，而 l2 中没有引用新元组，因此 l2 并不受影响。操作后 l2 不变，l1 发生改变：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l1: [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (<span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>), <span class="number">100</span>]</span><br></pre></td></tr></table></figure>

<p>通过这个例子，你可以很清楚地看到使用浅拷贝可能带来的副作用。因此，如果我们想避免这种副作用，完整地拷贝一个对象，你就得使用深度拷贝。</p>
<p>所谓深度拷贝，是指重新分配一块内存，创建一个新的对象，并且将原对象中的元素，以递归的方式，通过创建新的子对象拷贝到新对象中。因此，新对象和原对象没有任何关联。</p>
<ul>
<li>Python 中以 copy.deepcopy() 来实现对象的深度拷贝。比如上述例子写成下面的形式，就是深度拷贝：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">l1 = [[<span class="number">1</span>, <span class="number">2</span>], (<span class="number">30</span>, <span class="number">40</span>)]</span><br><span class="line">l2 = copy.deepcopy(l1)</span><br><span class="line">l1.append(<span class="number">100</span>)</span><br><span class="line">l1[<span class="number">0</span>].append(<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line">l1</span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (<span class="number">30</span>, <span class="number">40</span>), <span class="number">100</span>]</span><br><span class="line"> </span><br><span class="line">l2 </span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], (<span class="number">30</span>, <span class="number">40</span>)]</span><br></pre></td></tr></table></figure>

<p>不过，深度拷贝也不是完美的，往往也会带来一系列问题。如果被拷贝对象中存在指向自身的引用，那么程序很容易陷入无限循环：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">x = [<span class="number">1</span>]</span><br><span class="line">x.append(x)</span><br><span class="line">print(x[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">y = copy.deepcopy(x)</span><br><span class="line"></span><br><span class="line">print(y)</span><br><span class="line">print(x <span class="keyword">is</span> y)</span><br></pre></td></tr></table></figure>

<pre><code>[1, [...]]
[1, [...]]
False</code></pre><p>上面这个例子，列表 x 中有指向自身的引用，因此 x 是一个无限嵌套的列表。但是我们发现深度拷贝 x 到 y 后，程序并没有出现 stack overflow 的现象。这是为什么呢？</p>
<p>其实，这是因为深度拷贝函数 deepcopy 中会维护一个字典，记录已经拷贝的对象与其 ID。拷贝过程中，如果字典里已经存储了将要拷贝的对象，则会从字典直接返回，我们来看相对应的源码就能明白：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deepcopy</span><span class="params">(x, memo=None, _nil=[])</span>:</span></span><br><span class="line">    <span class="string">"""Deep copy operation on arbitrary Python objects.</span></span><br><span class="line"><span class="string">    	</span></span><br><span class="line"><span class="string">	See the module's __doc__ string for more info.</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> memo <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        memo = &#123;&#125;</span><br><span class="line">    d = id(x) <span class="comment"># 查询被拷贝对象 x 的 id</span></span><br><span class="line">	y = memo.get(d, _nil) <span class="comment"># 查询字典里是否已经存储了该对象</span></span><br><span class="line">	<span class="keyword">if</span> y <span class="keyword">is</span> <span class="keyword">not</span> _nil:</span><br><span class="line">	    <span class="keyword">return</span> y <span class="comment"># 如果字典里已经存储了将要拷贝的对象，则直接返回</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>今天这节课，我们一起学习了 Python 中对象的比较和拷贝，主要有下面几个重点内容。</p>
<ul>
<li>比较操作符’==’表示比较对象间的值是否相等，而’is’表示比较对象的标识是否相等，即它们是否指向同一个内存地址。</li>
<li>比较操作符’is’效率优于’==’，因为’is’操作符无法被重载，执行’is’操作只是简单的获取对象的 ID，并进行比较；而’==’操作符则会递归地遍历对象的所有值，并逐一比较。</li>
<li>浅拷贝中的元素，是原对象中子对象的引用，因此，如果原对象中的元素是可变的，改变其也会影响拷贝后的对象，存在一定的副作用。</li>
<li>深度拷贝则会递归地拷贝原对象中的每一个子对象，因此拷贝后的对象和原对象互不相关。另外，深度拷贝中会维护一个字典，记录已经拷贝的对象及其 ID，来提高效率并防止无限递归的发生。</li>
</ul>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>最后，我为你留下一道思考题。这节课我曾用深度拷贝，拷贝过一个无限嵌套的列表。那么。当我们用等于操作符’==’进行比较时，输出会是什么呢？是 True 或者 False 还是其他？为什么呢？建议你先自己动脑想一想，然后再实际跑一下代码，来检验你的猜想。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">x = [<span class="number">1</span>]</span><br><span class="line">x.append(x)</span><br><span class="line"> </span><br><span class="line">y = copy.deepcopy(x)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 以下命令的输出是？</span></span><br><span class="line">x == y</span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

RecursionError                            Traceback (most recent call last)

&lt;ipython-input-9-5392db420a70&gt; in &lt;module&gt;
      6 
      7 # 以下命令的输出是？
----&gt; 8 x == y


RecursionError: maximum recursion depth exceeded in comparison</code></pre><p>应该会出错，因为x是一个无限嵌套的列表，y深拷贝于x，按道理来讲 x == y应该是True的，但进行比较操作符“==”的时候，’==’操作符则会递归地遍历对象的所有值，并逐一比较。而python为了防止栈崩溃，递归的层数是要限定的，不会无休下去，所以到了限定的层数，python解释器会跳出错误。执行了一下代码，也的确是跳出了 RecursionError: maximum recursion depth exceeded in comparison。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/10/11%20%7C%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E4%BB%8E%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E7%B1%BB%E6%AF%94%E8%AF%B4%E8%B5%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/10/11%20%7C%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E4%BB%8E%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E7%B1%BB%E6%AF%94%E8%AF%B4%E8%B5%B7/" itemprop="url">11 | 面向对象（上）：从生活中的类比说起</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-10T19:13:07+08:00">
                2019-12-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/" itemprop="url" rel="index">
                    <span itemprop="name">python核心技术与实战</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/10/11%20%7C%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E4%BB%8E%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E7%B1%BB%E6%AF%94%E8%AF%B4%E8%B5%B7/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/12/10/11%20%7C%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E4%BB%8E%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E7%B1%BB%E6%AF%94%E8%AF%B4%E8%B5%B7/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="对象，你找到了吗？"><a href="#对象，你找到了吗？" class="headerlink" title="对象，你找到了吗？"></a>对象，你找到了吗？</h3><p>我们先来看一段最基本的 Python 面向对象的应用代码，不要被它的长度吓到，你无需立刻看懂所有代码，跟着节奏来，我会一点点为你剖析。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Document</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, title, author, context)</span>:</span></span><br><span class="line">        print(<span class="string">'init function called'</span>)</span><br><span class="line">        self.title = title</span><br><span class="line">        self.author = author</span><br><span class="line">        self.__context = context <span class="comment"># __ 开头的属性是私有属性</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_context_length</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.__context)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intercept_context</span><span class="params">(self, length)</span>:</span></span><br><span class="line">        self.__context = self.__context[:length]</span><br><span class="line"> </span><br><span class="line">harry_potter_book = Document(<span class="string">'Harry Potter'</span>, <span class="string">'J. K. Rowling'</span>, <span class="string">'... Forever Do not believe any thing is capable of thinking independently ...'</span>)</span><br><span class="line"> </span><br><span class="line">print(harry_potter_book.title)</span><br><span class="line">print(harry_potter_book.author)</span><br><span class="line">print(harry_potter_book.get_context_length())</span><br><span class="line"> </span><br><span class="line">harry_potter_book.intercept_context(<span class="number">10</span>)</span><br><span class="line"> </span><br><span class="line">print(harry_potter_book.get_context_length())</span><br><span class="line"> </span><br><span class="line">print(harry_potter_book.__context)</span><br></pre></td></tr></table></figure>

<pre><code>init function called
Harry Potter
J. K. Rowling
77
10



---------------------------------------------------------------------------

AttributeError                            Traceback (most recent call last)

&lt;ipython-input-1-1a6ee7c15513&gt; in &lt;module&gt;
     22 print(harry_potter_book.get_context_length())
     23 
---&gt; 24 print(harry_potter_book.__context)


AttributeError: &apos;Document&apos; object has no attribute &apos;__context&apos;</code></pre><p>参照着这段代码，我先来简单解释几个概念。</p>
<ul>
<li>类：一群有着相似性的事物的集合，这里对应 Python 的 class。</li>
<li>对象：集合中的一个事物，这里对应由 class 生成的某一个 object，比如代码中的 harry_potter_book。</li>
<li>属性：对象的某个静态特征，比如上述代码中的 title、author 和 **__context。</li>
<li>函数：对象的某个动态能力，比如上述代码中的 intercept_context () 函数。</li>
</ul>
<p>当然，这样的说法既不严谨，也不充分，但如果你对面向对象编程完全不了解，它们可以让你迅速有一个直观的了解。</p>
<p>这里我想多说两句。回想起当年参加数学竞赛时，我曾和一个大佬交流数学的学习，我清楚记得我们对数学有着相似的观点：很多数学概念非常抽象，如果纯粹从数理逻辑而不是更高的角度去解题，很容易陷入僵局；而具体、直观的想象和类比，才是迅速打开数学大门的钥匙。虽然这些想象和类比不严谨也不充分，很多时候甚至是错误或者异想天开的，但它们确实能帮我们快速找到正确的大门。</p>
<p>就像很多人都有过的一个疑惑，“学霸是怎样想到这个答案的？”。德国数学家克莱因曾说过，“推进数学的，主要是那些有卓越直觉的人，而不是以严格的证明方法见长的人。”编程世界同样如此，如果你不满足于只做一个 CRUD“码农”，而是想成为一个优秀的工程师，那就一定要积极锻炼直觉思考和快速类比的能力，尤其是在找不到 bug 的时候。这才是编程学习中能给人最快进步的方法和路径。</p>
<p>言归正传，继续回到我们的主题，还是通过刚刚那段代码，我想再给类下一个更为严谨的定义。</p>
<p><strong>类，一群有着相同属性和函数的对象的集合。</strong></p>
<p>可以看到，class Document 定义了 Document 类，再往下能看到它有三个函数，这三个函数即为 Document 类的三个函数。</p>
<p>其中，init 表示构造函数，意即一个对象生成时会被自动调用的函数。我们能看到， harry_potter_book = Document(…)这一行代码被执行的时候，’init function called’字符串会被打印出来。而 get_context_length() 和 intercept_context() 则为类的普通函数，我们调用它们来对对象的属性做一些事情。</p>
<p>class Document 还有三个属性，title、author 和 __context 分别表示标题、作者和内容，通过构造函数传入。这里代码很直观，我们可以看到， intercept_context 能修改对象 harry_potter_book 的 __context 属性。</p>
<p>这里唯一需要强调的一点是，如果一个属性以 __ （注意，此处有两个 _） 开头，我们就默认这个属性是私有属性。私有属性，是指不希望在类的函数之外的地方被访问和修改的属性。所以，你可以看到，title 和 author 能够很自由地被打印出来，但是 print(harry_potter_book.__context)就会报错。</p>
<h3 id="老师，能不能再给力点？"><a href="#老师，能不能再给力点？" class="headerlink" title="老师，能不能再给力点？"></a>老师，能不能再给力点？</h3><p>掌握了最基础的概念，其实我们已经能做很多很多的事情了。不过，在工程实践中，随着复杂度继续提升，你可能会想到一些问题：</p>
<ul>
<li>如何在一个类中定义一些常量，每个对象都可以方便访问这些常量而不用重新构造？</li>
<li>如果一个函数不涉及到访问修改这个类的属性，而放到类外面有点不恰当，怎么做才能更优雅呢？</li>
<li>既然类是一群相似的对象的集合，那么可不可以是一群相似的类的集合呢？</li>
</ul>
<p>前两个问题很好解决，不过，它们涉及到一些常用的代码规范，这里我放了一段代码示例。同样的，你无需一口气读完这段代码，跟着我的节奏慢慢学习即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Document</span><span class="params">()</span>:</span></span><br><span class="line">    </span><br><span class="line">    WELCOME_STR = <span class="string">'Welcome! The context for this book is &#123;&#125;.'</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, title, author, context)</span>:</span></span><br><span class="line">        print(<span class="string">'init function called'</span>)</span><br><span class="line">        self.title = title</span><br><span class="line">        self.author = author</span><br><span class="line">        self.__context = context</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 类函数</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_empty_book</span><span class="params">(cls, title, author)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cls(title=title, author=author, context=<span class="string">'nothing'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_context_length</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.__context)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 静态函数</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_welcome</span><span class="params">(context)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Document.WELCOME_STR.format(context)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">empty_book = Document.create_empty_book(<span class="string">'What Every Man Thinks About Apart from Sex'</span>, <span class="string">'Professor Sheridan Simove'</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">print(empty_book.get_context_length())</span><br><span class="line">print(empty_book.get_welcome(<span class="string">'indeed nothing'</span>))</span><br></pre></td></tr></table></figure>

<pre><code>init function called
7
Welcome! The context for this book is indeed nothing.</code></pre><p>第一个问题，在 Python 的类里，你只需要和函数并列地声明并赋值，就可以实现这一点，例如这段代码中的 WELCOME_STR。一种很常规的做法，是用全大写来表示常量，因此我们可以在类中使用 self.WELCOME_STR ，或者在类外使用 Entity.WELCOME_STR ，来表达这个字符串。</p>
<p>而针对第二个问题，我们提出了类函数、成员函数和静态函数三个概念。它们其实很好理解，前两者产生的影响是动态的，能够访问或者修改对象的属性；而静态函数则与类没有什么关联，最明显的特征便是，静态函数的第一个参数没有任何特殊性。</p>
<p>具体来看这几种函数。一般而言，静态函数可以用来做一些简单独立的任务，既方便测试，也能优化代码结构。静态函数还可以通过在函数前一行加上 @staticmethod 来表示，代码中也有相应的示例。这其实使用了装饰器的概念，我们会在后面的章节中详细讲解。</p>
<p>而类函数的第一个参数一般为 cls，表示必须传一个类进来。类函数最常用的功能是实现不同的 init 构造函数，比如上文代码中，我们使用 create_empty_book 类函数，来创造新的书籍对象，其 context 一定为 ‘nothing’。这样的代码，就比你直接构造要清晰一些。类似的，类函数需要装饰器 @classmethod 来声明。</p>
<p>成员函数则是我们最正常的类的函数，它不需要任何装饰器声明，第一个参数 self 代表当前对象的引用，可以通过此函数，来实现想要的查询 / 修改类的属性等功能。</p>
<h3 id="继承，是每个富二代的梦想"><a href="#继承，是每个富二代的梦想" class="headerlink" title="继承，是每个富二代的梦想"></a>继承，是每个富二代的梦想</h3><p>接下来，我们来看第三个问题，既然类是一群相似的对象的集合，那么可不可以是一群相似的类的集合呢？</p>
<p>答案是，当然可以。只要抽象得好，类可以描述成任何事物的集合。当然你要小心、严谨地去定义它，不然一不小心就会引起第三次数学危机 XD。</p>
<p>类的继承，顾名思义，指的是一个类既拥有另一个类的特征，也拥有不同于另一个类的独特特征。在这里的第一个类叫做子类，另一个叫做父类，特征其实就是类的属性和函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, object_type)</span>:</span></span><br><span class="line">        print(<span class="string">'parent class init called'</span>)</span><br><span class="line">        self.object_type = object_type</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_context_length</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'get_context_length not implemented'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_title</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.title)</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Document</span><span class="params">(Entity)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, title, author, context)</span>:</span></span><br><span class="line">        print(<span class="string">'Document class init called'</span>)</span><br><span class="line">        Entity.__init__(self, <span class="string">'document'</span>)</span><br><span class="line">        self.title = title</span><br><span class="line">        self.author = author</span><br><span class="line">        self.__context = context</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_context_length</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.__context)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Video</span><span class="params">(Entity)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, title, author, video_length)</span>:</span></span><br><span class="line">        print(<span class="string">'Video class init called'</span>)</span><br><span class="line">        Entity.__init__(self, <span class="string">'video'</span>)</span><br><span class="line">        self.title = title</span><br><span class="line">        self.author = author</span><br><span class="line">        self.__video_length = video_length</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_context_length</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__video_length</span><br><span class="line"> </span><br><span class="line">harry_potter_book = Document(<span class="string">'Harry Potter(Book)'</span>, <span class="string">'J. K. Rowling'</span>, <span class="string">'... Forever Do not believe any thing is capable of thinking independently ...'</span>)</span><br><span class="line">harry_potter_movie = Video(<span class="string">'Harry Potter(Movie)'</span>, <span class="string">'J. K. Rowling'</span>, <span class="number">120</span>)</span><br><span class="line"> </span><br><span class="line">print(harry_potter_book.object_type)</span><br><span class="line">print(harry_potter_movie.object_type)</span><br><span class="line"> </span><br><span class="line">harry_potter_book.print_title()</span><br><span class="line">harry_potter_movie.print_title()</span><br><span class="line"> </span><br><span class="line">print(harry_potter_book.get_context_length())</span><br><span class="line">print(harry_potter_movie.get_context_length())</span><br></pre></td></tr></table></figure>

<pre><code>Document class init called
parent class init called
Video class init called
parent class init called
document
video
Harry Potter(Book)
Harry Potter(Movie)
77
120</code></pre><p>我们同样结合代码来学习这些概念。在这段代码中，Document 和 Video 它们有相似的地方，都有相应的标题、作者和内容等属性。我们可以从中抽象出一个叫做 Entity 的类，来作为它俩的父类。</p>
<p>首先需要注意的是构造函数。每个类都有构造函数，继承类在生成对象的时候，是不会自动调用父类的构造函数的，因此你必须在 init() 函数中显式调用父类的构造函数。它们的执行顺序是 子类的构造函数 -&gt; 父类的构造函数。</p>
<p>其次需要注意父类 get_context_length() 函数。如果使用 Entity 直接生成对象，调用 get_context_length() 函数，就会 raise error 中断程序的执行。这其实是一种很好的写法，叫做函数重写，可以使子类必须重新写一遍 get_context_length() 函数，来覆盖掉原有函数。</p>
<p>最后需要注意到 print_title() 函数，这个函数定义在父类中，但是子类的对象可以毫无阻力地使用它来打印 title，这也就体现了继承的优势：减少重复的代码，降低系统的熵值（即复杂度）。</p>
<p>到这里，你对继承就有了比较详细的了解了，面向对象编程也可以说已经入门了。当然，如果你想达到更高的层次，大量练习编程，学习更多的细节知识，都是必不可少的。</p>
<p>最后，我想再为你扩展一下抽象函数和抽象类，我同样会用一段代码来辅助讲解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_title</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_title</span><span class="params">(self, title)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Document</span><span class="params">(Entity)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_title</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.title</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_title</span><span class="params">(self, title)</span>:</span></span><br><span class="line">        self.title = title</span><br><span class="line"> </span><br><span class="line">document = Document()</span><br><span class="line">document.set_title(<span class="string">'Harry Potter'</span>)</span><br><span class="line">print(document.get_title())</span><br><span class="line"> </span><br><span class="line">entity = Entity()</span><br></pre></td></tr></table></figure>

<p>你应该发现了，Entity 本身是没有什么用的，只需拿来定义 Document 和 Video 的一些基本元素就够了。不过，万一你不小心生成 Entity 的对象该怎么办呢？为了防止这样的手误，必须要介绍一下抽象类。</p>
<p>抽象类是一种特殊的类，它生下来就是作为父类存在的，一旦对象化就会报错。同样，抽象函数定义在抽象类之中，子类必须重写该函数才能使用。相应的抽象函数，则是使用装饰器 @abstractmethod 来表示。</p>
<p>我们可以看到，代码中entity = Entity()直接报错，只有通过 Document 继承 Entity 才能正常使用。</p>
<p>这其实正是软件工程中一个很重要的概念，定义接口。大型工程往往需要很多人合作开发，比如在 Facebook 中，在 idea 提出之后，开发组和产品组首先会召开产品设计会，PM（Product Manager，产品经理） 写出产品需求文档，然后迭代；TL（Team Leader，项目经理）编写开发文档，开发文档中会定义不同模块的大致功能和接口、每个模块之间如何协作、单元测试和集成测试、线上灰度测试、监测和日志等等一系列开发流程。</p>
<p>抽象类就是这么一种存在，它是一种自上而下的设计风范，你只需要用少量的代码描述清楚要做的事情，定义好接口，然后就可以交给不同开发人员去开发和对接。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>到目前为止，我们一直在强调一件事情：面向对象编程是软件工程中重要的思想。正如动态规划是算法中的重要思想一样，它不是某一种非常具体的技术，而是一种综合能力的体现，是将大型工程解耦化、模块化的重要方法。在实践中要多想，尤其是抽象地想，才能更快掌握这个技巧。</p>
<p>回顾一下今天的内容，我希望你能自己回答下面两个问题，作为今天内容的总结，写在留言区里。</p>
<p>第一个问题，面向对象编程四要素是什么？它们的关系又是什么？</p>
<p>第二个问题，讲了这么久的继承，继承究竟是什么呢？你能用三个字表达出来吗？</p>
<blockquote>
<p>这里不开玩笑，Facebook 很多 Launch Doc （上线文档）中要求用五个单词总结你的文档，因为你的文档不仅仅是你的团队要看，往上走甚至会到 VP 或者 CTO 那里，你需要言简意赅，让他们快速理解你想要表达的意思。</p>
</blockquote>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>最后，再给你留一道思考题。既然你能通过继承一个类，来获得父类的函数和属性，那么你能继承两个吗？答案自是能的，这就叫做多重继承。那么问题来了。</p>
<p>我们使用单一继承的时候，构造函数的执行顺序很好确定，即子类 -&gt; 父类 -&gt; 爷类 -&gt;… 的链式关系。不过，多重继承的时候呢？比如下面这个例子。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> ---&gt;B---</span><br><span class="line">A-      --&gt;D</span><br><span class="line"> ---&gt;C---</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这种继承方式，叫做菱形继承，BC 继承了 A，然后 D 继承了 BC，创造一个 D 的对象。那么，构造函数调用顺序又是怎样的呢？</span><br></pre></td></tr></table></figure>

<p>Python面向对象中super用法与MRO机制 —<a href="https://www.cnblogs.com/chenhuabin/p/10058594.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenhuabin/p/10058594.html</a></p>
<p>TODO: 类函数, 静态函数区别.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/09/10%20%7C%20%E7%AE%80%E7%BA%A6%E4%B8%8D%E7%AE%80%E5%8D%95%E7%9A%84%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/09/10%20%7C%20%E7%AE%80%E7%BA%A6%E4%B8%8D%E7%AE%80%E5%8D%95%E7%9A%84%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/" itemprop="url">10 | 简约不简单的匿名函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-09T22:13:07+08:00">
                2019-12-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/" itemprop="url" rel="index">
                    <span itemprop="name">python核心技术与实战</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/09/10%20%7C%20%E7%AE%80%E7%BA%A6%E4%B8%8D%E7%AE%80%E5%8D%95%E7%9A%84%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/12/09/10%20%7C%20%E7%AE%80%E7%BA%A6%E4%B8%8D%E7%AE%80%E5%8D%95%E7%9A%84%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="匿名函数基础"><a href="#匿名函数基础" class="headerlink" title="匿名函数基础"></a>匿名函数基础</h3><p>首先，什么是匿名函数呢？以下是匿名函数的格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> argument1, argument2,... argumentN : expression</span><br></pre></td></tr></table></figure>

<p>我们可以看到，匿名函数的关键字是 lambda，之后是一系列的参数，然后用冒号隔开，最后则是由这些参数组成的表达式。我们通过几个例子看一下它的用法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">square = <span class="keyword">lambda</span> x: x**<span class="number">2</span></span><br><span class="line">square(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>




<pre><code>9</code></pre><p>这里的匿名函数只输入一个参数 x，输出则是输入 x 的平方。因此当输入是 3 时，输出便是 9。如果把这个匿名函数写成常规函数的形式，则是下面这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x**<span class="number">2</span></span><br><span class="line">square(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到，匿名函数 lambda 和常规函数一样，返回的都是一个函数对象（function object），它们的用法也极其相似，不过还是有下面几点区别。</p>
<p>**第一，lambda 是一个表达式（expression），并不是一个语句（statement）。</p>
<ul>
<li><p>所谓的表达式，就是用一系列“公式”去表达一个东西，比如x + 2、 x**2等等；</p>
</li>
<li><p>而所谓的语句，则一定是完成了某些功能，比如赋值语句x = 1完成了赋值，print 语句print(x)完成了打印，条件语句 if x &lt; 0:完成了选择功能等等。</p>
</li>
</ul>
<p>因此，lambda 可以用在一些常规函数 def 不能用的地方，比如，lambda 可以用在列表内部，而常规函数却不能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="keyword">lambda</span> x: x*x)(x) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br></pre></td></tr></table></figure>




<pre><code>[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</code></pre><p>再比如，lambda 可以被用作某些函数的参数，而常规函数 def 也不能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = [(<span class="number">1</span>, <span class="number">20</span>), (<span class="number">3</span>, <span class="number">0</span>), (<span class="number">9</span>, <span class="number">10</span>), (<span class="number">2</span>, <span class="number">-1</span>)]</span><br><span class="line">l.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]) <span class="comment"># 按列表中元祖的第二个元素排序</span></span><br><span class="line">print(l)</span><br></pre></td></tr></table></figure>

<pre><code>[(2, -1), (3, 0), (9, 10), (1, 20)]</code></pre><p>常规函数 def 必须通过其函数名被调用，因此必须首先被定义。但是作为一个表达式的 lambda，返回的函数对象就不需要名字了。</p>
<p>**第二，lambda 的主体是只有一行的简单表达式，并不能扩展成一个多行的代码块。</p>
<p>这其实是出于设计的考虑。Python 之所以发明 lambda，就是为了让它和常规函数各司其职：lambda 专注于简单的任务，而常规函数则负责更复杂的多行逻辑。关于这点，Python 之父 Guido van Rossum 曾发了一篇文章解释，你有兴趣的话可以自己阅读。</p>
<h3 id="为什么要使用匿名函数？"><a href="#为什么要使用匿名函数？" class="headerlink" title="为什么要使用匿名函数？"></a>为什么要使用匿名函数？</h3><p>理论上来说，Python 中有匿名函数的地方，都可以被替换成等价的其他表达形式。一个 Python 程序是可以不用任何匿名函数的。不过，在一些情况下，使用匿名函数 lambda，可以帮助我们大大简化代码的复杂度，提高代码的可读性。</p>
<p>通常，我们用函数的目的无非是这么几点：</p>
<ol>
<li><p>减少代码的重复性；</p>
</li>
<li><p>模块化代码。</p>
</li>
</ol>
<p>对于第一点，如果你的程序在不同地方包含了相同的代码，那么我们就会把这部分相同的代码写成一个函数，并为它取一个名字，方便在相对应的不同地方调用。</p>
<p>对于第二点，如果你的一块儿代码是为了实现一个功能，但内容非常多，写在一起降低了代码的可读性，那么通常我们也会把这部分代码单独写成一个函数，然后加以调用。</p>
<p>不过，再试想一下这样的情况。你需要一个函数，但它非常简短，只需要一行就能完成；同时它在程序中只被调用一次而已。那么请问，你还需要像常规函数一样，给它一个定义和名字吗？</p>
<p>答案当然是否定的。这种情况下，函数就可以是匿名的，你只需要在适当的地方定义并使用，就能让匿名函数发挥作用了。</p>
<p>举个例子，如果你想对一个列表中的所有元素做平方操作，而这个操作在你的程序中只需要进行一次，用 lambda 函数可以表示成下面这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">squared = map(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

&lt;ipython-input-5-f2792dd957c5&gt; in &lt;module&gt;
      1 squared = map(lambda x: x**2, [1, 2, 3, 4, 5])
----&gt; 2 squared()


TypeError: &apos;map&apos; object is not callable</code></pre><p>如果用常规函数，则表示为这几行代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x**<span class="number">2</span></span><br><span class="line"> </span><br><span class="line">squared = map(square, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure>

<p>这里我简单解释一下。函数 map(function, iterable) 的第一个参数是函数对象，第二个参数是一个可以遍历的集合，它表示对 iterable 的每一个元素，都运用 function 这个函数。两者一对比，我们很明显地发现，lambda 函数让代码更加简洁明了。</p>
<p>再举一个例子，在 Python 的 Tkinter GUI 应用中，我们想实现这样一个简单的功能：创建显示一个按钮，每当用户点击时，就打印出一段文字。如果使用 lambda 函数可以表示成下面这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> Button, mainloop</span><br><span class="line">button = Button(</span><br><span class="line">    text=<span class="string">'This is a button'</span>,</span><br><span class="line">    command=<span class="keyword">lambda</span>: print(<span class="string">'being pressed'</span>)) <span class="comment"># 点击时调用 lambda 函数</span></span><br><span class="line">button.pack()</span><br><span class="line">mainloop()</span><br></pre></td></tr></table></figure>

<p>而如果我们用常规函数 def，那么需要写更多的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> Button, mainloop</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_message</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'being pressed'</span>)</span><br><span class="line"> </span><br><span class="line">button = Button(</span><br><span class="line">    text=<span class="string">'This is a button'</span>,</span><br><span class="line">    command=print_message) <span class="comment"># 点击时调用 lambda 函数</span></span><br><span class="line">button.pack()</span><br><span class="line">mainloop()</span><br></pre></td></tr></table></figure>

<p>显然，运用匿名函数的代码简洁很多，也更加符合 Python 的编程习惯。</p>
<h3 id="Python-函数式编程"><a href="#Python-函数式编程" class="headerlink" title="Python 函数式编程"></a>Python 函数式编程</h3><p>最后，我们一起来看一下，Python 的函数式编程特性，这与我们今天所讲的匿名函数 lambda，有着密切的联系。</p>
<p>所谓函数式编程，是指代码中每一块都是不可变的（immutable），都由纯函数（pure function）的形式组成。这里的纯函数，是指函数本身相互独立、互不影响，对于相同的输入，总会有相同的输出，没有任何副作用。</p>
<p>举个很简单的例子，比如对于一个列表，我想让列表中的元素值都变为原来的两倍，我们可以写成下面的形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply_2</span><span class="params">(l)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">0</span>, len(l)):</span><br><span class="line">        l[index] *= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure>

<p>这段代码就不是一个纯函数的形式，因为列表中元素的值被改变了，如果我多次调用 multiply_2() 这个函数，那么每次得到的结果都不一样。要想让它成为一个纯函数的形式，就得写成下面这种形式，重新创建一个新的列表并返回。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply_2_pure</span><span class="params">(l)</span>:</span></span><br><span class="line">    new_list = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> l:</span><br><span class="line">        new_list.append(item * <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> new_list</span><br></pre></td></tr></table></figure>

<p>函数式编程的优点，主要在于其纯函数和不可变的特性使程序更加健壮，易于调试（debug）和测试；缺点主要在于限制多，难写。当然，Python 不同于一些语言（比如 Scala），它并不是一门函数式编程语言，不过，Python 也提供了一些函数式编程的特性，值得我们了解和学习。</p>
<p>Python 主要提供了这么几个函数：map()、filter() 和 reduce()，通常结合匿名函数 lambda 一起使用。这些都是你需要掌握的东西，接下来我逐一介绍。</p>
<p>首先是 map(function, iterable) 函数，前面的例子提到过，它表示，对 iterable 中的每个元素，都运用 function 这个函数，最后返回一个新的可遍历的集合。比如刚才列表的例子，要对列表中的每个元素乘以 2，那么用 map 就可以表示为下面这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">new_list = map(<span class="keyword">lambda</span> x: x * <span class="number">2</span>, l) <span class="comment"># [2， 4， 6， 8， 10]</span></span><br></pre></td></tr></table></figure>

<p>我们可以以 map() 函数为例，看一下 Python 提供的函数式编程接口的性能。还是同样的列表例子，它还可以用 for 循环和 list comprehension（目前没有统一中文叫法，你也可以直译为列表理解等）实现，我们来比较一下它们的速度：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">python3 -mtimeit -s<span class="string">'xs=range(1000000)'</span> <span class="string">'map(lambda x: x*2, xs)'</span></span><br><span class="line"><span class="number">2000000</span> loops, best of <span class="number">5</span>: <span class="number">171</span> nsec per loop</span><br><span class="line"> </span><br><span class="line">python3 -mtimeit -s<span class="string">'xs=range(1000000)'</span> <span class="string">'[x * 2 for x in xs]'</span></span><br><span class="line"><span class="number">5</span> loops, best of <span class="number">5</span>: <span class="number">62.9</span> msec per loop</span><br><span class="line"> </span><br><span class="line">python3 -mtimeit -s<span class="string">'xs=range(1000000)'</span> <span class="string">'l = []'</span> <span class="string">'for i in xs: l.append(i * 2)'</span></span><br><span class="line"><span class="number">5</span> loops, best of <span class="number">5</span>: <span class="number">92.7</span> msec per loop</span><br></pre></td></tr></table></figure>


<pre><code>  File &quot;&lt;ipython-input-7-4859408d9dc8&gt;&quot;, line 1
    python3 -mtimeit -s&apos;xs=range(1000000)&apos; &apos;map(lambda x: x*2, xs)&apos;
                                         ^
SyntaxError: invalid syntax</code></pre><p>你可以看到，map() 是最快的。因为 map() 函数直接由 C 语言写的，运行时不需要通过 Python 解释器间接调用，并且内部做了诸多优化，所以运行速度最快。</p>
<p>接下来来看 filter(function, iterable) 函数，它和 map 函数类似，function 同样表示一个函数对象。filter() 函数表示对 iterable 中的每个元素，都使用 function 判断，并返回 True 或者 False，最后将返回 True 的元素组成一个新的可遍历的集合。</p>
<p>举个例子，比如我要返回一个列表中的所有偶数，可以写成下面这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">new_list = filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, l) <span class="comment"># [2, 4]</span></span><br></pre></td></tr></table></figure>

<p>最后我们来看 reduce(function, iterable) 函数，它通常用来对一个集合做一些累积操作。</p>
<p>function 同样是一个函数对象，规定它有两个参数，表示对 iterable 中的每个元素以及上一次调用后的结果，运用 function 进行计算，所以最后返回的是一个单独的数值。</p>
<p>举个例子，我想要计算某个列表元素的乘积，就可以用 reduce() 函数来表示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">product = reduce(<span class="keyword">lambda</span> x, y: x * y, l) <span class="comment"># 1*2*3*4*5 = 120</span></span><br></pre></td></tr></table></figure>

<p>最后我们来看 reduce(function, iterable) 函数，它通常用来对一个集合做一些累积操作。</p>
<p>function 同样是一个函数对象，规定它有两个参数，表示对 iterable 中的每个元素以及上一次调用后的结果，运用 function 进行计算，所以最后返回的是一个单独的数值。</p>
<p>举个例子，我想要计算某个列表元素的乘积，就可以用 reduce() 函数来表示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">product = reduce(<span class="keyword">lambda</span> x, y: x * y, l) <span class="comment"># 1*2*3*4*5 = 120</span></span><br></pre></td></tr></table></figure>

<p>当然，类似的，filter() 和 reduce() 的功能，也可以用 for 循环或者 list comprehension 来实现。</p>
<p>通常来说，在我们想对集合中的元素进行一些操作时，如果操作非常简单，比如相加、累积这种，那么我们优先考虑 map()、filter()、reduce() 这类或者 list comprehension 的形式。至于这两种方式的选择：</p>
<ul>
<li><p>在数据量非常多的情况下，比如机器学习的应用，那我们一般更倾向于函数式编程的表示，因为效率更高；</p>
</li>
<li><p>在数据量不多的情况下，并且你想要程序更加 Pythonic 的话，那么 list comprehension 也不失为一个好选择。</p>
</li>
</ul>
<p>不过，如果你要对集合中的元素，做一些比较复杂的操作，那么，考虑到代码的可读性，我们通常会使用 for 循环，这样更加清晰明了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这节课，我们一起学习了 Python 中的匿名函数 lambda，它的主要用途是减少代码的复杂度。需要注意的是 lambda 是一个表达式，并不是一个语句；它只能写成一行的表达形式，语法上并不支持多行。匿名函数通常的使用场景是：程序中需要使用一个函数完成一个简单的功能，并且该函数只调用一次。</p>
<p>其次，我们也入门了 Python 的函数式编程，主要了解了常见的 map()，fiilter() 和 reduce() 三个函数，并比较了它们与其他形式（for 循环，comprehension）的性能，显然，它们的性能效率是最优的。</p>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>最后，我想给你留下两道思考题。</p>
<p>第一问：如果让你对一个字典，根据值进行由高到底的排序，该怎么做呢？以下面这段代码为例，你可以思考一下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'mike'</span>: <span class="number">10</span>, <span class="string">'lucy'</span>: <span class="number">2</span>, <span class="string">'ben'</span>: <span class="number">30</span>&#125;</span><br><span class="line">d = sorted(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure>

<pre><code>[(&apos;ben&apos;, 30), (&apos;mike&apos;, 10), (&apos;lucy&apos;, 2)]</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/09/09%E4%B8%A8%E4%B8%8D%E5%8F%AF%E6%88%96%E7%BC%BA%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/09/09%E4%B8%A8%E4%B8%8D%E5%8F%AF%E6%88%96%E7%BC%BA%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/" itemprop="url">09丨不可或缺的自定义函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-09T20:13:07+08:00">
                2019-12-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/" itemprop="url" rel="index">
                    <span itemprop="name">python核心技术与实战</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/09/09%E4%B8%A8%E4%B8%8D%E5%8F%AF%E6%88%96%E7%BC%BA%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/12/09/09%E4%B8%A8%E4%B8%8D%E5%8F%AF%E6%88%96%E7%BC%BA%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h3><p>那么，到底什么是函数，如何在 Python 程序中定义函数呢？</p>
<p>说白了，函数就是为了实现某一功能的代码段，只要写好以后，就可以重复利用。我们先来看下面一个简单的例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span><span class="params">(message)</span>:</span></span><br><span class="line">    print(<span class="string">'Got a message: &#123;&#125;'</span>.format(message))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用函数 my_func()</span></span><br><span class="line">my_func(<span class="string">'Hello World'</span>)</span><br></pre></td></tr></table></figure>

<pre><code>Got a message: Hello World</code></pre><p>其中：</p>
<ul>
<li><p>def 是函数的声明；</p>
</li>
<li><p>my_func 是函数的名称；</p>
</li>
<li><p>括号里面的 message 则是函数的参数；</p>
</li>
<li><p>而 print 那行则是函数的主体部分，可以执行相应的语句；</p>
</li>
<li><p>在函数最后，你可以返回调用结果（return 或 yield），也可以不返回。</p>
</li>
</ul>
<p>总结一下，大概是下面的这种形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(param1, param2, ..., paramN)</span>:</span></span><br><span class="line">    statements</span><br><span class="line">    <span class="keyword">return</span>/<span class="keyword">yield</span> value <span class="comment"># optional</span></span><br></pre></td></tr></table></figure>

<p>和其他需要编译的语言（比如 C 语言）不一样的是，def 是可执行语句，这意味着函数直到被调用前，都是不存在的。当程序调用函数时，def 语句才会创建一个新的函数对象，并赋予其名字。</p>
<p>我们一起来看几个例子，加深你对函数的印象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_sum</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"> </span><br><span class="line">result = my_sum(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

<pre><code>8</code></pre><p>这里，我们定义了 my_sum() 这个函数，它有两个参数 a 和 b，作用是相加；随后，调用 my_sum() 函数，分别把 3 和 5 赋于 a 和 b；最后，返回其相加的值，赋于变量 result，并输出得到 8。</p>
<p>再来看一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_largest_element</span><span class="params">(l)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(l, list):</span><br><span class="line">        print(<span class="string">'input is not type of list'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> len(l) == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">'empty input'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    largest_element = l[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> l:</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest_element:</span><br><span class="line">            largest_element = item</span><br><span class="line">    print(<span class="string">'largest element is: &#123;&#125;'</span>.format(largest_element)) </span><br><span class="line">      </span><br><span class="line">find_largest_element([<span class="number">8</span>, <span class="number">1</span>,<span class="number">-3</span>, <span class="number">2</span>, <span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<pre><code>largest element is: 8</code></pre><p>这个例子中，我们定义了函数 find_largest_element，作用是遍历输入的列表，找出最大的值并打印。因此，当我们调用它，并传递列表 [8, 1, -3, 2, 0] 作为参数时，程序就会输出 largest element is: 8。</p>
<p>需要注意，主程序调用函数时，必须保证这个函数此前已经定义过，不然就会报错，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_func(<span class="string">'hello world'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span><span class="params">(message)</span>:</span></span><br><span class="line">    print(<span class="string">'Got a message: &#123;&#125;'</span>.format(message))</span><br></pre></td></tr></table></figure>

<pre><code>Got a message: hello world</code></pre><p>但是，如果我们在函数内部调用其他函数，函数间哪个声明在前、哪个在后就无所谓，因为 def 是可执行语句，函数在调用之前都不存在，我们只需保证调用时，所需的函数都已经声明定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span><span class="params">(message)</span>:</span></span><br><span class="line">    my_sub_func(message) <span class="comment"># 调用 my_sub_func() 在其声明之前不影响程序执行</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_sub_func</span><span class="params">(message)</span>:</span></span><br><span class="line">    print(<span class="string">'Got a message: &#123;&#125;'</span>.format(message))</span><br><span class="line"> </span><br><span class="line">my_func(<span class="string">'hello world'</span>)</span><br></pre></td></tr></table></figure>

<pre><code>Got a message: hello world</code></pre><p>另外，Python 函数的参数可以设定默认值，比如下面这样的写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(param = <span class="number">0</span>)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>这样，在调用函数 func() 时，如果参数 param 没有传入，则参数默认为 0；而如果传入了参数 param，其就会覆盖默认值。</p>
<p>前面说过，Python 和其他语言相比的一大特点是，Python 是 dynamically typed 的，可以接受任何数据类型（整型，浮点，字符串等等）。对函数参数来说，这一点同样适用。比如还是刚刚的 my_sum 函数，我们也可以把列表作为参数来传递，表示将两个列表相连接：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_sum</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"> </span><br><span class="line">print(my_sum([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]))</span><br></pre></td></tr></table></figure>

<pre><code>[1, 2, 3, 4]</code></pre><p>同样，也可以把字符串作为参数传递，表示字符串的合并拼接：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_sum</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">print(my_sum(<span class="string">'hello '</span>, <span class="string">'world'</span>))</span><br></pre></td></tr></table></figure>

<pre><code>hello world</code></pre><p>当然，如果两个参数的数据类型不同，比如一个是列表、一个是字符串，两者无法相加，那就会报错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_sum</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">print(my_sum([<span class="number">1</span>, <span class="number">2</span>], <span class="string">'hello'</span>))</span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

&lt;ipython-input-9-c00c9a9db157&gt; in &lt;module&gt;
      1 def my_sum(a, b):
      2     return a + b
----&gt; 3 print(my_sum([1, 2], &apos;hello&apos;))


&lt;ipython-input-9-c00c9a9db157&gt; in my_sum(a, b)
      1 def my_sum(a, b):
----&gt; 2     return a + b
      3 print(my_sum([1, 2], &apos;hello&apos;))


TypeError: can only concatenate list (not &quot;str&quot;) to list</code></pre><p>我们可以看到，Python 不用考虑输入的数据类型，而是将其交给具体的代码去判断执行，同样的一个函数（比如这边的相加函数 my_sum()），可以同时应用在整型、列表、字符串等等的操作中。</p>
<p>在编程语言中，我们把这种行为称为多态。这也是 Python 和其他语言，比如 Java、C 等很大的一个不同点。当然，Python 这种方便的特性，在实际使用中也会带来诸多问题。因此，必要时请你在开头加上数据的类型检查。</p>
<p>Python 函数的另一大特性，是 Python 支持函数的嵌套。所谓的函数嵌套，就是指函数里面又有函数，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'world'</span>)</span><br><span class="line">    f2()</span><br><span class="line">f1()</span><br></pre></td></tr></table></figure>

<pre><code>hello
world</code></pre><p>这里函数 f1() 的内部，又定义了函数 f2()。在调用函数 f1() 时，会先打印字符串’hello’，然后 f1() 内部再调用 f2()，打印字符串’world’。你也许会问，为什么需要函数嵌套？这样做有什么好处呢？</p>
<p>其实，函数的嵌套，主要有下面两个方面的作用。</p>
<p>第一，函数的嵌套能够保证内部函数的隐私。内部函数只能被外部函数所调用和访问，不会暴露在全局作用域，因此，如果你的函数内部有一些隐私数据（比如数据库的用户、密码等），不想暴露在外，那你就可以使用函数的的嵌套，将其封装在内部函数中，只通过外部函数来访问。比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect_DB</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_DB_configuration</span><span class="params">()</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> host, username, password</span><br><span class="line">    conn = connector.connect(get_DB_configuration())</span><br><span class="line">    <span class="keyword">return</span> conn</span><br><span class="line">get_DB_configuration()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment">#NameError: name 'get_DB_configuration' is not defined</span></span><br></pre></td></tr></table></figure>

<p>这里的函数 get_DB_configuration，便是内部函数，它无法在 connect_DB() 函数以外被单独调用。也就是说，下面这样的外部直接调用是错误的^:<br>我们只能通过调用外部函数 connect_DB() 来访问它，这样一来，程序的安全性便有了很大的提高。</p>
<p>第二，合理的使用函数嵌套，能够提高程序的运行效率。我们来看下面这个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(input)</span>:</span></span><br><span class="line">    <span class="comment"># validation check</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(input, int):</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'input must be an integer.'</span>)</span><br><span class="line">    <span class="keyword">if</span> input &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'input must be greater or equal to 0'</span> )</span><br><span class="line">    ...</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_factorial</span><span class="params">(input)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> input &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> input * inner_factorial(input<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> inner_factorial(input)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">print(factorial(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<pre><code>120</code></pre><p>这里，我们使用递归的方式计算一个数的阶乘。因为在计算之前，需要检查输入是否合法，所以我写成了函数嵌套的形式，这样一来，输入是否合法就只用检查一次。而如果我们不使用函数嵌套，那么每调用一次递归便会检查一次，这是没有必要的，也会降低程序的运行效率。</p>
<p>实际工作中，如果你遇到相似的情况，输入检查不是很快，还会耗费一定的资源，那么运用函数的嵌套就十分必要了。</p>
<h3 id="函数变量作用域"><a href="#函数变量作用域" class="headerlink" title="函数变量作用域"></a>函数变量作用域</h3><p>Python 函数中变量的作用域和其他语言类似。如果变量是在函数内部定义的，就称为局部变量，只在函数内部有效。一旦函数执行完毕，局部变量就会被回收，无法访问，比如下面的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_text_from_file</span><span class="params">(file_path)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(file_path) <span class="keyword">as</span> file:</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>我们在函数内部定义了 file 这个变量，这个变量只在 read_text_from_file 这个函数里有效，在函数外部则无法访问。</p>
<p>相对应的，全局变量则是定义在整个文件层次上的，比如下面这段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MIN_VALUE = <span class="number">1</span></span><br><span class="line">MAX_VALUE = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validation_check</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> value &lt; MIN_VALUE <span class="keyword">or</span> value &gt; MAX_VALUE:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'validation check fails'</span>)</span><br></pre></td></tr></table></figure>

<p>这里的 MIN_VALUE 和 MAX_VALUE 就是全局变量，可以在文件内的任何地方被访问，当然在函数内部也是可以的。不过，我们不能在函数内部随意改变全局变量的值。比如，下面的写法就是错误的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MIN_VALUE = <span class="number">1</span></span><br><span class="line">MAX_VALUE = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validation_check</span><span class="params">(value)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    MIN_VALUE += <span class="number">1</span></span><br><span class="line">    ...</span><br><span class="line">validation_check(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>如果运行这段代码，程序便会报错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnboundLocalError: local variable <span class="string">'MIN_VALUE'</span> referenced before assignment</span><br></pre></td></tr></table></figure>

<p>这是因为，Python 的解释器会默认函数内部的变量为局部变量，但是又发现局部变量 MIN_VALUE 并没有声明，因此就无法执行相关操作。所以，如果我们一定要在函数内部改变全局变量的值，就必须加上 global 这个声明：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MIN_VALUE = <span class="number">1</span></span><br><span class="line">MAX_VALUE = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validation_check</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> MIN_VALUE</span><br><span class="line">    ...</span><br><span class="line">    MIN_VALUE += <span class="number">1</span></span><br><span class="line">    ...</span><br><span class="line">validation_check(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>这里的 global 关键字，并不表示重新创建了一个全局变量 MIN_VALUE，而是告诉 Python 解释器，函数内部的变量 MIN_VALUE，就是之前定义的全局变量，并不是新的全局变量，也不是局部变量。这样，程序就可以在函数内部访问全局变量，并修改它的值了。</p>
<p>另外，如果遇到函数内部局部变量和全局变量同名的情况，那么在函数内部，局部变量会覆盖全局变量，比如下面这种：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MIN_VALUE = <span class="number">1</span></span><br><span class="line">MAX_VALUE = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validation_check</span><span class="params">(value)</span>:</span></span><br><span class="line">    MIN_VALUE = <span class="number">3</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>在函数 validation_check() 内部，我们定义了和全局变量同名的局部变量 MIN_VALUE，那么，MIN_VALUE 在函数内部的值，就应该是 3 而不是 1 了。</p>
<p>类似的，对于嵌套函数来说，内部函数可以访问外部函数定义的变量，但是无法修改，若要修改，必须加上 nonlocal 这个关键字：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">    x = <span class="string">"local"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> x <span class="comment"># nonlocal 关键字表示这里的 x 就是外部函数 outer 定义的变量 x</span></span><br><span class="line">        x = <span class="string">'nonlocal'</span></span><br><span class="line">        print(<span class="string">"inner:"</span>, x)</span><br><span class="line">    inner()</span><br><span class="line">    print(<span class="string">"outer:"</span>, x)</span><br><span class="line">outer()</span><br></pre></td></tr></table></figure>

<pre><code>inner: nonlocal
outer: nonlocal</code></pre><p>如果不加上 nonlocal 这个关键字，而内部函数的变量又和外部函数变量同名，那么同样的，内部函数变量会覆盖外部函数的变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">    x = <span class="string">"local"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        x = <span class="string">'nonlocal'</span> <span class="comment"># 这里的 x 是 inner 这个函数的局部变量</span></span><br><span class="line">        print(<span class="string">"inner:"</span>, x)</span><br><span class="line">    inner()</span><br><span class="line">    print(<span class="string">"outer:"</span>, x)</span><br><span class="line">outer()</span><br></pre></td></tr></table></figure>

<p>闭包<br>这节课的第三个重点，我想再来介绍一下闭包（closure）。闭包其实和刚刚讲的嵌套函数类似，不同的是，这里外部函数返回的是一个函数，而不是一个具体的值。返回的函数通常赋于一个变量，这个变量可以在后面被继续执行调用。</p>
<p>举个例子你就更容易理解了。比如，我们想计算一个数的 n 次幂，用闭包可以写成下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nth_power</span><span class="params">(exponent)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exponent_of</span><span class="params">(base)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> base ** exponent</span><br><span class="line">    <span class="keyword">return</span> exponent_of <span class="comment"># 返回值是 exponent_of 函数</span></span><br><span class="line"> </span><br><span class="line">square = nth_power(<span class="number">2</span>) <span class="comment"># 计算一个数的平方</span></span><br><span class="line">cube = nth_power(<span class="number">3</span>) <span class="comment"># 计算一个数的立方 </span></span><br><span class="line"></span><br><span class="line">print(square)</span><br><span class="line">print(cube)</span><br><span class="line"> </span><br><span class="line">print(square(<span class="number">2</span>))  <span class="comment"># 计算 2 的平方</span></span><br><span class="line">print(cube(<span class="number">2</span>)) <span class="comment"># 计算 2 的立方</span></span><br></pre></td></tr></table></figure>

<pre><code>&lt;function nth_power.&lt;locals&gt;.exponent_of at 0x111a8ce18&gt;
&lt;function nth_power.&lt;locals&gt;.exponent_of at 0x111a8cea0&gt;
4
8</code></pre><p>这里外部函数 nth_power() 返回值，是函数 exponent_of()，而不是一个具体的数值。需要注意的是，在执行完square = nth_power(2)和cube = nth_power(3)后，外部函数 nth_power() 的参数 exponent，仍然会被内部函数 exponent_of() 记住。这样，之后我们调用 square(2) 或者 cube(2) 时，程序就能顺利地输出结果，而不会报错说参数 exponent 没有定义了。</p>
<p>看到这里，你也许会思考，为什么要闭包呢？上面的程序，我也可以写成下面的形式啊！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nth_power_rewrite</span><span class="params">(base, exponent)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> base ** exponent</span><br></pre></td></tr></table></figure>

<p>确实可以，不过，要知道，使用闭包的一个原因，是让程序变得更简洁易读。设想一下，比如你需要计算很多个数的平方，那么你觉得写成下面哪一种形式更好呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不适用闭包</span></span><br><span class="line">res1 = nth_power_rewrite(base1, <span class="number">2</span>)</span><br><span class="line">res2 = nth_power_rewrite(base2, <span class="number">2</span>)</span><br><span class="line">res3 = nth_power_rewrite(base3, <span class="number">2</span>)</span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用闭包</span></span><br><span class="line">square = nth_power(<span class="number">2</span>)</span><br><span class="line">res1 = square(base1)</span><br><span class="line">res2 = square(base2)</span><br><span class="line">res3 = square(base3)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>显然是第二种，是不是？首先直观来看，第二种形式，让你每次调用函数都可以少输入一个参数，表达更为简洁。</p>
<p>其次，和上面讲到的嵌套函数优点类似，函数开头需要做一些额外工作，而你又需要多次调用这个函数时，将那些额外工作的代码放在外部函数，就可以减少多次调用导致的不必要的开销，提高程序的运行效率。</p>
<p>另外还有一点，我们后面会讲到，闭包常常和装饰器（decorator）一起使用。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这节课，我们一起学习了 Python 函数的概念及其应用，有这么几点你需要注意:</p>
<ol>
<li><p>Python 中函数的参数可以接受任意的数据类型，使用起来需要注意，必要时请在函数开头加入数据类型的检查；</p>
</li>
<li><p>和其他语言不同，Python 中函数的参数可以设定默认值；</p>
</li>
<li><p>嵌套函数的使用，能保证数据的隐私性，提高程序运行效率；</p>
</li>
<li><p>合理地使用闭包，则可以简化程序的复杂度，提高可读性。</p>
</li>
</ol>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>最后给你留一道思考题。在实际的学习工作中，你遇到过哪些使用嵌套函数或者是闭包的例子呢？欢迎在下方留言，与我讨论，也欢迎你把这篇文章分享给你的同事、朋友。</p>
<p>TODO: yield -<a href="https://blog.csdn.net/mieleizhi0522/article/details/82142856" target="_blank" rel="noopener">https://blog.csdn.net/mieleizhi0522/article/details/82142856</a></p>
<h3 id="自我总结"><a href="#自我总结" class="headerlink" title="自我总结"></a>自我总结</h3><ul>
<li>def 是可执行语句，函数在调用之前都不存在.</li>
<li>Python 是 dynamically typed 的，可以接受任何数据类型（整型，浮点，字符串等等）。对函数参数来说，这一点同样适用。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/06/08%20%7C%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%9A%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/06/08%20%7C%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%9A%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7%EF%BC%9F/" itemprop="url">08 | 异常处理：如何提高程序的稳定性？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-06T21:13:07+08:00">
                2019-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/" itemprop="url" rel="index">
                    <span itemprop="name">python核心技术与实战</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/06/08%20%7C%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%9A%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7%EF%BC%9F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/12/06/08%20%7C%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%9A%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7%EF%BC%9F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="错误与异常"><a href="#错误与异常" class="headerlink" title="错误与异常"></a>错误与异常</h3><p>首先要了解，Python 中的错误和异常是什么？两者之间又有什么联系和区别呢？</p>
<p>通常来说，程序中的错误至少包括两种，一种是语法错误，另一种则是异常。</p>
<p>所谓语法错误，你应该很清楚，也就是你写的代码不符合编程规范，无法被识别与执行，比如下面这个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法错误少:</span></span><br><span class="line"><span class="keyword">if</span> name <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line">    print(name)</span><br></pre></td></tr></table></figure>

<p>If 语句漏掉了冒号，不符合 Python 的语法规范，所以程序就会报错invalid syntax。</p>
<p>而异常则是指程序的语法正确，也可以被执行，但在执行过程中遇到了错误，抛出了异常，比如下面的 3 个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> / <span class="number">0</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ZeroDivisionError: integer division <span class="keyword">or</span> modulo by zero</span><br><span class="line"> </span><br><span class="line">order * <span class="number">2</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">'order'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span> + [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unsupported operand type(s) <span class="keyword">for</span> +: <span class="string">'int'</span> <span class="keyword">and</span> <span class="string">'list'</span></span><br></pre></td></tr></table></figure>


<pre><code>  File &quot;&lt;ipython-input-1-5c8a1fb0a76b&gt;&quot;, line 2
    Traceback (most recent call last):
                         ^
SyntaxError: invalid syntax</code></pre><p>它们语法完全正确，但显然，我们不能做除法时让分母为 0；也不能使用未定义的变量做运算；而让一个整型和一个列表相加也是不可取的。</p>
<p>于是，当程序运行到这些地方时，就抛出了异常，并且终止运行。例子中的ZeroDivisionError NameError和TypeError，就是三种常见的异常类型。</p>
<p>当然，Python 中还有很多其他异常类型，比如KeyError是指字典中的键找不到；FileNotFoundError是指发送了读取文件的请求，但相应的文件不存在等等，我在此不一一赘述，你可以自行参考相应文档。</p>
<h3 id="如何处理异常"><a href="#如何处理异常" class="headerlink" title="如何处理异常"></a>如何处理异常</h3><p>刚刚讲到，如果执行到程序中某处抛出了异常，程序就会被终止并退出。你可能会问，那有没有什么办法可以不终止程序，让其照样运行下去呢？答案当然是肯定的，这也就是我们所说的异常处理，通常使用 try 和 except 来解决，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    s = input(<span class="string">'please enter two numbers separated by comma: '</span>)</span><br><span class="line">    num1 = int(s.split(<span class="string">','</span>)[<span class="number">0</span>].strip())</span><br><span class="line">    num2 = int(s.split(<span class="string">','</span>)[<span class="number">1</span>].strip())</span><br><span class="line">    ... </span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> err:</span><br><span class="line">    print(<span class="string">'Value Error: &#123;&#125;'</span>.format(err))</span><br><span class="line"> </span><br><span class="line">print(<span class="string">'continue'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># please enter two numbers separated by comma: a,b</span></span><br><span class="line"><span class="comment"># Value Error: invalid literal for int() with base 10: 'a'</span></span><br><span class="line"><span class="comment"># continue</span></span><br></pre></td></tr></table></figure>

<p>这里默认用户输入以逗号相隔的两个整形数字，将其提取后，做后续的操作（注意 input 函数会将输入转换为字符串类型）。如果我们输入a,b，程序便会抛出异常invalid literal for int() with base 10: ‘a’，然后跳出 try 这个 block。</p>
<p>由于程序抛出的异常类型是 ValueError，和 except block 所 catch 的异常类型相匹配，所以 except block 便会被执行，最终输出Value Error: invalid literal for int() with base 10: ‘a’，并打印出continue。</p>
<p>我们知道，except block 只接受与它相匹配的异常类型并执行，如果程序抛出的异常并不匹配，那么程序照样会终止并退出。</p>
<p>所以，还是刚刚这个例子，如果我们只输入1，程序抛出的异常就是IndexError: list index out of range，与 ValueError 不匹配，那么 except block 就不会被执行，程序便会终止并退出（continue 不会被打印）。</p>
<p>please enter two numbers separated by comma: 1<br>IndexError Traceback (most recent call last)<br>IndexError: list index out of range</p>
<p>不过，很显然，这样强调一种类型的写法有很大的局限性。那么，该怎么解决这个问题呢？</p>
<p>其中一种解决方案，是在 except block 中加入多种异常的类型，比如下面这样的写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    s = input(<span class="string">'please enter two numbers separated by comma: '</span>)</span><br><span class="line">    num1 = int(s.split(<span class="string">','</span>)[<span class="number">0</span>].strip())</span><br><span class="line">    num2 = int(s.split(<span class="string">','</span>)[<span class="number">1</span>].strip())</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">except</span> (ValueError, IndexError) <span class="keyword">as</span> err:</span><br><span class="line">    print(<span class="string">'Error: &#123;&#125;'</span>.format(err))</span><br><span class="line">    </span><br><span class="line">print(<span class="string">'continue'</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>或者第二种写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    s = input(<span class="string">'please enter two numbers separated by comma: '</span>)</span><br><span class="line">    num1 = int(s.split(<span class="string">','</span>)[<span class="number">0</span>].strip())</span><br><span class="line">    num2 = int(s.split(<span class="string">','</span>)[<span class="number">1</span>].strip())</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> err:</span><br><span class="line">    print(<span class="string">'Value Error: &#123;&#125;'</span>.format(err))</span><br><span class="line"><span class="keyword">except</span> IndexError <span class="keyword">as</span> err:</span><br><span class="line">    print(<span class="string">'Index Error: &#123;&#125;'</span>.format(err))</span><br><span class="line"> </span><br><span class="line">print(<span class="string">'continue'</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这样，每次程序执行时，except block 中只要有一个 exception 类型与实际匹配即可。</p>
<p>不过，很多时候，我们很难保证程序覆盖所有的异常类型，所以，更通常的做法，是在最后一个 except block，声明其处理的异常类型是 Exception。Exception 是其他所有非系统异常的基类，能够匹配任意非系统异常。那么这段代码就可以写成下面这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    s = input(<span class="string">'please enter two numbers separated by comma: '</span>)</span><br><span class="line">    num1 = int(s.split(<span class="string">','</span>)[<span class="number">0</span>].strip())</span><br><span class="line">    num2 = int(s.split(<span class="string">','</span>)[<span class="number">1</span>].strip())</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> err:</span><br><span class="line">    print(<span class="string">'Value Error: &#123;&#125;'</span>.format(err))</span><br><span class="line"><span class="keyword">except</span> IndexError <span class="keyword">as</span> err:</span><br><span class="line">    print(<span class="string">'Index Error: &#123;&#125;'</span>.format(err))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">    print(<span class="string">'Other error: &#123;&#125;'</span>.format(err))</span><br><span class="line"> </span><br><span class="line">print(<span class="string">'continue'</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>或者，你也可以在 except 后面省略异常类型，这表示与任意异常相匹配（包括系统异常等）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    s = input(<span class="string">'please enter two numbers separated by comma: '</span>)</span><br><span class="line">    num1 = int(s.split(<span class="string">','</span>)[<span class="number">0</span>].strip())</span><br><span class="line">    num2 = int(s.split(<span class="string">','</span>)[<span class="number">1</span>].strip())</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> err:</span><br><span class="line">    print(<span class="string">'Value Error: &#123;&#125;'</span>.format(err))</span><br><span class="line"><span class="keyword">except</span> IndexError <span class="keyword">as</span> err:</span><br><span class="line">    print(<span class="string">'Index Error: &#123;&#125;'</span>.format(err))</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">'Other error'</span>)</span><br><span class="line"> </span><br><span class="line">print(<span class="string">'continue'</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>需要注意，当程序中存在多个 except block 时，最多只有一个 except block 会被执行。换句话说，如果多个 except 声明的异常类型都与实际相匹配，那么只有最前面的 except block 会被执行，其他则被忽略。</p>
<p>异常处理中，还有一个很常见的用法是 finally，经常和 try、except 放在一起来用。无论发生什么情况，finally block 中的语句都会被执行，哪怕前面的 try 和 excep block 中使用了 return 语句。</p>
<p>一个常见的应用场景，便是文件的读取：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">'file.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line">    .... <span class="comment"># some data processing</span></span><br><span class="line"><span class="keyword">except</span> OSError <span class="keyword">as</span> err:</span><br><span class="line">    print(<span class="string">'OS error: &#123;&#125;'</span>.format(err))</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">'Unexpected error:'</span>, sys.exc_info()[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure>

<p>这段代码中，try block 尝试读取 file.txt 这个文件，并对其中的数据进行一系列的处理，到最后，无论是读取成功还是读取失败，程序都会执行 finally 中的语句——关闭这个文件流，确保文件的完整性。因此，在 finally 中，我们通常会放一些无论如何都要执行的语句。</p>
<p>值得一提的是，对于文件的读取，我们也常常使用 with open，你也许在前面的例子中已经看到过，with open 会在最后自动关闭文件，让语句更加简洁。</p>
<h3 id="用户自定义异常"><a href="#用户自定义异常" class="headerlink" title="用户自定义异常"></a>用户自定义异常</h3><p>前面的例子里充斥了很多 Python 内置的异常类型，你可能会问，我可以创建自己的异常类型吗？</p>
<p>答案是肯定是，Python 当然允许我们这么做。下面这个例子，我们创建了自定义的异常类型 MyInputError，定义并实现了初始化函数和 str 函数（直接 print 时调用）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInputError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="string">"""Exception raised when there're errors in input"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span> <span class="comment"># 自定义异常类型的初始化</span></span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span> <span class="comment"># 自定义异常类型的 string 表达形式</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"&#123;&#125; is invalid input"</span>.format(repr(self.value)))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> MyInputError(<span class="number">1</span>) <span class="comment"># 抛出 MyInputError 这个异常</span></span><br><span class="line"><span class="keyword">except</span> MyInputError <span class="keyword">as</span> err:</span><br><span class="line">    print(<span class="string">'error: &#123;&#125;'</span>.format(err))</span><br></pre></td></tr></table></figure>

<p>如果你执行上述代码块并输出，便会得到下面的结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: <span class="number">1</span> <span class="keyword">is</span> invalid input</span><br></pre></td></tr></table></figure>

<p>实际工作中，如果内置的异常类型无法满足我们的需求，或者为了让异常更加详细、可读，想增加一些异常类型的其他功能，我们可以自定义所需异常类型。不过，大多数情况下，Python 内置的异常类型就足够好了。</p>
<h3 id="异常的使用场景与注意点"><a href="#异常的使用场景与注意点" class="headerlink" title="异常的使用场景与注意点"></a>异常的使用场景与注意点</h3><p>学完了前面的基础知识，接下来我们着重谈一下，异常的使用场景与注意点。</p>
<p>通常来说，在程序中，如果我们不确定某段代码能否成功执行，往往这个地方就需要使用异常处理。除了上述文件读取的例子，我可以再举一个例子来说明。</p>
<p>大型社交网站的后台，需要针对用户发送的请求返回相应记录。用户记录往往储存在 key-value 结构的数据库中，每次有请求过来后，我们拿到用户的 ID，并用 ID 查询数据库中此人的记录，就能返回相应的结果。</p>
<p>而数据库返回的原始数据，往往是 json string 的形式，这就需要我们首先对 json string 进行 decode（解码），你可能很容易想到下面的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">raw_data = queryDB(uid) <span class="comment"># 根据用户的 id，返回相应的信息</span></span><br><span class="line">data = json.loads(raw_data)</span><br></pre></td></tr></table></figure>

<p>这样的代码是不是就足够了呢？</p>
<p>要知道，在 json.loads() 函数中，输入的字符串如果不符合其规范，那么便无法解码，就会抛出异常，因此加上异常处理十分必要。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'name'</span>: <span class="string">'jason'</span>, <span class="string">'age'</span>: <span class="number">20</span>&#125;</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    value = d[<span class="string">'dob'</span>]</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">except</span> KeyError <span class="keyword">as</span> err:</span><br><span class="line">    print(<span class="string">'KeyError: &#123;&#125;'</span>.format(err))</span><br></pre></td></tr></table></figure>

<p>诚然，这样的代码并没有 bug，但是让人看了摸不着头脑，也显得很冗余。如果你的代码中充斥着这种写法，无疑对阅读、协作来说都是障碍。因此，对于 flow-control（流程控制）的代码逻辑，我们一般不用异常处理。</p>
<p>字典这个例子，写成下面这样就很好。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">'dob'</span> <span class="keyword">in</span> d:</span><br><span class="line">    value = d[<span class="string">'dob'</span>]</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这节课， 我们一起学习了 Python 的异常处理及其使用场景，你需要重点掌握下面几点。</p>
<p>异常，通常是指程序运行的过程中遇到了错误，终止并退出。我们通常使用 try except 语句去处理异常，这样程序就不会被终止，仍能继续执行。</p>
<p>处理异常时，如果有必须执行的语句，比如文件打开后必须关闭等等，则可以放在 finally block 中。</p>
<p>异常处理，通常用在你不确定某段代码能否成功执行，也无法轻易判断的情况下，比如数据库的连接、读取等等。正常的 flow-control 逻辑，不要使用异常处理，直接用条件语句解决就可以了。</p>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>最后，给你留一个思考题。在异常处理时，如果 try block 中有多处抛出异常，需要我们使用多个 try except block 吗？以数据库的连接、读取为例，下面两种写法，你觉得哪种更好呢？</p>
<p>第一种：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    db = DB.connect(<span class="string">'&lt;db path&gt;'</span>) <span class="comment"># 可能会抛出异常</span></span><br><span class="line">    raw_data = DB.queryData(<span class="string">'&lt;viewer_id&gt;'</span>) <span class="comment"># 可能会抛出异常</span></span><br><span class="line"><span class="keyword">except</span> (DBConnectionError, DBQueryDataError) err:</span><br><span class="line">    print(<span class="string">'Error: &#123;&#125;'</span>.format(err))</span><br></pre></td></tr></table></figure>

<p>第二种：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    db = DB.connect(<span class="string">'&lt;db path&gt;'</span>) <span class="comment"># 可能会抛出异常</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        raw_data = DB.queryData(<span class="string">'&lt;viewer_id&gt;'</span>)</span><br><span class="line">    <span class="keyword">except</span> DBQueryDataError <span class="keyword">as</span> err:</span><br><span class="line">         print(<span class="string">'DB query data error: &#123;&#125;'</span>.format(err))</span><br><span class="line"><span class="keyword">except</span> DBConnectionError <span class="keyword">as</span> err:</span><br><span class="line">     print(<span class="string">'DB connection error: &#123;&#125;'</span>.format(err))</span><br></pre></td></tr></table></figure>

<p>第一种写法更加简洁，易于阅读。而且except后面的错误类型先抛出数据库连接错误，之后才抛出查询错误，实现的异常处理和第二种一样。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/06/7python%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/06/7python%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF/" itemprop="url">07 | 修炼基本功：条件与循环</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-06T20:15:59+08:00">
                2019-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/" itemprop="url" rel="index">
                    <span itemprop="name">python核心技术与实战</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/06/7python%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/12/06/7python%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>首先，我们一起来看一下 Python 的条件语句，用法很简单。比如，我想要表示 y=|x|这个函数，那么相应的代码便是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># y = |x|</span></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">    y = -x</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    y = x</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure>

<pre><code>1</code></pre><p>由于 Python 不支持 switch 语句，因此，当存在多个条件判断时，我们需要用 else if 来实现，这在 Python 中的表达是elif。语法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition_1:</span><br><span class="line">    statement_1</span><br><span class="line"><span class="keyword">elif</span> condition_2:</span><br><span class="line">    statement_2</span><br><span class="line"><span class="keyword">elif</span> condition_i:</span><br><span class="line">    statement_i</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statement_n</span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

NameError                                 Traceback (most recent call last)

&lt;ipython-input-5-fefccca48302&gt; in &lt;module&gt;
----&gt; 1 if condition_1:
      2     statement_1
      3 elif condition_2:
      4     statement_2
      5 elif condition_i:


NameError: name &apos;condition_1&apos; is not defined</code></pre><p>整个条件语句是顺序执行的，如果遇到一个条件满足，比如 condition_i 满足时，在执行完 statement_i 后，便会退出整个 if、elif、else 条件语句，而不会继续向下执行。这个语句在工作中很常用，比如下面的这个例子。</p>
<p>实际工作中，我们经常用 ID 表示一个事物的属性，然后进行条件判断并且输出。比如，在 integrity 的工作中，通常用 0、1、2 分别表示一部电影的色情暴力程度。其中，0 的程度最高，是 red 级别；1 其次，是 yellow 级别；2 代表没有质量问题，属于 green。</p>
<p>如果给定一个 ID，要求输出某部电影的质量评级，则代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> id == <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">'red'</span>)</span><br><span class="line"><span class="keyword">elif</span> id == <span class="number">1</span>:</span><br><span class="line">    print(<span class="string">'yellow'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'green'</span>)</span><br></pre></td></tr></table></figure>

<p>不过要注意，if 语句是可以单独使用的，但 elif、else 都必须和 if 成对使用。</p>
<p>另外，在我们进行条件判断时， 不少人喜欢省略判断的条件，比如写成下面这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> s: <span class="comment"># s is a string</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> l: <span class="comment"># l is a list</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> i: <span class="comment"># i is an int</span></span><br><span class="line">    ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>不过，切记，在实际写代码时，我们鼓励，除了 boolean 类型的数据，条件判断最好是显性的。比如，在判断一个整型数是否为 0 时，我们最好写出判断的条件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">    print(i)</span><br><span class="line"><span class="comment"># 而不是只写出变量名：</span></span><br><span class="line"><span class="keyword">if</span> i:</span><br><span class="line">    print(i)</span><br><span class="line">s = <span class="string">"string"</span></span><br><span class="line"><span class="keyword">if</span> s != <span class="number">0</span>:</span><br><span class="line">    print(s)</span><br><span class="line"><span class="comment"># 而不是只写出变量名：</span></span><br><span class="line"><span class="keyword">if</span> s:</span><br><span class="line">    print(s)</span><br><span class="line">    </span><br><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]    </span><br><span class="line"><span class="keyword">if</span> l != <span class="number">0</span>:</span><br><span class="line">    print(l)</span><br><span class="line"><span class="comment"># 而不是只写出变量名：</span></span><br><span class="line"><span class="keyword">if</span> l:</span><br><span class="line">    print(l)</span><br></pre></td></tr></table></figure>

<pre><code>1
1
string
string
[1, 2, 3]
[1, 2, 3]</code></pre><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>讲完了条件语句，我们接着来看循环语句。所谓循环，顾名思义，本质上就是遍历集合中的元素。和其他语言一样，Python 中的循环一般通过 for 循环和 while 循环实现。</p>
<p>比如，我们有一个列表，需要遍历列表中的所有元素并打印输出，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> l:</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure>

<p>你看，是不是很简单呢？</p>
<p>其实，Python 中的数据结构只要是可迭代的（iterable），比如列表、集合等等，那么都可以通过下面这种方式遍历：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> &lt;iterable&gt;:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>这里需要单独强调一下字典。字典本身只有键是可迭代的，如果我们要遍历它的值或者是键值对，就需要通过其内置的函数 values() 或者 items() 实现。其中，values() 返回字典的值的集合，items() 返回键值对的集合。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'name'</span>: <span class="string">'jason'</span>, <span class="string">'dob'</span>: <span class="string">'2000-01-01'</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> d: <span class="comment"># 遍历字典的键</span></span><br><span class="line">    print(k)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> d.values(): <span class="comment"># 遍历字典的值</span></span><br><span class="line">    print(v)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> d.items(): <span class="comment"># 遍历字典的键值对</span></span><br><span class="line">    print(<span class="string">'key: &#123;&#125;, value: &#123;&#125;'</span>.format(k, v))</span><br></pre></td></tr></table></figure>

<pre><code>name
dob
gender
jason
2000-01-01
male
key: name, value: jason
key: dob, value: 2000-01-01
key: gender, value: male</code></pre><p>看到这里你也许会问，有没有办法通过集合中的索引来遍历元素呢？当然可以，其实这种情况在实际工作中还是很常见的，甚至很多时候，我们还得根据索引来做一些条件判断。</p>
<p>我们通常通过 range() 这个函数，拿到索引，再去遍历访问集合中的元素。比如下面的代码，遍历一个列表中的元素，当索引小于 5 时，打印输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">0</span>, len(l)):</span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="number">5</span>:</span><br><span class="line">        print(l[index])  </span><br><span class="line"><span class="comment"># enumerate 当我们同时需要索引和元素时，还有一种更简洁的方式，那就是通过 Python 内置的函数 enumerate()。</span></span><br><span class="line"><span class="comment"># 用它来遍历集合，不仅返回每个元素，并且还返回其对应的索引，这样一来，上面的例子就可以写成:       </span></span><br><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">for</span> index, item <span class="keyword">in</span> enumerate(l):</span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="number">5</span>:</span><br><span class="line">        print(item)</span><br></pre></td></tr></table></figure>

<p>在循环语句中，我们还常常搭配 continue 和 break 一起使用。所谓 continue，就是让程序跳过当前这层循环，继续执行下面的循环；而 break 则是指完全跳出所在的整个循环体。在循环中适当加入 continue 和 break，往往能使程序更加简洁、易读。</p>
<p>比如，给定两个字典，分别是产品名称到价格的映射，和产品名称到颜色列表的映射。我们要找出价格小于 1000，并且颜色不是红色的所有产品名称和颜色的组合。如果不用 continue，代码应该是下面这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># name_price: 产品名称 (str) 到价格 (int) 的映射字典</span></span><br><span class="line"><span class="comment"># name_color: 产品名字 (str) 到颜色 (list of str) 的映射字典</span></span><br><span class="line"><span class="keyword">for</span> name, price <span class="keyword">in</span> name_price.items():</span><br><span class="line">    <span class="keyword">if</span> price &lt; <span class="number">1000</span>:</span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> name_color:</span><br><span class="line">            <span class="keyword">for</span> color <span class="keyword">in</span> name_color[name]:</span><br><span class="line">                <span class="keyword">if</span> color != <span class="string">'red'</span>:</span><br><span class="line">                    print(<span class="string">'name: &#123;&#125;, color: &#123;&#125;'</span>.format(name, color))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'name: &#123;&#125;, color: &#123;&#125;'</span>.format(name, <span class="string">'None'</span>))</span><br></pre></td></tr></table></figure>

<p>而加入 continue 后，代码显然清晰了很多：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># name_price: 产品名称 (str) 到价格 (int) 的映射字典</span></span><br><span class="line"><span class="comment"># name_color: 产品名字 (str) 到颜色 (list of str) 的映射字典</span></span><br><span class="line"><span class="keyword">for</span> name, price <span class="keyword">in</span> name_price.items():</span><br><span class="line">    <span class="keyword">if</span> price &gt;= <span class="number">1000</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> name_color:</span><br><span class="line">        print(<span class="string">'name: &#123;&#125;, color: &#123;&#125;'</span>.format(name, <span class="string">'None'</span>))</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">for</span> color <span class="keyword">in</span> name_color[name]:</span><br><span class="line">        <span class="keyword">if</span> color == <span class="string">'red'</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        print(<span class="string">'name: &#123;&#125;, color: &#123;&#125;'</span>.format(name, color))</span><br></pre></td></tr></table></figure>

<p>我们可以看到，按照第一个版本的写法，从开始一直到打印输出符合条件的产品名称和颜色，共有 5 层 for 或者 if 的嵌套；但第二个版本加入了 continue 后，只有 3 层嵌套。</p>
<p>显然，如果代码中出现嵌套里还有嵌套的情况，代码便会变得非常冗余、难读，也不利于后续的调试、修改。因此，我们要尽量避免这种多层嵌套的情况。</p>
<p>前面讲了 for 循环，对于 while 循环，原理也是一样的。它表示当 condition 满足时，一直重复循环内部的操作，直到 condition 不再满足，就跳出循环体。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition:</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>

<p>很多时候，for 循环和 while 循环可以互相转换，比如要遍历一个列表，我们用 while 循环同样可以完成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> index &lt; len(l):</span><br><span class="line">    print(l[index])</span><br><span class="line">    index += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>那么，两者的使用场景又有什么区别呢？</p>
<p>通常来说，如果你只是遍历一个已知的集合，找出满足条件的元素，并进行相应的操作，那么使用 for 循环更加简洁。但如果你需要在满足某个条件前，不停地重复某些操作，并且没有特定的集合需要去遍历，那么一般则会使用 while 循环。</p>
<p>比如，某个交互式问答系统，用户输入文字，系统会根据内容做出相应的回答。为了实现这个功能，我们一般会使用 while 循环，大致代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        text = input(<span class="string">'Please enter your questions, enter "q" to exit'</span>)</span><br><span class="line">        <span class="keyword">if</span> text == <span class="string">'q'</span>:</span><br><span class="line">            print(<span class="string">'Exit system'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        print(response)</span><br><span class="line">    <span class="keyword">except</span> <span class="keyword">as</span> err:</span><br><span class="line">        print(<span class="string">'Encountered error: &#123;&#125;'</span>.format(err))</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>同时需要注意的是，for 循环和 while 循环的效率问题。比如下面的 while 循环：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">1000000</span>:</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"><span class="comment"># 将这个表达式分解开来，其实就等同于下面这样的嵌套结构：    </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">1000000</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>究竟哪个效率高呢？</p>
<p>要知道，range() 函数是直接由 C 语言写的，调用它速度非常快。而 while 循环中的“i += 1”这个操作，得通过 Python 的解释器间接调用底层的 C 语言；并且这个简单的操作，又涉及到了对象的创建和删除（因为 i 是整型，是 immutable，i += 1 相当于 i = new int(i + 1)）。所以，显然，for 循环的效率更胜一筹。</p>
<h3 id="条件与循环的复用"><a href="#条件与循环的复用" class="headerlink" title="条件与循环的复用"></a>条件与循环的复用</h3><p>前面两部分讲了条件与循环的一些基本操作，接下来，我们重点来看它们的进阶操作，让程序变得更简洁高效。</p>
<p>在阅读代码的时候，你应该常常会发现，有很多将条件与循环并做一行的操作，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expression1 <span class="keyword">if</span> condition <span class="keyword">else</span> expression2 <span class="keyword">for</span> item <span class="keyword">in</span> iterable</span><br></pre></td></tr></table></figure>

<p>将这个表达式分解开来，其实就等同于下面这样的嵌套结构：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> iterable:</span><br><span class="line">    <span class="keyword">if</span> condition:</span><br><span class="line">        expression1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        expression2</span><br></pre></td></tr></table></figure>

<p>而如果没有 else 语句，则需要写成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expression <span class="keyword">for</span> item <span class="keyword">in</span> iterable <span class="keyword">if</span> condition</span><br></pre></td></tr></table></figure>

<p>举个例子，比如我们要绘制 y = 2*|x| + 5 的函数图像，给定集合 x 的数据点，需要计算出 y 的数据集合，那么只用一行代码，就可以很轻松地解决问题了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = [value * <span class="number">2</span> + <span class="number">5</span> <span class="keyword">if</span> value &gt; <span class="number">0</span> <span class="keyword">else</span> -value * <span class="number">2</span> + <span class="number">5</span> <span class="keyword">for</span> value <span class="keyword">in</span> x]</span><br></pre></td></tr></table></figure>

<p>再比如我们在处理文件中的字符串时，常常遇到的一个场景：将文件中逐行读取的一个完整语句，按逗号分割单词，去掉首位的空字符，并过滤掉长度小于等于 3 的单词，最后返回由单词组成的列表。这同样可以简洁地表达成一行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">' Today,  is, Sunday'</span></span><br><span class="line">text_list = [s.strip() <span class="keyword">for</span> s <span class="keyword">in</span> text.split(<span class="string">','</span>) <span class="keyword">if</span> len(s.strip()) &gt; <span class="number">3</span>]</span><br><span class="line">print(text_list)</span><br></pre></td></tr></table></figure>

<pre><code>[&apos;Today&apos;, &apos;Sunday&apos;]</code></pre><p>当然，这样的复用并不仅仅局限于一个循环。比如，给定两个列表 x、y，要求返回 x、y 中所有元素对组成的元祖，相等情况除外。那么，你也可以很容易表示出来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(xx, yy) <span class="keyword">for</span> xx <span class="keyword">in</span> x <span class="keyword">for</span> yy <span class="keyword">in</span> y <span class="keyword">if</span> xx != yy]</span><br></pre></td></tr></table></figure>

<p>这样的写法就等价于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">l = []</span><br><span class="line"><span class="keyword">for</span> xx <span class="keyword">in</span> x:</span><br><span class="line">    <span class="keyword">for</span> yy <span class="keyword">in</span> y:</span><br><span class="line">        <span class="keyword">if</span> xx != yy:</span><br><span class="line">            l.append((xx, yy))</span><br></pre></td></tr></table></figure>

<p>熟练之后，你会发现这种写法非常方便。当然，如果遇到逻辑很复杂的复用，你可能会觉得写成一行难以理解、容易出错。那种情况下，用正常的形式表达，也不失为一种好的规范和选择。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>今天这节课，我们一起学习了条件与循环的基本概念、进阶用法以及相应的应用。这里，我重点强调几个易错的地方。</p>
<ul>
<li><p>在条件语句中，if 可以单独使用，但是 elif 和 else 必须和 if 同时搭配使用；而 If 条件语句的判断，除了 boolean 类型外，其他的最好显示出来。</p>
</li>
<li><p>在 for 循环中，如果需要同时访问索引和元素，你可以使用 enumerate() 函数来简化代码。</p>
</li>
<li><p>写条件与循环时，合理利用 continue 或者 break 来避免复杂的嵌套，是十分重要的。</p>
</li>
<li><p>要注意条件与循环的复用，简单功能往往可以用一行直接完成，极大地提高代码质量与效率。</p>
</li>
</ul>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>最后给你留一个思考题。给定下面两个列表 attributes 和 values，要求针对 values 中每一组子列表 value，输出其和 attributes 中的键对应后的字典，最后返回字典组成的列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">attributes = [<span class="string">'name'</span>, <span class="string">'dob'</span>, <span class="string">'gender'</span>]</span><br><span class="line">values = [[<span class="string">'jason'</span>, <span class="string">'2000-01-01'</span>, <span class="string">'male'</span>], </span><br><span class="line">[<span class="string">'mike'</span>, <span class="string">'1999-01-01'</span>, <span class="string">'male'</span>],</span><br><span class="line">[<span class="string">'nancy'</span>, <span class="string">'2001-02-01'</span>, <span class="string">'female'</span>]</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># expected outout:</span></span><br><span class="line">[&#123;<span class="string">'name'</span>: <span class="string">'jason'</span>, <span class="string">'dob'</span>: <span class="string">'2000-01-01'</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;, </span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'mike'</span>, <span class="string">'dob'</span>: <span class="string">'1999-01-01'</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;, </span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'nancy'</span>, <span class="string">'dob'</span>: <span class="string">'2001-02-01'</span>, <span class="string">'gender'</span>: <span class="string">'female'</span>&#125;]</span><br></pre></td></tr></table></figure>




<pre><code>[{&apos;name&apos;: &apos;jason&apos;, &apos;dob&apos;: &apos;2000-01-01&apos;, &apos;gender&apos;: &apos;male&apos;},
 {&apos;name&apos;: &apos;mike&apos;, &apos;dob&apos;: &apos;1999-01-01&apos;, &apos;gender&apos;: &apos;male&apos;},
 {&apos;name&apos;: &apos;nancy&apos;, &apos;dob&apos;: &apos;2001-02-01&apos;, &apos;gender&apos;: &apos;female&apos;}]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">attributes = [<span class="string">'name'</span>, <span class="string">'dob'</span>, <span class="string">'gender'</span>]</span><br><span class="line">values = [[<span class="string">'jason'</span>, <span class="string">'2000-01-01'</span>, <span class="string">'male'</span>], </span><br><span class="line">[<span class="string">'mike'</span>, <span class="string">'1999-01-01'</span>, <span class="string">'male'</span>],</span><br><span class="line">[<span class="string">'nancy'</span>, <span class="string">'2001-02-01'</span>, <span class="string">'female'</span>]</span><br><span class="line">]</span><br><span class="line">result = [&#123;attributes[index]:value[index] <span class="keyword">for</span> index <span class="keyword">in</span> range(len(attributes))&#125; <span class="keyword">for</span> value <span class="keyword">in</span> values]</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">result2 = [dict(zip(attributes,value)) <span class="keyword">for</span> value <span class="keyword">in</span> values]</span><br><span class="line">print(result2)</span><br></pre></td></tr></table></figure>

<pre><code>[{&apos;name&apos;: &apos;jason&apos;, &apos;dob&apos;: &apos;2000-01-01&apos;, &apos;gender&apos;: &apos;male&apos;}, {&apos;name&apos;: &apos;mike&apos;, &apos;dob&apos;: &apos;1999-01-01&apos;, &apos;gender&apos;: &apos;male&apos;}, {&apos;name&apos;: &apos;nancy&apos;, &apos;dob&apos;: &apos;2001-02-01&apos;, &apos;gender&apos;: &apos;female&apos;}]
[{&apos;name&apos;: &apos;jason&apos;, &apos;dob&apos;: &apos;2000-01-01&apos;, &apos;gender&apos;: &apos;male&apos;}, {&apos;name&apos;: &apos;mike&apos;, &apos;dob&apos;: &apos;1999-01-01&apos;, &apos;gender&apos;: &apos;male&apos;}, {&apos;name&apos;: &apos;nancy&apos;, &apos;dob&apos;: &apos;2001-02-01&apos;, &apos;gender&apos;: &apos;female&apos;}]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;dict()                        <span class="comment"># 创建空字典</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict(a=<span class="string">'a'</span>, b=<span class="string">'b'</span>, t=<span class="string">'t'</span>)     <span class="comment"># 传入关键字</span></span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="string">'a'</span>, <span class="string">'b'</span>: <span class="string">'b'</span>, <span class="string">'t'</span>: <span class="string">'t'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict(zip([<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))   <span class="comment"># 映射函数方式来构造字典</span></span><br><span class="line">&#123;<span class="string">'three'</span>: <span class="number">3</span>, <span class="string">'two'</span>: <span class="number">2</span>, <span class="string">'one'</span>: <span class="number">1</span>&#125; </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict([(<span class="string">'one'</span>, <span class="number">1</span>), (<span class="string">'two'</span>, <span class="number">2</span>), (<span class="string">'three'</span>, <span class="number">3</span>)])    <span class="comment"># 可迭代对象方式来构造字典</span></span><br><span class="line">&#123;<span class="string">'three'</span>: <span class="number">3</span>, <span class="string">'two'</span>: <span class="number">2</span>, <span class="string">'one'</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>


<pre><code>  File &quot;&lt;ipython-input-31-88ea8d10853c&gt;&quot;, line 4
    b = dict(&apos;one&apos;= 1)
            ^
SyntaxError: keyword can&apos;t be an expression</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/05/06Python%E9%BB%91%E7%AE%B1%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/05/06Python%E9%BB%91%E7%AE%B1%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93/" itemprop="url">06 | Python “黑箱”：输入与输出</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-05T14:13:07+08:00">
                2019-12-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/" itemprop="url" rel="index">
                    <span itemprop="name">python核心技术与实战</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/05/06Python%E9%BB%91%E7%AE%B1%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/12/05/06Python%E9%BB%91%E7%AE%B1%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Python 程序也是一个黑箱：通过输入流将数据送达，通过输出流将处理后的数据送出，可能 Python 解释器后面藏了一个人，还是一个史莱哲林？No one cares。</p>
<h3 id="输入输出基础"><a href="#输入输出基础" class="headerlink" title="输入输出基础"></a>输入输出基础</h3><p>最简单直接的输入来自键盘操作，比如下面这个例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">name = input(<span class="string">'your name:'</span>)</span><br><span class="line">gender = input(<span class="string">'you are a boy?(y/n)'</span>)</span><br><span class="line">welcome_str = <span class="string">'Welcome to the matrix &#123;prefix&#125; &#123;name&#125;.'</span></span><br><span class="line">welcome_dic = &#123;</span><br><span class="line">    <span class="string">'prefix'</span>: <span class="string">'Mr.'</span> <span class="keyword">if</span> gender == <span class="string">'y'</span> <span class="keyword">else</span> <span class="string">'Mrs'</span>,</span><br><span class="line">    <span class="string">'name'</span>: name</span><br><span class="line">&#125;</span><br><span class="line">print(<span class="string">'authorizing...'</span>)</span><br><span class="line">print(welcome_str.format(**welcome_dic))</span><br></pre></td></tr></table></figure>

<pre><code>your name:lv
you are a boy?(y/n)y
authorizing...
Welcome to the matrix Mr. lv.</code></pre><p>input() 函数暂停程序运行，同时等待键盘输入；直到回车被按下，函数的参数即为提示语，输入的类型永远是字符串型（str）。注意，初学者在这里很容易犯错，下面的例子我会讲到。print() 函数则接受字符串、数字、字典、列表甚至一些自定义类的输出。</p>
<p>我们再来看下面这个例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = input()</span><br><span class="line">b = input()</span><br><span class="line">print(<span class="string">'a + b = &#123;&#125;'</span>.format(a + b))</span><br><span class="line">print(<span class="string">'type of a is &#123;&#125;, type of b is &#123;&#125;'</span>.format(type(a), type(b)))</span><br><span class="line">print(<span class="string">'a + b = &#123;&#125;'</span>.format(int(a) + int(b)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果输入1和1</span></span><br><span class="line"><span class="comment">#1</span></span><br><span class="line"><span class="comment">#1</span></span><br><span class="line"><span class="comment">#a + b = 11</span></span><br><span class="line"><span class="comment">#type of a is &lt;class 'str'&gt;, type of b is &lt;class 'str'&gt;</span></span><br><span class="line"><span class="comment">#a + b = 2</span></span><br></pre></td></tr></table></figure>

<pre><code>1
1
a + b = 11
type of a is &lt;class &apos;str&apos;&gt;, type of b is &lt;class &apos;str&apos;&gt;
a + b = 2</code></pre><p>这里注意，把 str 强制转换为 int 请用 int()，转为浮点数请用 float()。而在生产环境中使用强制转换时，请记得加上 try except（即错误和异常处理，专栏后面文章会讲到）。</p>
<p>Python 对 <code>int 类型没有最大限制</code>（相比之下， C++ 的 int 最大为 2147483647，超过这个数字会产生溢出），但是对 float 类型依然有精度限制。这些特点，除了在一些算法竞赛中要注意，在生产环境中也要时刻提防，避免因为对边界条件判断不清而造成 bug 甚至 0day（危重安全漏洞）。</p>
<p>我们回望一下币圈。2018 年 4 月 23 日中午 11 点 30 分左右，BEC 代币智能合约被黑客攻击。黑客利用数据溢出的漏洞，攻击与美图合作的公司美链 BEC 的智能合约，成功地向两个地址转出了天量级别的 BEC 代币，导致市场上的海量 BEC 被抛售，该数字货币的价值也几近归零，给 BEC 市场交易带来了毁灭性的打击。</p>
<p>由此可见，虽然输入输出和类型处理事情简单，但我们一定要慎之又慎。毕竟相当比例的安全漏洞，都来自随意的 I/O 处理。</p>
<h3 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h3><p>命令行的输入输出，只是 Python 交互的最基本方式，适用一些简单小程序的交互。而生产级别的 Python 代码，大部分 I/O 则来自于文件、网络、其他进程的消息等等。</p>
<p>接下来，我们来详细分析一个文本文件读写。假设我们有一个文本文件 in.txt，内容如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I have a dream that my four little children will one day live <span class="keyword">in</span> a nation where they will <span class="keyword">not</span> be judged by the color of their skin but by the content of their character. I have a dream today.</span><br><span class="line"> </span><br><span class="line">I have a dream that one day down <span class="keyword">in</span> Alabama, <span class="keyword">with</span> its vicious racists, . . . one day right there <span class="keyword">in</span> Alabama little black boys <span class="keyword">and</span> black girls will be able to join hands <span class="keyword">with</span> little white boys <span class="keyword">and</span> white girls <span class="keyword">as</span> sisters <span class="keyword">and</span> brothers. I have a dream today.</span><br><span class="line"> </span><br><span class="line">I have a dream that one day every valley shall be exalted, every hill <span class="keyword">and</span> mountain shall be made low, the rough places will be made plain, <span class="keyword">and</span> the crooked places will be made straight, <span class="keyword">and</span> the glory of the Lord shall be revealed, <span class="keyword">and</span> all flesh shall see it together.</span><br><span class="line"> </span><br><span class="line">This <span class="keyword">is</span> our hope. . . With this faith we will be able to hew out of the mountain of despair a stone of hope. With this faith we will be able to transform the jangling discords of our nation into a beautiful symphony of brotherhood. With this faith we will be able to work together, to pray together, to struggle together, to go to jail together, to stand up <span class="keyword">for</span> freedom together, knowing that we will be free one day. . . .</span><br><span class="line"> </span><br><span class="line">And when this happens, <span class="keyword">and</span> when we allow freedom ring, when we let it ring <span class="keyword">from</span> every village <span class="keyword">and</span> every hamlet, <span class="keyword">from</span> every state <span class="keyword">and</span> every city, we will be able to speed up that day when all of God<span class="string">'s children, black men and white men, Jews and Gentiles, Protestants and Catholics, will be able to join hands and sing in the words of the old Negro spiritual: "Free at last! Free at last! Thank God Almighty, we are free at last!"</span></span><br></pre></td></tr></table></figure>

<p>好，让我们来做一个简单的 NLP（自然语言处理）任务。如果你对此不太了解也没有影响，我会带你一步步完成这个任务。</p>
<p>首先，我们要清楚 NLP 任务的基本步骤，也就是下面的四步：</p>
<ol>
<li><p>读取文件；</p>
</li>
<li><p>去除所有标点符号和换行符，并把所有大写变成小写；</p>
</li>
<li><p>合并相同的词，统计每个词出现的频率，并按照词频从大到小排序；</p>
</li>
<li><p>将结果按行输出到文件 out.txt。</p>
</li>
</ol>
<p>你可以自己先思考一下，用 Python 如何解决这个问题。这里，我也给出了我的代码，并附有详细的注释。我们一起来看下这段代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">"""</span></span><br><span class="line"><span class="string">I have a dream that my four little children will one day live in a nation where they will not be judged by the color of their skin but by the content of their character. I have a dream today.</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">I have a dream that one day down in Alabama, with its vicious racists, . . . one day right there in Alabama little black boys and black girls will be able to join hands with little white boys and white girls as sisters and brothers. I have a dream today.</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">I have a dream that one day every valley shall be exalted, every hill and mountain shall be made low, the rough places will be made plain, and the crooked places will be made straight, and the glory of the Lord shall be revealed, and all flesh shall see it together.</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">This is our hope. . . With this faith we will be able to hew out of the mountain of despair a stone of hope. With this faith we will be able to transform the jangling discords of our nation into a beautiful symphony of brotherhood. With this faith we will be able to work together, to pray together, to struggle together, to go to jail together, to stand up for freedom together, knowing that we will be free one day. . . .</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">And when this happens, and when we allow freedom ring, when we let it ring from every village and every hamlet, from every state and every city, we will be able to speed up that day when all of God's children, black men and white men, Jews and Gentiles, Protestants and Catholics, will be able to join hands and sing in the words of the old Negro spiritual: "Free at last! Free at last! Thank God Almighty, we are free at last!"</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 你不用太关心这个函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(text)</span>:</span></span><br><span class="line">    <span class="comment"># 使用正则表达式去除标点符号和换行符</span></span><br><span class="line">    text = re.sub(<span class="string">r'[^\w ]'</span>, <span class="string">' '</span>, text)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 转为小写</span></span><br><span class="line">    text = text.lower()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 生成所有单词的列表</span></span><br><span class="line">    word_list = text.split(<span class="string">' '</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 去除空白单词</span></span><br><span class="line">    word_list = filter(<span class="literal">None</span>, word_list)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 生成单词和词频的字典</span></span><br><span class="line">    word_cnt = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> word_list:</span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> word_cnt:</span><br><span class="line">            word_cnt[word] = <span class="number">0</span></span><br><span class="line">        word_cnt[word] += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 按照词频排序</span></span><br><span class="line">    sorted_word_cnt = sorted(word_cnt.items(), key=<span class="keyword">lambda</span> kv: kv[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sorted_word_cnt</span><br><span class="line"> </span><br><span class="line"><span class="comment"># with open('in.txt', 'r') as fin:</span></span><br><span class="line"><span class="comment">#     text = fin.read()</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># word_and_freq = parse(text)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># with open('out.txt', 'w') as fout:</span></span><br><span class="line"><span class="comment">#     for word, freq in word_and_freq:</span></span><br><span class="line"><span class="comment">#         fout.write('&#123;&#125; &#123;&#125;\n'.format(word, freq))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">word_and_freq = parse(text)</span><br><span class="line"><span class="keyword">for</span> word, freq <span class="keyword">in</span> word_and_freq:</span><br><span class="line">    print(word, freq)</span><br></pre></td></tr></table></figure>

<pre><code>and 15
be 13
will 11
to 11
the 10
of 10
a 8
we 8
day 6
able 6
every 6
together 6
i 5
have 5
dream 5
that 5
one 5
with 5
this 5
in 4
shall 4
free 4
when 4
little 3
black 3
white 3
made 3
faith 3
at 3
last 3
children 2
nation 2
by 2
their 2
today 2
alabama 2
boys 2
girls 2
join 2
hands 2
mountain 2
places 2
all 2
it 2
our 2
hope 2
up 2
freedom 2
ring 2
from 2
god 2
men 2
my 1
four 1
live 1
where 1
they 1
not 1
judged 1
color 1
skin 1
but 1
content 1
character 1
down 1
its 1
vicious 1
racists 1
right 1
there 1
as 1
sisters 1
brothers 1
valley 1
exalted 1
hill 1
low 1
rough 1
plain 1
crooked 1
straight 1
glory 1
lord 1
revealed 1
flesh 1
see 1
is 1
hew 1
out 1
despair 1
stone 1
transform 1
jangling 1
discords 1
into 1
beautiful 1
symphony 1
brotherhood 1
work 1
pray 1
struggle 1
go 1
jail 1
stand 1
for 1
knowing 1
happens 1
allow 1
let 1
village 1
hamlet 1
state 1
city 1
speed 1
s 1
jews 1
gentiles 1
protestants 1
catholics 1
sing 1
words 1
old 1
negro 1
spiritual 1
thank 1
almighty 1
are 1</code></pre><p>你不用太关心 parse() 函数的具体实现，你只需要知道，它做的事情是把输入的 text 字符串，转化为我们需要的排序后的词频统计。而 sorted_word_cnt 则是一个二元组的列表（list of tuples）。</p>
<p>首先我们需要先了解一下，计算机中文件访问的基础知识。事实上，计算机内核（kernel）对文件的处理相对比较复杂，涉及到内核模式、虚拟文件系统、锁和指针等一系列概念，这些内容我不会深入讲解，我只说一些基础但足够使用的知识。</p>
<p>我们先要用 open() 函数拿到文件的指针。其中，第一个参数指定文件位置（相对位置或者绝对位置）；第二个参数，如果是 ‘r’表示读取，如果是’w’ 则表示写入，当然也可以用 ‘rw’ ，表示读写都要。a 则是一个不太常用（但也很有用）的参数，表示追加（append），这样打开的文件，如果需要写入，会从原始文件的最末尾开始写入。</p>
<p>这里我插一句，在 Facebook 的工作中，代码权限管理非常重要。如果你只需要读取文件，就不要请求写入权限。这样在某种程度上可以降低 bug 对整个系统带来的风险。</p>
<p>好，回到我们的话题。在拿到指针后，我们可以通过 read() 函数，来读取文件的全部内容。代码 text = fin.read() ，即表示把文件所有内容读取到内存中，并赋值给变量 text。这么做自然也是有利有弊：</p>
<ul>
<li><p>优点是方便，接下来我们可以很方便地调用 parse 函数进行分析；</p>
</li>
<li><p>缺点是如果文件过大，一次性读取可能造成内存崩溃。</p>
</li>
</ul>
<p>这时，我们可以给 read 指定参数 size ，用来表示读取的最大长度。还可以通过 readline() 函数，每次读取一行，这种做法常用于数据挖掘（Data Mining）中的数据清洗，在写一些小的程序时非常轻便。如果每行之间没有关联，这种做法也可以降低内存的压力。而 write() 函数，可以把参数中的字符串输出到文件中，也很容易理解。</p>
<p>这里我需要简单提一下 with 语句（后文会详细讲到）。open() 函数对应于 close() 函数，也就是说，如果你打开了文件，在完成读取任务后，就应该立刻关掉它。而如果你使用了 with 语句，就不需要显式调用 close()。在 with 的语境下任务执行完毕后，close() 函数会被自动调用，代码也简洁很多。</p>
<p>最后需要注意的是，所有 I/O 都应该进行错误处理。因为 I/O 操作可能会有各种各样的情况出现，而一个健壮（robust）的程序，需要能应对各种情况的发生，而不应该崩溃（故意设计的情况除外）。</p>
<h3 id="JSON-序列化与实战"><a href="#JSON-序列化与实战" class="headerlink" title="JSON 序列化与实战"></a>JSON 序列化与实战</h3><p>最后，我来讲一个和实际应用很贴近的知识点。</p>
<p>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，它的设计意图是把所有事情都用设计的字符串来表示，这样既方便在互联网上传递信息，也方便人进行阅读（相比一些 binary 的协议）。JSON 在当今互联网中应用非常广泛，也是每一个用 Python 程序员应当熟练掌握的技能点。</p>
<p>设想一个情景，你要向交易所购买一定数额的股票。那么，你需要提交股票代码、方向（买入 / 卖出）、订单类型（市价 / 限价）、价格（如果是限价单）、数量等一系列参数，而这些数据里，有字符串，有整数，有浮点数，甚至还有布尔型变量，全部混在一起并不方便交易所解包。</p>
<p>那该怎么办呢？</p>
<p>其实，我们要讲的 JSON ，正能解决这个场景。你可以把它简单地理解为两种黑箱：</p>
<ul>
<li><p>第一种，输入这些杂七杂八的信息，比如 Python 字典，输出一个字符串；</p>
</li>
<li><p>第二种，输入这个字符串，可以输出包含原始信息的 Python 字典。</p>
</li>
</ul>
<p>具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"> </span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">'symbol'</span>: <span class="string">'123456'</span>,</span><br><span class="line">    <span class="string">'type'</span>: <span class="string">'limit'</span>,</span><br><span class="line">    <span class="string">'price'</span>: <span class="number">123.4</span>,</span><br><span class="line">    <span class="string">'amount'</span>: <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">params_str = json.dumps(params)</span><br><span class="line"> </span><br><span class="line">print(<span class="string">'after json serialization'</span>)</span><br><span class="line">print(<span class="string">'type of params_str = &#123;&#125;,type of params = &#123;&#125;, params_str = &#123;&#125;'</span>.format(type(params_str),type(params), params))</span><br><span class="line"> </span><br><span class="line">original_params = json.loads(params_str)</span><br><span class="line"> </span><br><span class="line">print(<span class="string">'after json deserialization'</span>)</span><br><span class="line">print(<span class="string">'type of original_params = &#123;&#125;, original_params = &#123;&#125;'</span>.format(type(original_params), original_params))</span><br></pre></td></tr></table></figure>

<pre><code>after json serialization
type of params_str = &lt;class &apos;str&apos;&gt;,type of params = &lt;class &apos;dict&apos;&gt;, params_str = {&apos;symbol&apos;: &apos;123456&apos;, &apos;type&apos;: &apos;limit&apos;, &apos;price&apos;: 123.4, &apos;amount&apos;: 23}
after json deserialization
type of original_params = &lt;class &apos;dict&apos;&gt;, original_params = {&apos;symbol&apos;: &apos;123456&apos;, &apos;type&apos;: &apos;limit&apos;, &apos;price&apos;: 123.4, &apos;amount&apos;: 23}</code></pre><p>其中，</p>
<ul>
<li><p>json.dumps() 这个函数，接受 Python 的基本数据类型，然后将其序列化为 string；</p>
</li>
<li><p>而 json.loads() 这个函数，接受一个合法字符串，然后将其反序列化为 Python 的基本数据类型。</p>
</li>
</ul>
<p>是不是很简单呢？</p>
<p>不过还是那句话，请记得加上错误处理。不然，哪怕只是给 json.loads() 发送了一个非法字符串，而你没有 catch 到，程序就会崩溃了。</p>
<p>到这一步，你可能会想，如果我要输出字符串到文件，或者从文件中读取 JSON 字符串，又该怎么办呢？</p>
<p>是的，你仍然可以使用上面提到的 open() 和 read()/write() ，先将字符串读取 / 输出到内存，再进行 JSON 编码 / 解码，当然这有点麻烦。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"> </span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">'symbol'</span>: <span class="string">'123456'</span>,</span><br><span class="line">    <span class="string">'type'</span>: <span class="string">'limit'</span>,</span><br><span class="line">    <span class="string">'price'</span>: <span class="number">123.4</span>,</span><br><span class="line">    <span class="string">'amount'</span>: <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'params.json'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> fout:</span><br><span class="line">    params_str = json.dump(params, fout)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'params.json'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> fin:</span><br><span class="line">    original_params = json.load(fin)</span><br><span class="line"> </span><br><span class="line">print(<span class="string">'after json deserialization'</span>)</span><br><span class="line">print(<span class="string">'type of original_params = &#123;&#125;, original_params = &#123;&#125;'</span>.format(type(original_params), original_params))</span><br></pre></td></tr></table></figure>

<pre><code>after json deserialization
type of original_params = &lt;class &apos;dict&apos;&gt;, original_params = {&apos;symbol&apos;: &apos;123456&apos;, &apos;type&apos;: &apos;limit&apos;, &apos;price&apos;: 123.4, &apos;amount&apos;: 23}</code></pre><p>这样，我们就简单清晰地实现了读写 JSON 字符串的过程。当开发一个第三方应用程序时，你可以通过 JSON 将用户的个人配置输出到文件，方便下次程序启动时自动读取。这也是现在普遍运用的成熟做法。</p>
<p>那么 JSON 是唯一的选择吗？显然不是，它只是轻量级应用中最方便的选择之一。据我所知，在 Google，有类似的工具叫做 Protocol Buffer，当然，Google 已经完全开源了这个工具，你可以自己了解一下使用方法。</p>
<p>相比于 JSON，它的优点是生成优化后的二进制文件，因此性能更好。但与此同时，生成的二进制序列，是不能直接阅读的。它在 TensorFlow 等很多对性能有要求的系统中都有广泛的应用。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这节课，我们主要学习了 Python 的普通 I/O 和文件 I/O，同时了解了 JSON 序列化的基本知识，并通过具体的例子进一步掌握。再次强调一下需要注意的几点：</p>
<ul>
<li><p>I/O 操作需谨慎，一定要进行充分的错误处理，并细心编码，防止出现编码漏洞；</p>
</li>
<li><p>编码时，对内存占用和磁盘占用要有充分的估计，这样在出错时可以更容易找到原因；</p>
</li>
<li><p>JSON 序列化是很方便的工具，要结合实战多多练习；</p>
</li>
<li><p>代码尽量简洁、清晰，哪怕是初学阶段，也要有一颗当元帅的心。</p>
</li>
</ul>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>最后，我给你留了两道思考题。</p>
<p>第一问：你能否把 NLP 例子中的 word count 实现一遍？不过这次，in.txt 可能非常非常大（意味着你不能一次读取到内存中），而 output.txt 不会很大（意味着重复的单词数量很多）。</p>
<p>提示：你可能需要每次读取一定长度的字符串，进行处理，然后再读取下一次的。但是如果单纯按照长度划分，你可能会把一个单词隔断开，所以需要细心处理这种边界情况。</p>
<p>第二问：你应该使用过类似百度网盘、Dropbox 等网盘，但是它们可能空间有限（比如 5GB）。如果有一天，你计划把家里的 100GB 数据传送到公司，可惜你没带 U 盘，于是你想了一个主意：</p>
<p>每次从家里向 Dropbox 网盘写入不超过 5GB 的数据，而公司电脑一旦侦测到新数据，就立即拷贝到本地，然后删除网盘上的数据。等家里电脑侦测到本次数据全部传入公司电脑后，再进行下一次写入，直到所有数据都传输过去。</p>
<p>根据这个想法，你计划在家写一个 server.py，在公司写一个 client.py 来实现这个需求。</p>
<p>提示：我们假设每个文件都不超过 5GB。</p>
<ul>
<li><p>你可以通过写入一个控制文件（config.json）来同步状态。不过，要小心设计状态，这里有可能产生 race condition。</p>
</li>
<li><p>你也可以通过直接侦测文件是否产生，或者是否被删除来同步状态，这是最简单的做法。</p>
</li>
</ul>
<p>不要担心难度问题，尽情写下你的思考，最终代码我也会为你准备好。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们假设 server 电脑上的所有的文件都在 BASR_DIR 中，为了简化不考虑文件夹结构，网盘的路径在 NET_DIR</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> copyfile</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">BASE_DIR = <span class="string">'server/'</span></span><br><span class="line">NET_DIR = <span class="string">'net/'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    filenames = os.listdir(BASE_DIR)</span><br><span class="line">    <span class="keyword">for</span> i, filename <span class="keyword">in</span> enumerate(filenames):</span><br><span class="line">        print(<span class="string">'copying &#123;&#125; into net drive... &#123;&#125;/&#123;&#125;'</span>.format(filename, i + <span class="number">1</span>, len(filenames)))</span><br><span class="line">        copyfile(BASE_DIR + filename, NET_DIR + filename)</span><br><span class="line">        print(<span class="string">'copied &#123;&#125; into net drive, waiting client complete... &#123;&#125;/&#123;&#125;'</span>.format(filename, i + <span class="number">1</span>, len(filenames)))</span><br><span class="line">        <span class="keyword">while</span> os.path.exists(NET_DIR + filename):</span><br><span class="line">            time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">'transferred &#123;&#125; into client. &#123;&#125;/&#123;&#125;'</span>.format(filename, i + <span class="number">1</span>, len(filenames)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们假设 client 电脑上要输出的文件夹在 BASR_DIR ，网盘的路径在 NET_DIR</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> copyfile</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">BASE_DIR = <span class="string">'client/'</span></span><br><span class="line">NET_DIR = <span class="string">'net/'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        filenames = os.listdir(NET_DIR)</span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">            print(<span class="string">'downloading &#123;&#125; into local disk...'</span>.format(filename))</span><br><span class="line">            copyfile(NET_DIR + filename, BASE_DIR + filename)</span><br><span class="line">            os.remove(NET_DIR + filename) <span class="comment"># 我们需要删除这个文件，网盘会提我们同步这个操作，从而 server 知晓已完成</span></span><br><span class="line">            print(<span class="string">'downloaded &#123;&#125; into local disk.'</span>.format(filename))</span><br><span class="line">        time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>json.dumps()— json dict转字符串str<br>json.loads()— str 转dict</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/04/05%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/04/05%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/" itemprop="url">05 | 深入浅出字符串</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-04T19:45:36+08:00">
                2019-12-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/" itemprop="url" rel="index">
                    <span itemprop="name">python核心技术与实战</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/04/05%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/12/04/05%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="字符串基础"><a href="#字符串基础" class="headerlink" title="字符串基础"></a>字符串基础</h3><p>什么是字符串呢？字符串是由独立字符组成的一个序列，通常包含在单引号（’’）双引号（””）或者三引号之中（’’’ ‘’’或””” “””，两者一样），比如下面几种写法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">'jason'</span></span><br><span class="line">city = <span class="string">'beijing'</span></span><br><span class="line">text = <span class="string">"welcome to jike shijian"</span></span><br></pre></td></tr></table></figure>

<p>这里定义了 name、city 和 text 三个变量，都是字符串类型。我们知道，Python 中单引号、双引号和三引号的字符串是一模一样的，没有区别，比如下面这个例子中的 s1、s2、s3 完全一样。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">'hello'</span></span><br><span class="line">s2 = <span class="string">"hello"</span></span><br><span class="line">s3 = <span class="string">"""hello"""</span></span><br><span class="line">s1 == s2 == s3</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>Python 的三引号字符串，则主要应用于多行字符串的情境，比如函数的注释等等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_similarity</span><span class="params">(item1, item2)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Calculate similarity between two items</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        item1: 1st item</span></span><br><span class="line"><span class="string">        item2: 2nd item</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">      similarity score between item1 and item2</span></span><br><span class="line"><span class="string">    """</span></span><br></pre></td></tr></table></figure>

<p>同时，Python 也支持转义字符。所谓的转义字符，就是用反斜杠开头的字符串，来表示一些特定意义的字符。我把常见的的转义字符，总结成了下面这张表格。</p>
<p><img src="/2019/12/04/05%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/img/05-1.png" alt="title"></p>
<p>为了方便你理解，我举一个例子来说明。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'a\nb\tc'</span></span><br><span class="line">print(s)</span><br><span class="line">print(len(s))</span><br></pre></td></tr></table></figure>

<pre><code>a
b    c
5</code></pre><p>这段代码中的’\n’，表示一个字符——换行符；’\t’也表示一个字符——横向制表符。所以，最后打印出来的输出，就是字符 a，换行，字符 b，然后制表符，最后打印字符 c。不过要注意，虽然最后打印的输出横跨了两行，但是整个字符串 s 仍然只有 5 个元素。<br>在转义字符的应用中，最常见的就是换行符’\n’的使用。比如文件读取，如果我们一行行地读取，那么每一行字符串的末尾，都会包含换行符’\n’。而最后做数据处理时，我们往往会丢掉每一行的换行符。</p>
<h3 id="字符串的常用操作"><a href="#字符串的常用操作" class="headerlink" title="字符串的常用操作"></a>字符串的常用操作</h3><p>讲完了字符串的基本原理，下面我们一起来看看字符串的常用操作。你可以把字符串想象成一个由单个字符组成的数组，所以，Python 的字符串同样支持索引，切片和遍历等等操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">'jason'</span></span><br><span class="line">print(name[<span class="number">0</span>])</span><br><span class="line">print(name[<span class="number">1</span>:<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<pre><code>j
as</code></pre><p>和其他数据结构，如列表、元组一样，字符串的索引同样从 0 开始，index=0 表示第一个元素（字符），[index:index+2] 则表示第 index 个元素到 index+1 个元素组成的子字符串。</p>
<p>遍历字符串同样很简单，相当于遍历字符串中的每个字符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> name:</span><br><span class="line">    print(char)</span><br></pre></td></tr></table></figure>

<p>特别要注意，Python 的字符串是不可变的（immutable）。因此，用下面的操作，来改变一个字符串内部的字符是错误的，不允许的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'hello'</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="string">'H'</span></span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="comment"># TypeError: 'str' object does not support item assignment</span></span><br></pre></td></tr></table></figure>

<p>Python 中字符串的改变，通常只能通过创建新的字符串来完成。比如上述例子中，想把’hello’的第一个字符’h’，改为大写的’H’，我们可以采用下面的做法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'H'</span> + s[<span class="number">1</span>:]</span><br><span class="line">s = s.replace(<span class="string">'h'</span>, <span class="string">'H'</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一种方法，是直接用大写的’H’，通过加号’+’操作符，与原字符串切片操作的子字符串拼接而成新的字符串。</p>
</li>
<li><p>第二种方法，是直接扫描原字符串，把小写的’h’替换成大写的’H’，得到新的字符串。</p>
</li>
</ul>
<p>你可能了解到，在其他语言中，如 Java，有可变的字符串类型，比如 StringBuilder，每次添加、改变或删除字符（串），无需创建新的字符串，时间复杂度仅为 O(1)。这样就大大提高了程序的运行效率。</p>
<p>但可惜的是，Python 中并没有相关的数据类型，我们还是得老老实实创建新的字符串。因此，每次想要改变字符串，往往需要 O(n) 的时间复杂度，其中，n 为新字符串的长度。</p>
<p>你可能注意到了，上述例子的说明中，我用的是“往往”、“通常”这样的字眼，并没有说“一定”。这是为什么呢？显然，随着版本的更新，Python 也越来越聪明，性能优化得越来越好了。</p>
<p>这里，我着重讲解一下，使用加法操作符’+=’的字符串拼接方法。因为它是一个例外，打破了字符串不可变的特性。</p>
<p>操作方法如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#  str1 += str2  # 表示 str1 = str1 + str2</span></span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

NameError                                 Traceback (most recent call last)

&lt;ipython-input-7-b341e0578f95&gt; in &lt;module&gt;
----&gt; 1 str1 += str2  # 表示 str1 = str1 + str2


NameError: name &apos;str1&apos; is not defined</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">100000</span>):</span><br><span class="line">    s += str(n)</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>

<pre><code>012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340</code></pre><p>你觉得这个例子的时间复杂度是多少呢？</p>
<p>每次循环，似乎都得创建一个新的字符串；而每次创建一个新的字符串，都需要 O(n) 的时间复杂度。因此，总的时间复杂度就为 O(1) + O(2) + … + O(n) = O(n^2)。这样到底对不对呢？</p>
<p>乍一看，这样分析确实很有道理，但是必须说明，这个结论只适用于老版本的 Python 了。自从 Python2.5 开始，每次处理字符串的拼接操作时（str1 += str2），Python 首先会检测 str1 还有没有其他的引用。如果没有的话，就会尝试原地扩充字符串 buffer 的大小，而不是重新分配一块内存来创建新的字符串并拷贝。这样的话，上述例子中的时间复杂度就仅为 O(n) 了。</p>
<p>因此，以后你在写程序遇到字符串拼接时，如果使用’+=’更方便，就放心地去用吧，不用过分担心效率问题了。</p>
<p>另外，对于字符串拼接问题，除了使用加法操作符，我们还可以使用字符串内置的 join 函数。string.join(iterable)，表示把每个元素都按照指定的格式连接起来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">l = []</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">100000</span>):</span><br><span class="line">    l.append(str(n))</span><br><span class="line">l = <span class="string">' '</span>.join(l)</span><br><span class="line">print(l)</span><br></pre></td></tr></table></figure>

<pre><code>0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 </code></pre><p>由于列表的 append 操作是 O(1) 复杂度，字符串同理。因此，这个含有 for 循环例子的时间复杂度为 n*O(1)=O(n)。</p>
<p>接下来，我们看一下字符串的分割函数 split()。string.split(separator)，表示把字符串按照 separator 分割成子字符串，并返回一个分割后子字符串组合的列表。它常常应用于对数据的解析处理，比如我们读取了某个文件的路径，想要调用数据库的 API，去读取对应的数据，我们通常会写成下面这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query_data</span><span class="params">(namespace, table)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    given namespace and table, query database to get corresponding</span></span><br><span class="line"><span class="string">    data         </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"> </span><br><span class="line">path = <span class="string">'hive://ads/training_table'</span></span><br><span class="line">namespace = path.split(<span class="string">'//'</span>)[<span class="number">1</span>].split(<span class="string">'/'</span>)[<span class="number">0</span>] <span class="comment"># 返回'ads'</span></span><br><span class="line">table = path.split(<span class="string">'//'</span>)[<span class="number">1</span>].split(<span class="string">'/'</span>)[<span class="number">1</span>] <span class="comment"># 返回 'training_table'</span></span><br><span class="line">data = query_data(namespace, table)</span><br></pre></td></tr></table></figure>

<p>此外，常见的函数还有：</p>
<ul>
<li><p>string.strip(str)，表示去掉首尾的 str 字符串；</p>
</li>
<li><p>string.lstrip(str)，表示只去掉开头的 str 字符串；</p>
</li>
<li><p>string.rstrip(str)，表示只去掉尾部的 str 字符串。</p>
</li>
</ul>
<p>这些在数据的解析处理中同样很常见。比如很多时候，从文件读进来的字符串中，开头和结尾都含有空字符，我们需要去掉它们，就可以用 strip() 函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">' my name is jason '</span></span><br><span class="line">s.strip()</span><br></pre></td></tr></table></figure>




<pre><code>&apos;my name is jason&apos;</code></pre><p>当然，Python 中字符串还有很多常用操作，比如，string.find(sub, start, end)，表示从 start 到 end 查找字符串中子字符串 sub 的位置等等。这里，我只强调了最常用并且容易出错的几个函数，其他内容你可以自行查找相应的文档、范例加以了解，我就不一一赘述了。</p>
<h3 id="字符串的格式化"><a href="#字符串的格式化" class="headerlink" title="字符串的格式化"></a>字符串的格式化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id = <span class="number">123</span></span><br><span class="line">name = <span class="string">"jason"</span></span><br><span class="line">print(<span class="string">'no data available for person with id: &#123;&#125;, name: &#123;&#125;'</span>.format(id, name))</span><br><span class="line">print(<span class="string">'no data available for person with id: %s, name: %s'</span> % (id, name))</span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

NameError                                 Traceback (most recent call last)

&lt;ipython-input-14-2445183242b6&gt; in &lt;module&gt;
      1 id = 123
----&gt; 2 name = jason
      3 
      4 print(&apos;no data available for person with id: {}, name: {}&apos;.format(id, name))


NameError: name &apos;jason&apos; is not defined</code></pre><p>其中 %s 表示字符串型，%d 表示整型等等，这些属于常识，你应该都了解。</p>
<p>当然，现在你写程序时，我还是推荐使用 format 函数，毕竟这是最新规范，也是官方文档推荐的规范。</p>
<p>也许有人会问，为什么非要使用格式化函数，上述例子用字符串的拼接不也能完成吗？没错，在很多情况下，字符串拼接确实能满足格式化函数的需求。但是使用格式化函数，更加清晰、易读，并且更加规范，不易出错。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这节课，我们主要学习了 Python 字符串的一些基本知识和常用操作，并且结合具体的例子与场景加以说明，特别需要注意下面几点。</p>
<ul>
<li><p>Python 中字符串使用单引号、双引号或三引号表示，三者意义相同，并没有什么区别。其中，三引号的字符串通常用在多行字符串的场景。</p>
</li>
<li><p>Python 中字符串是不可变的（前面所讲的新版本 Python 中拼接操作’+=’是个例外）。因此，随意改变字符串中字符的值，是不被允许的。</p>
</li>
<li><p>Python 新版本（2.5+）中，字符串的拼接变得比以前高效了许多，你可以放心使用。</p>
</li>
<li><p>Python 中字符串的格式化（string.format）常常用在输出、日志的记录等场景。</p>
</li>
</ul>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>最后，给你留一道思考题。在新版本的 Python（2.5+）中，下面的两个字符串拼接操作，你觉得哪个更优呢？欢迎留言和我分享你的观点，也欢迎你把这篇文章分享给你的同事、朋友。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">100000</span>):</span><br><span class="line">    s += str(n)l = []</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">100000</span>):</span><br><span class="line">    l.append(str(n))</span><br><span class="line">    </span><br><span class="line">s = <span class="string">' '</span>.join(l)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">l = []</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">100000</span>):</span><br><span class="line">    l.append(str(n))</span><br><span class="line">    </span><br><span class="line">s = <span class="string">' '</span>.join(l)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">start_time = time.perf_counter()</span><br><span class="line">s = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">1000</span>):</span><br><span class="line">    s += str(n)</span><br><span class="line">end_time = time.perf_counter()</span><br><span class="line"> </span><br><span class="line">print(<span class="string">'Time elapse:&#123;&#125;'</span>.format(end_time - start_time))</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">start_time = time.perf_counter()</span><br><span class="line">s = []</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">1000</span>):</span><br><span class="line">    s.append(str(n))</span><br><span class="line"><span class="string">''</span>.join(s)</span><br><span class="line">end_time = time.perf_counter()</span><br><span class="line">print(<span class="string">'Time elapse:&#123;&#125;'</span>.format(end_time - start_time))</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">start_time = time.perf_counter()</span><br><span class="line">s = <span class="string">''</span>.join(map(str,range(<span class="number">0</span>,<span class="number">1000</span>)))</span><br><span class="line">end_time = time.perf_counter()</span><br><span class="line">print(<span class="string">'Time elapse:&#123;&#125;'</span>.format(end_time - start_time))</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">方案\条数</th>
<th align="center">1000</th>
<th align="center">100000（十万条）</th>
<th align="center">10000000（一千万条）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">方式一（+=）</td>
<td align="center">0.0006100520004110876</td>
<td align="center">0.053987349001545226</td>
<td align="center">5.24716751743108</td>
</tr>
<tr>
<td align="center">方式二（list,join）</td>
<td align="center">0.00047015399832162075</td>
<td align="center">0.038282303998130374</td>
<td align="center">4.119422915999166</td>
</tr>
<tr>
<td align="center">方式三(map,join)</td>
<td align="center">0.00022071799685363658</td>
<td align="center">0.021825258001626935</td>
<td align="center">2.6899159259992302</td>
</tr>
</tbody></table>
<ul>
<li>结论: 字符串+=的方式千万条以下相差不大. 千万条以上效率就会差距很大了. </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/29/04%E5%AD%97%E5%85%B8%E9%9B%86%E5%90%88%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%90%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/29/04%E5%AD%97%E5%85%B8%E9%9B%86%E5%90%88%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%90%97/" itemprop="url">04 | 字典、集合，你真的了解吗？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-29T18:53:42+08:00">
                2019-11-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/" itemprop="url" rel="index">
                    <span itemprop="name">python核心技术与实战</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/11/29/04%E5%AD%97%E5%85%B8%E9%9B%86%E5%90%88%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%90%97/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/11/29/04%E5%AD%97%E5%85%B8%E9%9B%86%E5%90%88%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%90%97/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="字典（dict）和集合（set）"><a href="#字典（dict）和集合（set）" class="headerlink" title="字典（dict）和集合（set）"></a>字典（dict）和集合（set）</h2><h3 id="字典和集合基础"><a href="#字典和集合基础" class="headerlink" title="字典和集合基础"></a>字典和集合基础</h3><p>那究竟什么是字典，什么是集合呢？字典是一系列由键（key）和值（value）配对组成的元素的集合，在 Python3.7+，字典被确定为有序（注意：在 3.6 中，字典有序是一个 implementation detail，在 3.7 才正式成为语言特性，因此 3.6 中无法 100% 确保其有序性），而 3.6 之前是无序的，其长度大小可变，元素可以任意地删减和改变。</p>
<p>相比于列表和元组，字典的性能更优，特别是对于查找、添加和删除操作，字典都能在常数时间复杂度内完成。</p>
<p>而集合和字典基本相同，唯一的区别，就是集合没有键和值的配对，是一系列无序的、唯一的元素组合。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#首先我们来看字典和集合的创建，通常有下面这几种方式：</span></span><br><span class="line">d1 = &#123;<span class="string">'name'</span>: <span class="string">'jason'</span>, <span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br><span class="line">d2 = dict(&#123;<span class="string">'name'</span>: <span class="string">'jason'</span>, <span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;)</span><br><span class="line">d3 = dict([(<span class="string">'name'</span>, <span class="string">'jason'</span>), (<span class="string">'age'</span>, <span class="number">20</span>), (<span class="string">'gender'</span>, <span class="string">'male'</span>)])</span><br><span class="line">d4 = dict(name=<span class="string">'jason'</span>, age=<span class="number">20</span>, gender=<span class="string">'male'</span>) </span><br><span class="line">d1 == d2 == d3 ==d4</span><br><span class="line"></span><br><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">s1 == s2</span><br></pre></td></tr></table></figure>




<pre><code>True</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这里注意，Python 中字典和集合，无论是键还是值，都可以是混合类型。比如下面这个例子，我创建了一个元素为1，'hello'，5.0的集合：</span></span><br><span class="line">s = &#123;<span class="number">1</span>, <span class="string">'hello'</span>, <span class="number">5.0</span>&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 再来看元素访问的问题。字典访问可以直接索引键，如果不存在，就会抛出异常：</span></span><br><span class="line">d = &#123;<span class="string">'name'</span>: <span class="string">'jason'</span>, <span class="string">'age'</span>: <span class="number">20</span>&#125;</span><br><span class="line">d[<span class="string">'name'</span>]</span><br><span class="line">d[<span class="string">'location'</span>]</span><br><span class="line"><span class="comment">#Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#KeyError: 'location'</span></span><br></pre></td></tr></table></figure>




<pre><code>&apos;jason&apos;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#也可以使用 get(key, default) 函数来进行索引。如果键不存在，调用 get() 函数可以返回一个默认值。比如下面这个示例，返回了'null'。</span></span><br><span class="line">d = &#123;<span class="string">'name'</span>: <span class="string">'jason'</span>, <span class="string">'age'</span>: <span class="number">20</span>&#125;</span><br><span class="line">d.get(<span class="string">'name'</span>)</span><br><span class="line">d.get(<span class="string">'location'</span>, <span class="string">'null'</span>)</span><br></pre></td></tr></table></figure>




<pre><code>&apos;null&apos;</code></pre><p>首先我要强调的是，集合并不支持索引操作，因为集合本质上是一个哈希表，和列表不一样。所以，下面这样的操作是错误的，Python 会抛出异常：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s[<span class="number">0</span>]</span><br><span class="line"><span class="comment">#Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#TypeError: 'set' object does not support indexing</span></span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

&lt;ipython-input-10-78ad603678a3&gt; in &lt;module&gt;
      1 s = {1, 2, 3}
----&gt; 2 s[0]
      3 #Traceback (most recent call last):
      4 #  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
      5 #TypeError: &apos;set&apos; object does not support indexing


TypeError: &apos;set&apos; object does not support indexing</code></pre><p>想要判断一个元素在不在字典或集合内，我们可以用 value in dict/set 来判断。</p>
<ul>
<li>dict in 判断是key是否.value判断不了.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">print(<span class="number">1</span> <span class="keyword">in</span> s)</span><br><span class="line">print(<span class="number">10</span> <span class="keyword">in</span> s)</span><br><span class="line">d = &#123;<span class="string">'name'</span>: <span class="string">'jason'</span>, <span class="string">'age'</span>: <span class="number">20</span>&#125;</span><br><span class="line">print(<span class="string">'name'</span> <span class="keyword">in</span> d)</span><br><span class="line">print(<span class="string">'location'</span> <span class="keyword">in</span> d)</span><br></pre></td></tr></table></figure>

<pre><code>True
False
True
False





False</code></pre><p>当然，除了创建和访问，字典和集合也同样支持增加、删除、更新等操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'name'</span>: <span class="string">'jason'</span>, <span class="string">'age'</span>: <span class="number">20</span>&#125;</span><br><span class="line">d[<span class="string">'gender'</span>] = <span class="string">'male'</span> <span class="comment"># 增加元素对'gender': 'male'</span></span><br><span class="line">d[<span class="string">'dob'</span>] = <span class="string">'1999-02-01'</span> <span class="comment"># 增加元素对'dob': '1999-02-01'</span></span><br><span class="line">d[<span class="string">'dob'</span>] = <span class="string">'1998-01-01'</span> <span class="comment"># 更新键'dob'对应的值 </span></span><br><span class="line">d.pop(<span class="string">'dob'</span>) <span class="comment"># 删除键为'dob'的元素对</span></span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'jason'</span>, <span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br><span class="line"> </span><br><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s.add(<span class="number">4</span>) <span class="comment"># 增加元素 4 到集合</span></span><br><span class="line">s.remove(<span class="number">4</span>) <span class="comment"># 从集合中删除元素 4</span></span><br><span class="line">s.pop()</span><br><span class="line">s</span><br></pre></td></tr></table></figure>




<pre><code>{2, 3}</code></pre><p>不过要注意，集合的 pop() 操作是删除集合中最后一个元素，可是集合本身是无序的，你无法知道会删除哪个元素，因此这个操作得谨慎使用。</p>
<p>实际应用中，很多情况下，我们需要对字典或集合进行排序，比如，取出值最大的 50 对。</p>
<p>对于字典，我们通常会根据键或值，进行升序或降序排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'b'</span>: <span class="number">1</span>, <span class="string">'a'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">10</span>&#125;</span><br><span class="line">d_sorted_by_key = sorted(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>]) <span class="comment"># 根据字典键的升序排序</span></span><br><span class="line">d_sorted_by_value = sorted(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]) <span class="comment"># 根据字典值的升序排序</span></span><br><span class="line">[(<span class="string">'a'</span>, <span class="number">2</span>), (<span class="string">'b'</span>, <span class="number">1</span>), (<span class="string">'c'</span>, <span class="number">10</span>)]</span><br><span class="line">[(<span class="string">'b'</span>, <span class="number">1</span>), (<span class="string">'a'</span>, <span class="number">2</span>), (<span class="string">'c'</span>, <span class="number">10</span>)]</span><br></pre></td></tr></table></figure>




<pre><code>[(&apos;b&apos;, 1), (&apos;a&apos;, 2), (&apos;c&apos;, 10)]</code></pre><p>这里返回了一个列表。列表中的每个元素，是由原字典的键和值组成的元组。</p>
<p>而对于集合，其排序和前面讲过的列表、元组很类似，直接调用 sorted(set) 即可，结果会返回一个排好序的列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>&#125;</span><br><span class="line">sorted(s) <span class="comment"># 对集合的元素进行升序排序</span></span><br></pre></td></tr></table></figure>




<pre><code>[1, 2, 3, 4]</code></pre><h3 id="字典和集合性能"><a href="#字典和集合性能" class="headerlink" title="字典和集合性能"></a>字典和集合性能</h3><p>文章开头我就说到了，字典和集合是进行过性能高度优化的数据结构，特别是对于查找、添加和删除操作。那接下来，我们就来看看，它们在具体场景下的性能表现，以及与列表等其他数据结构的对比。</p>
<p>比如电商企业的后台，存储了每件产品的 ID、名称和价格。现在的需求是，给定某件商品的 ID，我们要找出其价格。</p>
<p>如果我们用列表来存储这些数据结构，并进行查找，相应的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_product_price</span><span class="params">(products, product_id)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> id, price <span class="keyword">in</span> products:</span><br><span class="line">        <span class="keyword">if</span> id == product_id:</span><br><span class="line">            <span class="keyword">return</span> price</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span> </span><br><span class="line">     </span><br><span class="line">products = [</span><br><span class="line">    (<span class="number">143121312</span>, <span class="number">100</span>), </span><br><span class="line">    (<span class="number">432314553</span>, <span class="number">30</span>),</span><br><span class="line">    (<span class="number">32421912367</span>, <span class="number">150</span>) </span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line">print(<span class="string">'The price of product 432314553 is &#123;&#125;'</span>.format(find_product_price(products, <span class="number">432314553</span>)))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment">#The price of product 432314553 is 30</span></span><br></pre></td></tr></table></figure>

<pre><code>The price of product 432314553 is 30</code></pre><p>假设列表有 n 个元素，而查找的过程要遍历列表，那么时间复杂度就为 O(n)。即使我们先对列表进行排序，然后使用二分查找，也会需要 O(logn) 的时间复杂度，更何况，列表的排序还需要 O(nlogn) 的时间。</p>
<p>但如果我们用字典来存储这些数据，那么查找就会非常便捷高效，只需 O(1) 的时间复杂度就可以完成。原因也很简单，刚刚提到过的，字典的内部组成是一张哈希表，你可以直接通过键的哈希值，找到其对应的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">products = &#123;</span><br><span class="line">  <span class="number">143121312</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="number">432314553</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="number">32421912367</span>: <span class="number">150</span></span><br><span class="line">&#125;</span><br><span class="line">print(<span class="string">'The price of product 432314553 is &#123;&#125;'</span>.format(products[<span class="number">432314553</span>])) </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment">#The price of product 432314553 is 30</span></span><br></pre></td></tr></table></figure>

<p>类似的，现在需求变成，要找出这些商品有多少种不同的价格。我们还用同样的方法来比较一下。</p>
<p>如果还是选择使用列表，对应的代码如下，其中，A 和 B 是两层循环。同样假设原始列表有 n 个元素，那么，在最差情况下，需要 O(n^2) 的时间复杂度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># list version</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_unique_price_using_list</span><span class="params">(products)</span>:</span></span><br><span class="line">    unique_price_list = []</span><br><span class="line">    <span class="keyword">for</span> _, price <span class="keyword">in</span> products: <span class="comment"># A</span></span><br><span class="line">        <span class="keyword">if</span> price <span class="keyword">not</span> <span class="keyword">in</span> unique_price_list: <span class="comment">#B</span></span><br><span class="line">            unique_price_list.append(price)</span><br><span class="line">    <span class="keyword">return</span> len(unique_price_list)</span><br><span class="line"> </span><br><span class="line">products = [</span><br><span class="line">    (<span class="number">143121312</span>, <span class="number">100</span>), </span><br><span class="line">    (<span class="number">432314553</span>, <span class="number">30</span>),</span><br><span class="line">    (<span class="number">32421912367</span>, <span class="number">150</span>),</span><br><span class="line">    (<span class="number">937153201</span>, <span class="number">30</span>)</span><br><span class="line">]</span><br><span class="line">print(<span class="string">'number of unique price is: &#123;&#125;'</span>.format(find_unique_price_using_list(products)))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment">#number of unique price is: 3</span></span><br></pre></td></tr></table></figure>

<pre><code>number of unique price is: 3</code></pre><p>但如果我们选择使用集合这个数据结构，由于集合是高度优化的哈希表，里面元素不能重复，并且其添加和查找操作只需 O(1) 的复杂度，那么，总的时间复杂度就只有 O(n)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># set version</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_unique_price_using_set</span><span class="params">(products)</span>:</span></span><br><span class="line">    unique_price_set = set()</span><br><span class="line">    <span class="keyword">for</span> _, price <span class="keyword">in</span> products:</span><br><span class="line">        unique_price_set.add(price)</span><br><span class="line">    <span class="keyword">return</span> len(unique_price_set)        </span><br><span class="line"> </span><br><span class="line">products = [</span><br><span class="line">    (<span class="number">143121312</span>, <span class="number">100</span>), </span><br><span class="line">    (<span class="number">432314553</span>, <span class="number">30</span>),</span><br><span class="line">    (<span class="number">32421912367</span>, <span class="number">150</span>),</span><br><span class="line">    (<span class="number">937153201</span>, <span class="number">30</span>)</span><br><span class="line">]</span><br><span class="line">print(<span class="string">'number of unique price is: &#123;&#125;'</span>.format(find_unique_price_using_set(products)))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment">#number of unique price is: 3</span></span><br></pre></td></tr></table></figure>

<pre><code>number of unique price is: 3</code></pre><p>可能你对这些时间复杂度没有直观的认识，我可以举一个实际工作场景中的例子，让你来感受一下。</p>
<p>下面的代码，初始化了含有 100,000 个元素的产品，并分别计算了使用列表和集合来统计产品价格数量的运行时间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_unique_price_using_set</span><span class="params">(products)</span>:</span></span><br><span class="line">    unique_price_set = set()</span><br><span class="line">    <span class="keyword">for</span> _, price <span class="keyword">in</span> products:</span><br><span class="line">        unique_price_set.add(price)</span><br><span class="line">    <span class="keyword">return</span> len(unique_price_set)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_unique_price_using_list</span><span class="params">(products)</span>:</span></span><br><span class="line">    unique_price_list = []</span><br><span class="line">    <span class="keyword">for</span> _, price <span class="keyword">in</span> products: <span class="comment"># A</span></span><br><span class="line">        <span class="keyword">if</span> price <span class="keyword">not</span> <span class="keyword">in</span> unique_price_list: <span class="comment">#B</span></span><br><span class="line">            unique_price_list.append(price)</span><br><span class="line">    <span class="keyword">return</span> len(unique_price_list)</span><br><span class="line"></span><br><span class="line">id = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">100000</span>)]</span><br><span class="line">price = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">200000</span>, <span class="number">300000</span>)]</span><br><span class="line">products = list(zip(id, price))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 计算列表版本的时间</span></span><br><span class="line">start_using_list = time.perf_counter()</span><br><span class="line">find_unique_price_using_list(products)</span><br><span class="line">end_using_list = time.perf_counter()</span><br><span class="line">print(<span class="string">"time elapse using list: &#123;&#125;"</span>.format(end_using_list - start_using_list))</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line"><span class="comment">#time elapse using list: 41.61519479751587</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 计算集合版本的时间</span></span><br><span class="line">start_using_set = time.perf_counter()</span><br><span class="line">find_unique_price_using_set(products)</span><br><span class="line">end_using_set = time.perf_counter()</span><br><span class="line">print(<span class="string">"time elapse using set: &#123;&#125;"</span>.format(end_using_set - start_using_set))</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment">#time elapse using set: 0.008238077163696289</span></span><br></pre></td></tr></table></figure>

<pre><code>time elapse using list: 63.849736968993966
time elapse using set: 0.015473385996301658</code></pre><h3 id="字典和集合的工作原理"><a href="#字典和集合的工作原理" class="headerlink" title="字典和集合的工作原理"></a>字典和集合的工作原理</h3><p>我们通过举例以及与列表的对比，看到了字典和集合操作的高效性。不过，字典和集合为什么能够如此高效，特别是查找、插入和删除操作？</p>
<p>这当然和字典、集合内部的数据结构密不可分。不同于其他数据结构，字典和集合的内部结构都是一张哈希表。</p>
<ul>
<li><p>对于字典而言，这张表存储了哈希值（hash）、键和值这 3 个元素。</p>
</li>
<li><p>而对集合来说，区别就是哈希表内没有键和值的配对，只有单一的元素了。</p>
</li>
</ul>
<p>我们来看，老版本 Python 的哈希表结构如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--+-------------------------------+</span><br><span class="line">  | 哈希值 (hash)  键 (key)  值 (value)</span><br><span class="line">--+-------------------------------+</span><br><span class="line"><span class="number">0</span> |    hash0      key0    value0</span><br><span class="line">--+-------------------------------+</span><br><span class="line"><span class="number">1</span> |    hash1      key1    value1</span><br><span class="line">--+-------------------------------+</span><br><span class="line"><span class="number">2</span> |    hash2      key2    value2</span><br><span class="line">--+-------------------------------+</span><br><span class="line">. |           ...</span><br><span class="line">__+_______________________________+</span><br></pre></td></tr></table></figure>


<pre><code>  File &quot;&lt;ipython-input-49-5b39457a5c8c&gt;&quot;, line 1
    --+-------------------------------+
                                       ^
SyntaxError: invalid syntax</code></pre><p>不难想象，随着哈希表的扩张，它会变得越来越稀疏。举个例子，比如我有这样一个字典：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'mike'</span>, <span class="string">'dob'</span>: <span class="string">'1999-01-01'</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br></pre></td></tr></table></figure>

<p>那么它会存储为类似下面的形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">entries = [</span><br><span class="line">[<span class="string">'--'</span>, <span class="string">'--'</span>, <span class="string">'--'</span>]</span><br><span class="line">[<span class="number">-230273521</span>, <span class="string">'dob'</span>, <span class="string">'1999-01-01'</span>],</span><br><span class="line">[<span class="string">'--'</span>, <span class="string">'--'</span>, <span class="string">'--'</span>],</span><br><span class="line">[<span class="string">'--'</span>, <span class="string">'--'</span>, <span class="string">'--'</span>],</span><br><span class="line">[<span class="number">1231236123</span>, <span class="string">'name'</span>, <span class="string">'mike'</span>],</span><br><span class="line">[<span class="string">'--'</span>, <span class="string">'--'</span>, <span class="string">'--'</span>],</span><br><span class="line">[<span class="number">9371539127</span>, <span class="string">'gender'</span>, <span class="string">'male'</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>这样的设计结构显然非常浪费存储空间。为了提高存储空间的利用率，现在的哈希表除了字典本身的结构，会把索引和哈希值、键、值单独分开，也就是下面这样新的结构：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Indices</span><br><span class="line">----------------------------------------------------</span><br><span class="line"><span class="literal">None</span> | index | <span class="literal">None</span> | <span class="literal">None</span> | index | <span class="literal">None</span> | index ...</span><br><span class="line">----------------------------------------------------</span><br><span class="line"> </span><br><span class="line">Entries</span><br><span class="line">--------------------</span><br><span class="line">hash0   key0  value0</span><br><span class="line">---------------------</span><br><span class="line">hash1   key1  value1</span><br><span class="line">---------------------</span><br><span class="line">hash2   key2  value2</span><br><span class="line">---------------------</span><br><span class="line">        ...</span><br><span class="line">---------------------</span><br></pre></td></tr></table></figure>

<p>那么，刚刚的这个例子，在新的哈希表结构下的存储形式，就会变成下面这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">indices = [<span class="literal">None</span>, <span class="number">1</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="number">0</span>, <span class="literal">None</span>, <span class="number">2</span>]</span><br><span class="line">entries = [</span><br><span class="line">[<span class="number">1231236123</span>, <span class="string">'name'</span>, <span class="string">'mike'</span>],</span><br><span class="line">[<span class="number">-230273521</span>, <span class="string">'dob'</span>, <span class="string">'1999-01-01'</span>],</span><br><span class="line">[<span class="number">9371539127</span>, <span class="string">'gender'</span>, <span class="string">'male'</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>这段我开始看也很迷惑, 重点是如果知道哈希表,散列表是有大概三分之一是空的.所以后来的优化方式就是在空的地方只有index,不存空的实体了.很好理解.</li>
</ul>
<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>每次向字典或集合插入一个元素时，Python 会首先计算键的哈希值（hash(key)），再和 mask = PyDicMinSize - 1 做与操作，计算这个元素应该插入哈希表的位置 index = hash(key) &amp; mask。如果哈希表中此位置是空的，那么这个元素就会被插入其中。</p>
<ul>
<li>这个插入的计算方式,我真的好迷惑.</li>
</ul>
<p>而如果此位置已被占用，Python 便会比较两个元素的哈希值和键是否相等。</p>
<ul>
<li><p>若两者都相等，则表明这个元素已经存在，如果值不同，则更新值。</p>
</li>
<li><p>若两者中有一个不相等，这种情况我们通常称为哈希冲突（hash collision），意思是两个元素的键不相等，但是哈希值相等。这种情况下，Python 便会继续寻找表中空余的位置，直到找到位置为止。</p>
</li>
</ul>
<p>值得一提的是，通常来说，遇到这种情况，最简单的方式是线性寻找，即从这个位置开始，挨个往后寻找空位。当然，Python 内部对此进行了优化（这一点无需深入了解，你有兴趣可以查看源码，我就不再赘述），让这个步骤更加高效。</p>
<h3 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h3><p>和前面的插入操作类似，Python 会根据哈希值，找到其应该处于的位置；然后，比较哈希表这个位置中元素的哈希值和键，与需要查找的元素是否相等。如果相等，则直接返回；如果不等，则继续查找，直到找到空位或者抛出异常为止。</p>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>对于删除操作，Python 会暂时对这个位置的元素，赋于一个特殊的值，等到重新调整哈希表的大小时，再将其删除。</p>
<p>不难理解，哈希冲突的发生，往往会降低字典和集合操作的速度。因此，为了保证其高效性，字典和集合内的哈希表，通常会保证其至少留有 1/3 的剩余空间。随着元素的不停插入，当剩余空间小于 1/3 时，Python 会重新获取更大的内存空间，扩充哈希表。不过，这种情况下，表内所有的元素位置都会被重新排放。</p>
<p>虽然哈希冲突和哈希表大小的调整，都会导致速度减缓，但是这种情况发生的次数极少。所以，平均情况下，这仍能保证插入、查找和删除的时间复杂度为 O(1)。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这节课，我们一起学习了字典和集合的基本操作，并对它们的高性能和内部存储结构进行了讲解。</p>
<p>字典在 Python3.7+ 是有序的数据结构，而集合是无序的，其内部的哈希表存储结构，保证了其查找、插入、删除操作的高效性。所以，字典和集合通常运用在对元素的高效查找、去重等场景。</p>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Option A</span></span><br><span class="line">d = &#123;<span class="string">'name'</span>: <span class="string">'jason'</span>, <span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Option B</span></span><br><span class="line">d = dict(&#123;<span class="string">'name'</span>: <span class="string">'jason'</span>, <span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>字典的键可以是一个列表吗？下面这段代码中，字典的初始化是否正确呢？如果不正确，可以说出你的原因吗？</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'name'</span>: <span class="string">'jason'</span>, [<span class="string">'education'</span>]: [<span class="string">'Tsinghua University'</span>, <span class="string">'Stanford University'</span>]&#125;</span><br></pre></td></tr></table></figure>



          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/29/jupyter%E8%BD%ACmd%E5%92%8Chexo%E9%83%A8%E7%BD%B2%E7%9A%84%E6%97%A5%E5%B8%B8%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/29/jupyter%E8%BD%ACmd%E5%92%8Chexo%E9%83%A8%E7%BD%B2%E7%9A%84%E6%97%A5%E5%B8%B8%E6%93%8D%E4%BD%9C/" itemprop="url">jupyter转md和hexo部署的日常操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-29T16:55:27+08:00">
                2019-11-29
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/11/29/jupyter%E8%BD%ACmd%E5%92%8Chexo%E9%83%A8%E7%BD%B2%E7%9A%84%E6%97%A5%E5%B8%B8%E6%93%8D%E4%BD%9C/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/11/29/jupyter%E8%BD%ACmd%E5%92%8Chexo%E9%83%A8%E7%BD%B2%E7%9A%84%E6%97%A5%E5%B8%B8%E6%93%8D%E4%BD%9C/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="编辑jupyter加上hexo-new-生成的表头"><a href="#编辑jupyter加上hexo-new-生成的表头" class="headerlink" title="编辑jupyter加上hexo new 生成的表头."></a>编辑jupyter加上hexo new 生成的表头.</h2><ul>
<li>这样就不用修改md,直接hexo g生成文章就可以了.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 07 | 修炼基本功：条件与循环</span><br><span class="line">date: 2019-12-06 20:15:59</span><br><span class="line">tags:</span><br><span class="line">- python</span><br><span class="line">- 极客时间</span><br><span class="line">categories:</span><br><span class="line">- python核心技术与实战</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="jupyter"><a href="#jupyter" class="headerlink" title="jupyter"></a>jupyter</h2><p>日常用jupyter写python笔记,优点是能实时计算,缺点是查看不容易.</p>
<p>我在想能不能转成markdown格式发表在blog,没想到真有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter nbconvert --to markdown &quot;3.11-matplotlib 基础.ipynb&quot;</span><br></pre></td></tr></table></figure>



<h2 id="HEXO"><a href="#HEXO" class="headerlink" title="HEXO"></a>HEXO</h2><ul>
<li><p>月初搭了hexo的blog,今天转完markdown之后居然忘了常用命令</p>
</li>
<li><p>创建文章</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new 文章名</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成静态网页</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
</li>
<li><p>部署到github</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
</li>
<li><p>本地运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul>
<li>转ipynb–&gt;md</li>
<li>新建文章,需要新建文章的表头</li>
<li>生成静态</li>
<li>部署github</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/">&lt;i class=&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/">&lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">LvYang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">41</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LvYang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    





  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'qcq1G35cOv9sG5BrpbdXJwtJ-gzGzoHsz',
        appKey: 'VtFEF7WhBgSXbcGzdO1GztzO',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
