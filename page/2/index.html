<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="LvYang">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;page&#x2F;2&#x2F;index.html">
<meta property="og:site_name" content="LvYang">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>LvYang</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LvYang</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/31/22%E4%B8%A8%E5%8F%8D%E8%8C%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A3NF%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E8%B6%B3%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E5%8F%8D%E8%8C%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/31/22%E4%B8%A8%E5%8F%8D%E8%8C%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A3NF%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E8%B6%B3%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E5%8F%8D%E8%8C%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%EF%BC%9F/" itemprop="url">22丨反范式设计：3NF有什么不足，为什么有时候需要反范式设计？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-31T20:44:01+08:00">
                2020-03-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/" itemprop="url" rel="index">
                    <span itemprop="name">SQL必知必会</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/31/22%E4%B8%A8%E5%8F%8D%E8%8C%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A3NF%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E8%B6%B3%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E5%8F%8D%E8%8C%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%EF%BC%9F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/03/31/22%E4%B8%A8%E5%8F%8D%E8%8C%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A3NF%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E8%B6%B3%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E5%8F%8D%E8%8C%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%EF%BC%9F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上一篇文章中，我们介绍了数据表设计的三种范式。作为数据库的设计人员，理解范式的设计以及反范式优化是非常有必要的。</p>
<p>为什么这么说呢？了解以下几个方面的内容之后你就明白了。</p>
<ol>
<li>3NF 有什么不足？除了 3NF，我们为什么还需要 BCNF？</li>
<li>有了范式设计，为什么有时候需要进行反范式设计？</li>
<li>反范式设计适用的场景是什么？又可能存在哪些问题？<h3 id="BCNF（巴斯范式）"><a href="#BCNF（巴斯范式）" class="headerlink" title="BCNF（巴斯范式）"></a>BCNF（巴斯范式）</h3>如果数据表的关系模式符合 3NF 的要求，就不存在问题了吗？我们来看下这张仓库管理关系 warehouse_keeper 表：</li>
</ol>
<p>在这个数据表中，一个仓库只有一个管理员，同时一个管理员也只管理一个仓库。我们先来梳理下这些属性之间的依赖关系。</p>
<p>仓库名决定了管理员，管理员也决定了仓库名，同时（仓库名，物品名）的属性集合可以决定数量这个属性。</p>
<p>这样，我们就可以找到数据表的候选键是（管理员，物品名）和（仓库名，物品名），</p>
<p>然后我们从候选键中选择一个作为主键，比如（仓库名，物品名）。</p>
<p>在这里，主属性是包含在任一候选键中的属性，也就是仓库名，管理员和物品名。非主属性是数量这个属性。</p>
<p>如何判断一张表的范式呢？我们需要根据范式的等级，从低到高来进行判断。</p>
<p>首先，数据表每个属性都是原子性的，符合 1NF 的要求；其次，数据表中非主属性”数量“都与候选键全部依赖，（仓库名，物品名）决定数量，（管理员，物品名）决定数量，因此，数据表符合 2NF 的要求；最后，数据表中的非主属性，不传递依赖于候选键。因此符合 3NF 的要求。</p>
<p>既然数据表已经符合了 3NF 的要求，是不是就不存在问题了呢？我们来看下下面的情况：</p>
<ol>
<li>增加一个仓库，但是还没有存放任何物品。根据数据表实体完整性的要求，主键不能有空值，因此会出现插入异常；</li>
<li>如果仓库更换了管理员，我们就可能会修改数据表中的多条记录；</li>
<li>如果仓库里的商品都卖空了，那么此时仓库名称和相应的管理员名称也会随之被删除。<br>你能看到，即便数据表符合 3NF 的要求，同样可能存在插入，更新和删除数据的异常情况。</li>
</ol>
<p>这种情况下该怎么解决呢？</p>
<p>首先我们需要确认造成异常的原因：主属性仓库名对于候选键（管理员，物品名）是部分依赖的关系，这样就有可能导致上面的异常情况。人们在 3NF 的基础上进行了改进，提出了<strong>BCNF，也叫做巴斯 - 科德范式，它在 3NF 的基础上消除了主属性对候选键的部分依赖或者传递依赖关系。</strong></p>
<p>根据 BCNF 的要求，我们需要把仓库管理关系 warehouse_keeper 表拆分成下面这样：</p>
<p>仓库表：（仓库名，管理员）</p>
<p>库存表：（仓库名，物品名，数量）</p>
<p>这样就不存在主属性对于候选键的部分依赖或传递依赖，上面数据表的设计就符合 BCNF。</p>
<h3 id="反范式设计"><a href="#反范式设计" class="headerlink" title="反范式设计"></a>反范式设计</h3><p>尽管围绕着数据表的设计有很多范式，但事实上，我们在设计数据表的时候却不一定要参照这些标准。</p>
<p>我们在之前已经了解了越高阶的范式得到的数据表越多，数据冗余度越低。但有时候，我们在设计数据表的时候，还需要为了性能和读取效率违反范式化的原则。反范式就是相对范式化而言的，换句话说，就是允许少量的冗余，通过空间来换时间。</p>
<p>如果我们想对查询效率进行优化，有时候反范式优化也是一种优化思路。</p>
<p>比如我们想要查询某个商品的前 1000 条评论，会涉及到两张表。</p>
<p>商品评论表 product_comment，对应的字段名称及含义如下：</p>
<p>用户表 user，对应的字段名称及含义如下：</p>
<p>下面，我们就用这两张表模拟一下反范式优化。</p>
<h3 id="实验数据：模拟两张百万量级的数据表"><a href="#实验数据：模拟两张百万量级的数据表" class="headerlink" title="实验数据：模拟两张百万量级的数据表"></a>实验数据：模拟两张百万量级的数据表</h3><p>为了更好地进行 SQL 优化实验，我们需要给用户表和商品评论表随机模拟出百万量级的数据。我们可以通过存储过程来实现模拟数据。</p>
<p>下面是给用户表随机生成 100 万用户的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CREATE DEFINER=`root`@`localhost` PROCEDURE `insert_many_user`(IN start INT(10), IN max_num INT(10))</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">DECLARE date_start DATETIME DEFAULT (&apos;2017-01-01 00:00:00&apos;);</span><br><span class="line">DECLARE date_temp DATETIME;</span><br><span class="line">SET date_temp = date_start;</span><br><span class="line">SET autocommit=0;</span><br><span class="line">REPEAT</span><br><span class="line">SET i=i+1;</span><br><span class="line">SET date_temp = date_add(date_temp, interval RAND()*60 second);</span><br><span class="line">INSERT INTO user(user_id, user_name, create_time)</span><br><span class="line">VALUES((start+i), CONCAT(&apos;user_&apos;,i), date_temp);</span><br><span class="line">UNTIL i = max_num</span><br><span class="line">END REPEAT;</span><br><span class="line">COMMIT;</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<p>我用 date_start 变量来定义初始的注册时间，时间为 2017 年 1 月 1 日 0 点 0 分 0 秒，然后用 date_temp 变量计算每个用户的注册时间，新的注册用户与上一个用户注册的时间间隔为 60 秒内的随机值。然后使用 REPEAT … UNTIL … END REPEAT 循环，对 max_num 个用户的数据进行计算。在循环前，我们将 autocommit 设置为 0，这样等计算完成再统一插入，执行效率更高。</p>
<p>然后我们来运行 call insert_many_user(10000, 1000000); 调用存储过程。这里需要通过 start 和 max_num 两个参数对初始的 user_id 和要创建的用户数量进行设置。运行结果：</p>
<p>你能看到在 MySQL 里，创建 100 万的用户数据用时 1 分 37 秒。</p>
<p>接着我们再来给商品评论表 product_comment 随机生成 100 万条商品评论。这里我们设置为给某一款商品评论，比如 product_id=10001。评论的内容为随机的 20 个字母。以下是创建随机的 100 万条商品评论的存储过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CREATE DEFINER=`root`@`localhost` PROCEDURE `insert_many_product_comments`(IN START INT(10), IN max_num INT(10))</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">DECLARE date_start DATETIME DEFAULT (&apos;2018-01-01 00:00:00&apos;);</span><br><span class="line">DECLARE date_temp DATETIME;</span><br><span class="line">DECLARE comment_text VARCHAR(25);</span><br><span class="line">DECLARE user_id INT;</span><br><span class="line">SET date_temp = date_start;</span><br><span class="line">SET autocommit=0;</span><br><span class="line">REPEAT</span><br><span class="line">SET i=i+1;</span><br><span class="line">SET date_temp = date_add(date_temp, INTERVAL RAND()*60 SECOND);</span><br><span class="line">SET comment_text = substr(MD5(RAND()),1, 20);</span><br><span class="line">SET user_id = FLOOR(RAND()*1000000);</span><br><span class="line">INSERT INTO product_comment(comment_id, product_id, comment_text, comment_time, user_id)</span><br><span class="line">VALUES((START+i), 10001, comment_text, date_temp, user_id);</span><br><span class="line">UNTIL i = max_num</span><br><span class="line">END REPEAT;</span><br><span class="line">COMMIT;</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<p>同样的，我用 date_start 变量来定义初始的评论时间。这里新的评论时间与上一个评论的时间间隔还是 60 秒内的随机值，商品评论表中的 user_id 为随机值。我们使用 REPEAT … UNTIL … END REPEAT 循环，来对 max_num 个商品评论的数据进行计算。</p>
<p>然后调用存储过程，运行结果如下：</p>
<p>MySQL 一共花了 2 分 7 秒完成了商品评论数据的创建。</p>
<h3 id="反范式优化实验对比"><a href="#反范式优化实验对比" class="headerlink" title="反范式优化实验对比"></a>反范式优化实验对比</h3><p>如果我们想要查询某个商品 ID，比如 10001 的前 1000 条评论，需要写成下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT p.comment_text, p.comment_time, u.user_name FROM product_comment AS p </span><br><span class="line">LEFT JOIN user AS u </span><br><span class="line">ON p.user_id = u.user_id </span><br><span class="line">WHERE p.product_id = 10001 </span><br><span class="line">ORDER BY p.comment_id DESC LIMIT 1000</span><br></pre></td></tr></table></figure>
<p>运行结果（1000 条数据行）：</p>
<p>运行时长为 0.395 秒，查询效率并不高。</p>
<p>这是因为在实际生活中，我们在显示商品评论的时候，通常会显示这个用户的昵称，而不是用户 ID，因此我们还需要关联 product_comment 和 user 这两张表来进行查询。当表数据量不大的时候，查询效率还好，但如果表数据量都超过了百万量级，查询效率就会变低。这是因为查询会在 product_comment 表和 user 表这两个表上进行聚集索引扫描，然后再嵌套循环，这样一来查询所耗费的时间就有几百毫秒甚至更多。对于网站的响应来说，这已经很慢了，用户体验会非常差。</p>
<p>如果我们想要提升查询的效率，可以允许适当的数据冗余，也就是在商品评论表中增加用户昵称字段，在 product_comment 数据表的基础上增加 user_name 字段，就得到了 product_comment2 数据表。</p>
<p>你可以在百度网盘中下载这三张数据表 product_comment、product_comment2 和 user 表，密码为 n3l8。</p>
<p>这样一来，只需单表查询就可以得到数据集结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT comment_text, comment_time, user_name FROM product_comment2 WHERE product_id = 10001 ORDER BY comment_id DESC LIMIT 1000</span><br></pre></td></tr></table></figure>
<p>运行结果（1000 条数据）：</p>
<p>优化之后只需要扫描一次聚集索引即可，运行时间为 0.039 秒，查询时间是之前的 1/10。 你能看到，在数据量大的情况下，查询效率会有显著的提升。</p>
<p>反范式存在的问题 &amp; 适用场景<br>从上面的例子中可以看出，反范式可以通过空间换时间，提升查询的效率，但是反范式也会带来一些新问题。</p>
<p>在数据量小的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加复杂。比如采用存储过程来支持数据的更新、删除等额外操作，很容易增加系统的维护成本。</p>
<p>比如用户每次更改昵称的时候，都需要执行存储过程来更新，如果昵称更改频繁，会非常消耗系统资源。</p>
<p>那么反范式优化适用于哪些场景呢？</p>
<p>在现实生活中，我们经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每次发生的订单收货信息都属于历史快照，需要进行保存，但用户可以随时修改自己的信息，这时保存这些冗余信息是非常有必要的。</p>
<p>当冗余信息有价值或者能大幅度提高查询效率的时候，我们就可以采取反范式的优化。</p>
<p>此外反范式优化也常用在数据仓库的设计中，因为数据仓库通常存储历史数据，对增删改的实时性要求不强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。</p>
<p>我简单总结下数据仓库和数据库在使用上的区别：</p>
<p>数据库设计的目的在于捕获数据，而数据仓库设计的目的在于分析数据；<br>数据库对数据的增删改实时性要求强，需要存储在线的用户数据，而数据仓库存储的一般是历史数据；<br>数据库设计需要尽量避免冗余，但为了提高查询效率也允许一定的冗余度，而数据仓库在设计上更偏向采用反范式设计。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>今天我们讲了 BCNF，它是基于 3NF 进行的改进。你能看到设计范式越高阶，数据表就会越精细，数据的冗余度也就越少，在一定程度上可以让数据库在内部关联上更好地组织数据。但有时候我们也需要采用反范进行优化，通过空间来换取时间。</p>
<p>范式本身没有优劣之分，只有适用场景不同。没有完美的设计，只有合适的设计，我们在数据表的设计中，还需要根据需求将范式和反范式混合使用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/31/21%E4%B8%A8%E8%8C%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E8%8C%83%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C3NF%E6%8C%87%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/31/21%E4%B8%A8%E8%8C%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E8%8C%83%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C3NF%E6%8C%87%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/" itemprop="url">21丨范式设计：数据表的范式有哪些，3NF指的是什么？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-31T19:49:01+08:00">
                2020-03-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/" itemprop="url" rel="index">
                    <span itemprop="name">SQL必知必会</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/31/21%E4%B8%A8%E8%8C%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E8%8C%83%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C3NF%E6%8C%87%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/03/31/21%E4%B8%A8%E8%8C%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E8%8C%83%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C3NF%E6%8C%87%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在日常工作中，我们都需要遵守一定的规范，比如签到打卡、审批流程等，这些规范虽然有一定的约束感，却是非常有必要的，这样可以保证正确性和严谨性，但有些情况下，约束反而会带来效率的下降，比如一个可以直接操作的任务，却需要通过重重审批才能执行。</p>
<p>实际上，数据表的设计和工作流程的设计很像，我们既需要规范性，也要考虑到执行时的方便性。</p>
<p>今天，我来讲解一下数据表的设计范式。范式是数据表设计的基本原则，又很容易被忽略。很多时候，当数据库运行了一段时间之后，我们才发现数据表设计得有问题。重新调整数据表的结构，就需要做数据迁移，还有可能影响程序的业务逻辑，以及网站正常的访问。所以在开始设置数据库的时候，我们就需要重视数据表的设计。</p>
<p>今天的课程你需要掌握以下几个方面的内容：</p>
<ol>
<li>数据库的设计范式都有哪些？</li>
<li>数据表的键都有哪些？</li>
<li>1NF、2NF 和 3NF 指的是什么？<h3 id="数据库的设计范式都包括哪些"><a href="#数据库的设计范式都包括哪些" class="headerlink" title="数据库的设计范式都包括哪些"></a>数据库的设计范式都包括哪些</h3>我们在设计关系型数据库模型的时候，需要对关系内部各个属性之间联系的合理化程度进行定义，这就有了不同等级的规范要求，这些规范要求被称为范式（NF）。你可以把范式理解为，一张数据表的设计结构需要满足的某种设计标准的级别。</li>
</ol>
<p>目前关系型数据库一共有 6 种范式，按照范式级别，从低到高分别是：1NF（第一范式）、2NF（第二范式）、3NF（第三范式）、BCNF（巴斯 - 科德范式）、4NF（第四范式）和 5NF（第五范式，又叫做完美范式）。</p>
<p>数据库的范式设计越高阶，冗余度就越低，同时高阶的范式一定符合低阶范式的要求，比如满足 2NF 的一定满足 1NF，满足 3NF 的一定满足 2NF，依次类推。</p>
<p>你可能会问，这么多范式是不是都要掌握呢？</p>
<p>一般来说数据表的设计应尽量满足 3NF。但也不绝对，有时候为了提高某些查询性能，我们还需要破坏范式规则，也就是反规范化。</p>
<h3 id="数据表中的那些键"><a href="#数据表中的那些键" class="headerlink" title="数据表中的那些键"></a>数据表中的那些键</h3><p>范式的定义会使用到主键和候选键（因为主键和候选键可以唯一标识元组），数据库中的键（Key）由一个或者多个属性组成。我总结了下数据表中常用的几种键和属性的定义：</p>
<ul>
<li>超键：能唯一标识元组的属性集叫做超键。</li>
<li>候选键：如果超键不包括多余的属性，那么这个超键就是候选键。</li>
<li>主键：用户可以从候选键中选择一个作为主键。</li>
<li>外键：如果数据表 R1 中的某属性集不是 R1 的主键，而是另一个数据表 R2 的主键，那么这个属性集就是数据表 R1 的外键。</li>
<li>主属性：包含在任一候选键中的属性称为主属性。</li>
<li>非主属性：与主属性相对，指的是不包含在任何一个候选键中的属性。<br>通常，我们也将候选键称之为“码”，把主键也称为“主码”。因为键可能是由多个属性组成的，针对单个属性，我们还可以用主属性和非主属性来进行区分。</li>
</ul>
<p>看到上面的描述你可能还是有点懵，我举个简单的例子。</p>
<p>我们之前用过 NBA 的球员表（player）和球队表（team）。这里我可以把球员表定义为包含球员编号、姓名、身份证号、年龄和球队编号；球队表包含球队编号、主教练和球队所在地。</p>
<p>对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如（球员编号）（球员编号，姓名）（身份证号，年龄）等。</p>
<p>候选键就是最小的超键，对于球员表来说，候选键就是（球员编号）或者（身份证号）。</p>
<p>主键是我们自己选定，也就是从候选键中选择一个，比如（球员编号）。</p>
<p>外键就是球员表中的球队编号。</p>
<p>在 player 表中，主属性是（球员编号）（身份证号），其他的属性（姓名）（年龄）（球队编号）都是非主属性。</p>
<h3 id="从-1NF-到-3NF"><a href="#从-1NF-到-3NF" class="headerlink" title="从 1NF 到 3NF"></a>从 1NF 到 3NF</h3><p>了解了数据表中的 4 种键之后，我们再来看下 1NF、2NF 和 3NF，BCNF 我们放在后面讲。</p>
<p><strong>1NF 指的是数据库表中的任何属性都是原子性的，不可再分。</strong>这很好理解，我们在设计某个字段的时候，对于字段 X 来说，就不能把字段 X 拆分成字段 X-1 和字段 X-2。事实上，任何的 DBMS 都会满足第一范式的要求，不会将字段进行拆分。</p>
<p><strong>2NF 指的数据表里的非主属性都要和这个数据表的候选键有完全依赖关系。</strong>所谓完全依赖不同于部分依赖，也就是不能仅依赖候选键的一部分属性，而必须依赖全部属性。</p>
<p>这里我举一个没有满足 2NF 的例子，比如说我们设计一张球员比赛表 player_game，里面包含球员编号、姓名、年龄、比赛编号、比赛时间和比赛场地等属性，这里候选键和主键都为（球员编号，比赛编号），我们可以通过候选键来决定如下的关系：</p>
<p>(球员编号, 比赛编号) → (姓名, 年龄, 比赛时间, 比赛场地，得分)</p>
<p>上面这个关系说明球员编号和比赛编号的组合决定了球员的姓名、年龄、比赛时间、比赛地点和该比赛的得分数据。</p>
<p>但是这个数据表不满足第二范式，因为数据表中的字段之间还存在着如下的对应关系：</p>
<p>(球员编号) → (姓名，年龄)</p>
<p>(比赛编号) → (比赛时间, 比赛场地)</p>
<p>也就是说候选键中的某个字段决定了非主属性。你也可以理解为，对于非主属性来说，并非完全依赖候选键。这样会产生怎样的问题呢？</p>
<ol>
<li>数据冗余：如果一个球员可以参加 m 场比赛，那么球员的姓名和年龄就重复了 m-1 次。一个比赛也可能会有 n 个球员参加，比赛的时间和地点就重复了 n-1 次。</li>
<li>插入异常：如果我们想要添加一场新的比赛，但是这时还没有确定参加的球员都有谁，那么就没法插入。</li>
<li>删除异常：如果我要删除某个球员编号，如果没有单独保存比赛表的话，就会同时把比赛信息删除掉。</li>
<li>更新异常：如果我们调整了某个比赛的时间，那么数据表中所有这个比赛的时间都需要进行调整，否则就会出现一场比赛时间不同的情况。<br>为了避免出现上述的情况，我们可以把球员比赛表设计为下面的三张表。</li>
</ol>
<p>球员 player 表包含球员编号、姓名和年龄等属性；比赛 game 表包含比赛编号、比赛时间和比赛场地等属性；球员比赛关系 player_game 表包含球员编号、比赛编号和得分等属性。</p>
<p>这样的话，每张数据表都符合第二范式，也就避免了异常情况的发生。某种程度上 2NF 是对 1NF 原子性的升级。1NF 告诉我们字段属性需要是原子性的，而 2NF 告诉我们一张表就是一个独立的对象，也就是说一张表只表达一个意思。</p>
<p><strong>3NF 在满足 2NF 的同时，对任何非主属性都不传递依赖于候选键。</strong> 也就是说不能存在非主属性 A 依赖于非主属性 B，非主属性 B 依赖于候选键的情况。</p>
<p>我们用球员 player 表举例子，这张表包含的属性包括球员编号、姓名、球队名称和球队主教练。现在，我们把属性之间的依赖关系画出来，如下图所示：</p>
<p>你能看到球员编号决定了球队名称，同时球队名称决定了球队主教练，非主属性球队主教练就会传递依赖于球员编号，因此不符合 3NF 的要求。</p>
<p>如果要达到 3NF 的要求，需要把数据表拆成下面这样：</p>
<p>球员表的属性包括球员编号、姓名和球队名称；球队表的属性包括球队名称、球队主教练。</p>
<p>我再总结一下，1NF 需要保证表中每个属性都保持原子性；2NF 需要保证表中的非主属性与候选键完全依赖；3NF 需要保证表中的非主属性与候选键不存在传递依赖。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们今天讲解了数据表设计的三种范式。关系型数据库的设计都是基于关系模型的，在关系模型中存在着 4 种键，这些键的核心作用就是标识。</p>
<p>在这些概念的基础上，我又讲了 1NF，2NF 和 3NF。我们经常会与这三种范式打交道，利用它们建立冗余度小、结构合理的数据库。</p>
<p>有一点需要注意的是，这些范式只是提出了设计的标准，实际上设计数据表时，未必要符合这些原则。一方面是因为这些范式本身存在一些问题，可能会带来插入，更新，删除等的异常情况（这些会在下一讲举例说明），另一方面，它们也可能降低会查询的效率。这是为什么呢？因为范式等级越高，设计出来的数据表就越多，进行数据查询的时候就可能需要关联多张表，从而影响查询效率。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/31/20%E4%B8%A8%E5%BD%93%E6%88%91%E4%BB%AC%E6%80%9D%E8%80%83%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E4%BC%98%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BB%B4%E5%BA%A6%E5%8F%AF%E4%BB%A5%E9%80%89%E6%8B%A9%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/31/20%E4%B8%A8%E5%BD%93%E6%88%91%E4%BB%AC%E6%80%9D%E8%80%83%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E4%BC%98%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BB%B4%E5%BA%A6%E5%8F%AF%E4%BB%A5%E9%80%89%E6%8B%A9%EF%BC%9F/" itemprop="url">20丨当我们思考数据库调优的时候，都有哪些维度可以选择？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-31T17:49:01+08:00">
                2020-03-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/" itemprop="url" rel="index">
                    <span itemprop="name">SQL必知必会</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/31/20%E4%B8%A8%E5%BD%93%E6%88%91%E4%BB%AC%E6%80%9D%E8%80%83%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E4%BC%98%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BB%B4%E5%BA%A6%E5%8F%AF%E4%BB%A5%E9%80%89%E6%8B%A9%EF%BC%9F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/03/31/20%E4%B8%A8%E5%BD%93%E6%88%91%E4%BB%AC%E6%80%9D%E8%80%83%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E4%BC%98%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BB%B4%E5%BA%A6%E5%8F%AF%E4%BB%A5%E9%80%89%E6%8B%A9%EF%BC%9F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>从这一篇开始，我们正式进入了 SQL 性能优化篇。在这一模块中，我们会关注如何提升 SQL 查询的效率。你可以思考一下，如何你是一名 DBA 或者开发人员，都有哪些维度可以进行数据库调优？</p>
<p>其实关于数据库调优的知识点非常分散。不同的 DBMS，不同的公司，不同的职位，不同的项目遇到的问题都不尽相同。为了能让你对数据库调优有一个整体的概览，我把这些知识点做了一个梳理，希望能对你有一些帮助。</p>
<p>今天的课程你需要掌握以下几个方面的内容：</p>
<ol>
<li>数据库调优的目标是什么？</li>
<li>如果要进行调优，都有哪些维度可以选择？</li>
<li>如何思考和分析数据库调优这件事？<h3 id="数据库调优的目标"><a href="#数据库调优的目标" class="headerlink" title="数据库调优的目标"></a>数据库调优的目标</h3>简单来说，数据库调优的目的就是要让数据库运行得更快，也就是说响应的时间更快，吞吐量更大。</li>
</ol>
<p>不过随着用户量的不断增加，以及应用程序复杂度的提升，我们很难用“更快”去定义数据库调优的目标，因为用户在不同时间段访问服务器遇到的瓶颈不同，比如双十一促销的时候会带来大规模的并发访问；还有用户在进行不同业务操作的时候，数据库的事务处理和 SQL 查询都会有所不同。因此我们还需要更加精细的定位，去确定调优的目标。</p>
<p>如何确定呢？一般情况下，有两种方式可以得到反馈。</p>
<h3 id="用户的反馈"><a href="#用户的反馈" class="headerlink" title="用户的反馈"></a>用户的反馈</h3><p>用户是我们的服务对象，因此他们的反馈是最直接的。虽然他们不会直接提出技术建议，但是有些问题往往是用户第一时间发现的。我们要重视用户的反馈，找到和数据相关的问题。</p>
<h3 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h3><p>我们可以通过查看数据库日志和操作系统日志等方式找出异常情况，通过它们来定位遇到的问题。</p>
<p>除了这些具体的反馈以外，我们还可以通过监控运行状态来整体了解服务器和数据库的运行情况。</p>
<h3 id="服务器资源使用监控"><a href="#服务器资源使用监控" class="headerlink" title="服务器资源使用监控"></a>服务器资源使用监控</h3><p>通过监控服务器的 CPU、内存、I/O 等使用情况，可以实时了解服务器的性能使用，与历史情况进行对比。</p>
<h3 id="数据库内部状况监控"><a href="#数据库内部状况监控" class="headerlink" title="数据库内部状况监控"></a>数据库内部状况监控</h3><p>在数据库的监控中，活动会话（Active Session）监控是一个重要的指标。通过它，你可以清楚地了解数据库当前是否处于非常繁忙的状态，是否存在 SQL 堆积等。</p>
<p>除了活动会话监控以外，我们也可以对事务、锁等待等进行监控，这些都可以帮助我们对数据库的运行状态有更全面的认识。</p>
<h3 id="对数据库进行调优，都有哪些维度可以进行选择？"><a href="#对数据库进行调优，都有哪些维度可以进行选择？" class="headerlink" title="对数据库进行调优，都有哪些维度可以进行选择？"></a>对数据库进行调优，都有哪些维度可以进行选择？</h3><p>我们需要调优的对象是整个数据库管理系统，它不仅包括 SQL 查询，还包括数据库的部署配置、架构等。从这个角度来说，我们思考的维度就不仅仅局限在 SQL 优化上了。</p>
<p>听起来比较复杂，但其实我们可以一步步通过下面的步骤进行梳理。</p>
<h3 id="第一步，选择适合的-DBMS"><a href="#第一步，选择适合的-DBMS" class="headerlink" title="第一步，选择适合的 DBMS"></a>第一步，选择适合的 DBMS</h3><p>我们之前讲到了 SQL 阵营和 NoSQL 阵营。在 RDBMS 中，常用的有 Oracle，SQL Server 和 MySQL 等。如果对事务性处理以及安全性要求高的话，可以选择商业的数据库产品。这些数据库在事务处理和查询性能上都比较强，比如采用 SQL Server，那么单表存储上亿条数据是没有问题的。如果数据表设计得好，即使不采用分库分表的方式，查询效率也不差。</p>
<p>除此以外，你也可以采用开源的 MySQL 进行存储，我们之前讲到过，它有很多存储引擎可以选择，如果进行事务处理的话可以选择 InnoDB，非事务处理可以选择 MyISAM。</p>
<p>NoSQL 阵营包括键值型数据库、文档型数据库、搜索引擎、列式存储和图形数据库。这些数据库的优缺点和使用场景各有不同，比如列式存储数据库可以大幅度降低系统的 I/O，适合于分布式文件系统和 OLAP，但如果数据需要频繁地增删改，那么列式存储就不太适用了。原因我在答疑篇已经讲过，这里不再赘述。</p>
<p>DBMS 的选择关系到了后面的整个设计过程，所以第一步就是要选择适合的 DBMS。如果已经确定好了 DBMS，那么这步可以跳过，但有时候我们要根据业务需求来进行选择。</p>
<h3 id="第二步，优化表设计"><a href="#第二步，优化表设计" class="headerlink" title="第二步，优化表设计"></a>第二步，优化表设计</h3><p>选择了 DBMS 之后，我们就需要进行表设计了。RDBMS 中，每个对象都可以定义为一张表，表与表之间的关系代表了对象之间的关系。如果用的是 MySQL，我们还可以根据不同表的使用需求，选择不同的存储引擎。除此以外，还有一些优化的原则可以参考：</p>
<p>表结构要尽量遵循第三范式的原则（关于第三范式，我在后面章节会讲）。这样可以让数据结构更加清晰规范，减少冗余字段，同时也减少了在更新，插入和删除数据时等异常情况的发生。<br>如果分析查询应用比较多，尤其是需要进行多表联查的时候，可以采用反范式进行优化。反范式采用空间换时间的方式，通过增加冗余字段提高查询的效率。<br>表字段的数据类型选择，关系到了查询效率的高低以及存储空间的大小。一般来说，如果字段可以采用数值类型就不要采用字符类型；字符长度要尽可能设计得短一些。针对字符类型来说，当确定字符长度固定时，就可以采用 CHAR 类型；当长度不固定时，通常采用 VARCHAR 类型。<br>数据表的结构设计很基础，也很关键。好的表结构可以在业务发展和用户量增加的情况下依然发挥作用，不好的表结构设计会让数据表变得非常臃肿，查询效率也会降低。</p>
<h3 id="第三步，优化逻辑查询"><a href="#第三步，优化逻辑查询" class="headerlink" title="第三步，优化逻辑查询"></a>第三步，优化逻辑查询</h3><p>当我们建立好数据表之后，就可以对数据表进行增删改查的操作了。这时我们首先需要考虑的是逻辑查询优化，什么是逻辑查询优化呢？</p>
<p>SQL 查询优化，可以分为逻辑查询优化和物理查询优化。逻辑查询优化就是通过改变 SQL 语句的内容让 SQL 执行效率更高效，采用的方式是对 SQL 语句进行等价变换，对查询进行重写。重写查询的数学基础就是关系代数。</p>
<p>SQL 的查询重写包括了子查询优化、等价谓词重写、视图重写、条件简化、连接消除和嵌套连接消除等。</p>
<p>比如我们在讲解 EXISTS 子查询和 IN 子查询的时候，会根据小表驱动大表的原则选择适合的子查询。在 WHERE 子句中会尽量避免对字段进行函数运算，它们会让字段的索引失效。</p>
<p>我举一个例子，假设我想对商品评论表中的评论内容进行检索，查询评论内容开头为 abc 的内容都有哪些，如果在 WHERE 子句中使用了函数，语句就会写成下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT comment_id, comment_text, comment_time FROM product_comment WHERE SUBSTRING(comment_text, 1,3)=&apos;abc&apos;</span><br></pre></td></tr></table></figure>
<p>我们可以采用查询重写的方式进行等价替换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT comment_id, comment_text, comment_time FROM product_comment WHERE comment_text LIKE &apos;abc%&apos;</span><br></pre></td></tr></table></figure>
<p>你会发现在数据量大的情况下，第二条 SQL 语句的查询效率要比前面的高很多，执行时间为前者的 1/10。</p>
<h3 id="第四步，优化物理查询"><a href="#第四步，优化物理查询" class="headerlink" title="第四步，优化物理查询"></a>第四步，优化物理查询</h3><p>物理查询优化是将逻辑查询的内容变成可以被执行的物理操作符，从而为后续执行器的执行提供准备。它的核心是高效地建立索引，并通过这些索引来做各种优化。</p>
<p>但你要知道索引不是万能的，我们需要根据实际情况来创建索引。那么都有哪些情况需要考虑呢？</p>
<ol>
<li><p>如果数据重复度高，就不需要创建索引。通常在重复度超过 10% 的情况下，可以不创建这个字段的索引。比如性别这个字段（取值为男和女）。</p>
</li>
<li><p>要注意索引列的位置对索引使用的影响。比如我们在 WHERE 子句中对索引字段进行了表达式的计算，会造成这个字段的索引失效。</p>
</li>
<li><p>要注意联合索引对索引使用的影响。我们在创建联合索引的时候会对多个字段创建索引，这时索引的顺序就很重要了。比如我们对字段 x, y, z 创建了索引，那么顺序是 (x,y,z) 还是 (z,y,x)，在执行的时候就会存在差别。</p>
</li>
<li><p>要注意多个索引对索引使用的影响。索引不是越多越好，因为每个索引都需要存储空间，索引多也就意味着需要更多的存储空间。此外，过多的索引也会导致优化器在进行评估的时候增加了筛选出索引的计算时间，影响评估的效率。<br>查询优化器在对 SQL 语句进行等价变换之后，还需要根据数据表的索引情况和数据情况确定访问路径，这就决定了执行 SQL 时所需要消耗的资源。SQL 查询时需要对不同的数据表进行查询，因此在物理查询优化阶段也需要确定这些查询所采用的路径，具体的情况包括：</p>
</li>
<li><p>单表扫描：对于单表扫描来说，我们可以全表扫描所有的数据，也可以局部扫描。</p>
</li>
<li><p>两张表的连接：常用的连接方式包括了嵌套循环连接、HASH 连接和合并连接。</p>
</li>
<li><p>多张表的连接：多张数据表进行连接的时候，顺序很重要，因为不同的连接路径查询的效率不同，搜索空间也会不同。我们在进行多表连接的时候，搜索空间可能会达到很高的数据量级，巨大的搜索空间显然会占用更多的资源，因此我们需要通过调整连接顺序，将搜索空间调整在一个可接收的范围内。<br>物理查询优化是在确定了逻辑查询优化之后，采用物理优化技术（比如索引等），通过计算代价模型对各种可能的访问路径进行估算，从而找到执行方式中代价最小的作为执行计划。在这个部分中，我们需要掌握的重点是对索引的创建和使用。</p>
</li>
</ol>
<h3 id="第五步，使用-Redis-或-Memcached-作为缓存"><a href="#第五步，使用-Redis-或-Memcached-作为缓存" class="headerlink" title="第五步，使用 Redis 或 Memcached 作为缓存"></a>第五步，使用 Redis 或 Memcached 作为缓存</h3><p>除了可以对 SQL 本身进行优化以外，我们还可以请外援提升查询的效率。</p>
<p>因为数据都是存放到数据库中，我们需要从数据库层中取出数据放到内存中进行业务逻辑的操作，当用户量增大的时候，如果频繁地进行数据查询，会消耗数据库的很多资源。如果我们将常用的数据直接放到内存中，就会大幅提升查询的效率。</p>
<p>键值存储数据库可以帮我们解决这个问题。</p>
<p>常用的键值存储数据库有 Redis 和 Memcached，它们都可以将数据存放到内存中。</p>
<p>从可靠性来说，Redis 支持持久化，可以让我们的数据保存在硬盘上，不过这样一来性能消耗也会比较大。而 Memcached 仅仅是内存存储，不支持持久化。</p>
<p>从支持的数据类型来说，Redis 比 Memcached 要多，它不仅支持 key-value 类型的数据，还支持 List，Set，Hash 等数据结构。 当我们有持久化需求或者是更高级的数据处理需求的时候，就可以使用 Redis。如果是简单的 key-value 存储，则可以使用 Memcached。</p>
<p>通常我们对于查询响应要求高的场景（响应时间短，吞吐量大），可以考虑内存数据库，毕竟术业有专攻。传统的 RDBMS 都是将数据存储在硬盘上，而内存数据库则存放在内存中，查询起来要快得多。不过使用不同的工具，也增加了开发人员的使用成本。</p>
<h3 id="第六步，库级优化"><a href="#第六步，库级优化" class="headerlink" title="第六步，库级优化"></a>第六步，库级优化</h3><p>库级优化是站在数据库的维度上进行的优化策略，比如控制一个库中的数据表数量。另外我们可以采用主从架构优化我们的读写策略。</p>
<p>如果读和写的业务量都很大，并且它们都在同一个数据库服务器中进行操作，那么数据库的性能就会出现瓶颈，这时为了提升系统的性能，优化用户体验，我们可以采用读写分离的方式降低主数据库的负载，比如用主数据库（master）完成写操作，用从数据库（slave）完成读操作。</p>
<p>除此以外，我们还可以对数据库分库分表。当数据量级达到亿级以上时，有时候我们需要把一个数据库切成多份，放到不同的数据库服务器上，减少对单一数据库服务器的访问压力。如果你使用的是 MySQL，就可以使用 MySQL 自带的分区表功能，当然你也可以考虑自己做垂直切分和水平切分。</p>
<p>什么情况下做垂直切分，什么情况下做水平切分呢？</p>
<p>如果数据库中的数据表过多，可以采用垂直分库的方式，将关联的数据表部署在一个数据库上。</p>
<p>如果数据表中的列过多，可以采用垂直分表的方式，将数据表分拆成多张，把经常一起使用的列放到同一张表里。</p>
<p>如果数据表中的数据达到了亿级以上，可以考虑水平切分，将大的数据表分拆成不同的子表，每张表保持相同的表结构。比如你可以按照年份来划分，把不同年份的数据放到不同的数据表中。2017 年、2018 年和 2019 年的数据就可以分别放到三张数据表中。</p>
<p>采用垂直分表的形式，就是将一张数据表分拆成多张表，采用水平拆分的方式，就是将单张数据量大的表按照某个属性维度分成不同的小表。</p>
<p>但需要注意的是，分拆在提升数据库性能的同时，也会增加维护和使用成本。</p>
<h3 id="我们该如何思考和分析数据库调优这件事"><a href="#我们该如何思考和分析数据库调优这件事" class="headerlink" title="我们该如何思考和分析数据库调优这件事"></a>我们该如何思考和分析数据库调优这件事</h3><p>做任何事情之前，我们都需要确认目标。在数据库调优中，我们的目标就是响应时间更快，吞吐量更大。利用宏观的监控工具和微观的日志分析可以帮我们快速找到调优的思路和方式。</p>
<p>虽然每个人的情况都不一样，但我们同样需要对数据库调优这件事有一个整体的认知。在思考数据库调优的时候，可以从三个维度进行考虑。</p>
<h3 id="首先，选择比努力更重要。"><a href="#首先，选择比努力更重要。" class="headerlink" title="首先，选择比努力更重要。"></a>首先，选择比努力更重要。</h3><p>在进行 SQL 调优之前，可以先选择 DBMS 和数据表的设计方式。你能看到，不同的 DBMS 直接决定了后面的操作方式，数据表的设计方式也直接影响了后续的 SQL 查询语句。</p>
<p>另外，你可以把 SQL 查询优化分成两个部分，逻辑查询优化和物理查询优化。</p>
<p>虽然 SQL 查询优化的技术有很多，但是大方向上完全可以分成逻辑查询优化和物理查询优化两大块。逻辑查询优化就是通过 SQL 等价变换提升查询效率，直白一点就是说，换一种查询写法执行效率可能更高。物理查询优化则是通过索引和表连接方式等技术来进行优化，这里重点需要掌握索引的使用。</p>
<h3 id="最后，我们可以通过外援来增强数据库的性能。"><a href="#最后，我们可以通过外援来增强数据库的性能。" class="headerlink" title="最后，我们可以通过外援来增强数据库的性能。"></a>最后，我们可以通过外援来增强数据库的性能。</h3><p>单一的数据库总会遇到各种限制，不如取长补短，利用外援的方式。</p>
<p>另外通过对数据库进行垂直或者水平切分，突破单一数据库或数据表的访问限制，提升查询的性能。</p>
<p>本篇文章中涉及到的概念和知识点比较多，也有可能出现纰漏，不过没有关系，我会在在后续的文章中陆续进行讲解。希望这篇文章可以让你站在一个宏观的角度对数据库的调优有系统性的认知，对今后的工作有一些启发。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/30/19%E4%B8%A8%E5%9F%BA%E7%A1%80%E7%AF%87%E6%80%BB%E7%BB%93%EF%BC%9A%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E3%80%81%E9%80%9A%E9%85%8D%E7%AC%A6%E4%BB%A5%E5%8F%8A%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/30/19%E4%B8%A8%E5%9F%BA%E7%A1%80%E7%AF%87%E6%80%BB%E7%BB%93%EF%BC%9A%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E3%80%81%E9%80%9A%E9%85%8D%E7%AC%A6%E4%BB%A5%E5%8F%8A%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%9F/" itemprop="url">19丨基础篇总结：如何理解查询优化、通配符以及存储过程？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-30T15:49:01+08:00">
                2020-03-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/" itemprop="url" rel="index">
                    <span itemprop="name">SQL必知必会</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/30/19%E4%B8%A8%E5%9F%BA%E7%A1%80%E7%AF%87%E6%80%BB%E7%BB%93%EF%BC%9A%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E3%80%81%E9%80%9A%E9%85%8D%E7%AC%A6%E4%BB%A5%E5%8F%8A%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%9F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/03/30/19%E4%B8%A8%E5%9F%BA%E7%A1%80%E7%AF%87%E6%80%BB%E7%BB%93%EF%BC%9A%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E3%80%81%E9%80%9A%E9%85%8D%E7%AC%A6%E4%BB%A5%E5%8F%8A%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%9F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>到这一篇的时候，意味着 SQL 专栏的基础部分正式更新完毕。在文章更新的时候，谢谢大家积极地评论和提问，让专栏增色不少。我总结了一些基础篇的常见问题，希望能对你有所帮助。答疑篇主要包括了 DBMS、查询优化、存储过程、事务处理等一些问题。</p>
<h3 id="关于各种-DBMS-的介绍"><a href="#关于各种-DBMS-的介绍" class="headerlink" title="关于各种 DBMS 的介绍"></a>关于各种 DBMS 的介绍</h3><h3 id="答疑-1"><a href="#答疑-1" class="headerlink" title="答疑 1"></a>答疑 1</h3><p>文章中有句话不太理解，“列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的 I/O”，可以解释一些“降低系统 I/O”是什么意思吗？</p>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>行式存储是把一行的数据都串起来进行存储，然后再存储下一行。同样，列式存储是把一列的数据都串起来进行存储，然后再存储下一列。这样做的话，相邻数据的数据类型都是一样的，更容易压缩，压缩之后就自然降低了 I/O。</p>
<p>我们还需要从数据处理的需求出发，去理解行式存储和列式存储。数据处理可以分为 OLTP（联机事务处理）和 OLAP（联机分析处理）两大类。</p>
<p>OLTP 一般用于处理客户的事务和进行查询，需要随时对数据表中的记录进行增删改查，对实时性要求高。</p>
<p>OLAP 一般用于市场的数据分析，通常数据量大，需要进行复杂的分析操作，可以对大量历史数据进行汇总和分析，对实时性要求不高。</p>
<p>那么对于 OLTP 来说，由于随时需要对数据记录进行增删改查，更适合采用行式存储，因为一行数据的写入会同时修改多个列。传统的 RDBMS 都属于行式存储，比如 Oracle、SQL Server 和 MySQL 等。</p>
<p>对于 OLAP 来说，由于需要对大量历史数据进行汇总和分析，则适合采用列式存储，这样的话汇总数据会非常快，但是对于插入（INSERT）和更新（UPDATE）会比较麻烦，相比于行式存储性能会差不少。</p>
<p>所以说列式存储适合大批量数据查询，可以降低 I/O，但如果对实时性要求高，则更适合行式存储。</p>
<h3 id="关于查询优化"><a href="#关于查询优化" class="headerlink" title="关于查询优化"></a>关于查询优化</h3><h3 id="答疑-1-1"><a href="#答疑-1-1" class="headerlink" title="答疑 1"></a>答疑 1</h3><p>在 MySQL 中统计数据表的行数，可以使用三种方式：SELECT COUNT(<em>)、SELECT COUNT(1)和SELECT COUNT(具体字段)，使用这三者之间的查询效率是怎样的？之前看到说是：SELECT COUNT(</em>)＞ SELECT COUNT(1)＞ SELECT COUNT(具体字段)。</p>
<h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><p>在 MySQL InnoDB 存储引擎中，COUNT(*)和COUNT(1)都是对所有结果进行COUNT。如果有 WHERE 子句，则是对所有符合筛选条件的数据行进行统计；如果没有 WHERE 子句，则是对数据表的数据行数进行统计。</p>
<p>因此COUNT(*)和COUNT(1)本质上并没有区别，执行的复杂度都是O(N)，也就是采用全表扫描，进行循环 + 计数的方式进行统计。</p>
<p>如果是 MySQL MyISAM 存储引擎，统计数据表的行数只需要O(1)的复杂度，这是因为每张 MyISAM 的数据表都有一个 meta 信息存储了row_count值，而一致性则由表级锁来保证。因为 InnoDB 支持事务，采用行级锁和 MVCC 机制，所以无法像 MyISAM 一样，只维护一个row_count变量，因此需要采用扫描全表，进行循环 + 计数的方式来完成统计。</p>
<p>需要注意的是，在实际执行中，COUNT(*)和COUNT(1)的执行时间可能略有差别，不过你还是可以把它俩的执行效率看成是相等的。</p>
<p>另外在 InnoDB 引擎中，如果采用COUNT(<em>)和COUNT(1)来统计数据行数，要尽量采用二级索引。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引（非聚簇索引）。对于COUNT(</em>)和COUNT(1)来说，它们不需要查找具体的行，只是统计行数，系统会自动采用占用空间更小的二级索引来进行统计。</p>
<p>然而如果想要查找具体的行，那么采用主键索引的效率更高。如果有多个二级索引，会使用 key_len 小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。</p>
<p>这里我总结一下：</p>
<p>一般情况下，三者执行的效率为 COUNT(<em>)= COUNT(1)&gt; COUNT(字段)。我们尽量使用COUNT(</em>)，当然如果你要统计的是某个字段的非空数据行数，则另当别论，毕竟比较执行效率的前提是结果一样才可以。<br>如果要统计COUNT(<em>)，尽量在数据表上建立二级索引，系统会自动采用key_len小的二级索引进行扫描，这样当我们使用SELECT COUNT(</em>)的时候效率就会提升，有时候可以提升几倍甚至更高。<br>答疑 2<br>在 MySQL 中，LIMIT关键词是最后执行的，如果可以确定只有一条结果，那么就起不到查询优化的效果了吧，因为LIMIT是对最后的结果集过滤，如果结果集本来就只有一条，那就没有什么用了。</p>
<h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><p>如果你可以确定结果集只有一条，那么加上LIMIT 1的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。这里指的查询优化针对的是会扫描全表的 SQL 语句，如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上LIMIT 1了。</p>
<p>关于通配符的解释<br>关于查询语句中通配符的使用理解，我举了一个查询英雄名除了第一个字以外，包含“太”字的英雄都有谁的例子，使用的 SQL 语句是：</p>
<p>SQL&gt; SELECT name FROM heros WHERE name LIKE ‘_% 太 %’<br>（_）匹配任意一个字符，（%） 匹配大于等于 0 个任意字符。</p>
<p>所以通配符’_%太%’说明在第一个字符之后需要有“太”字，这里就不能匹配上“太乙真人”，但是可以匹配上“东皇太一”。如果数据表中有“太乙真人太太”，那么结果集中也可以匹配到。</p>
<p>另外，单独的LIKE ‘%’无法查出 NULL 值，比如：SELECT * FROM heros WHERE role_assist LIKE ‘%’。</p>
<h3 id="答疑-4"><a href="#答疑-4" class="headerlink" title="答疑 4"></a>答疑 4</h3><p>可以理解在 WHERE 条件字段上加索引，但是为什么在 ORDER BY 字段上还要加索引呢？这个时候已经通过 WHERE 条件过滤得到了数据，已经不需要再筛选过滤数据了，只需要根据字段排序就好了。</p>
<h3 id="解答-3"><a href="#解答-3" class="headerlink" title="解答"></a>解答</h3><p>在 MySQL 中，支持两种排序方式，分别是 FileSort 和 Index 排序。在 Index 排序中，索引可以保证数据的有序性，不需要再进行排序，效率更高。而 FileSort 排序则一般在内存中进行排序，占用 CPU 较多。如果待排结果较大，会产生临时文件 I/O 到磁盘进行排序的情况，效率较低。</p>
<p>所以使用 ORDER BY 子句时，应该尽量使用 Index 排序，避免使用 FileSort 排序。当然你可以使用 explain 来查看执行计划，看下优化器是否采用索引进行排序。</p>
<p>优化建议：</p>
<p>SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中避免全表扫描，在 ORDER BY 子句避免使用 FileSort 排序。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。一般情况下，优化器会帮我们进行更好的选择，当然我们也需要建立合理的索引。<br>尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列；如果不同就使用联合索引。<br>无法使用 Index 时，需要对 FileSort 方式进行调优。</p>
<h3 id="答疑-5"><a href="#答疑-5" class="headerlink" title="答疑 5"></a>答疑 5</h3><p>ORDER BY 是对分的组排序还是对分组中的记录排序呢？</p>
<h3 id="解答-4"><a href="#解答-4" class="headerlink" title="解答"></a>解答</h3><p>ORDER BY 就是对记录进行排序。如果你在 ORDER BY 前面用到了 GROUP BY，实际上这是一种分组的聚合方式，已经把一组的数据聚合成为了一条记录，再进行排序的时候，相当于对分的组进行了排序。</p>
<h3 id="答疑-6"><a href="#答疑-6" class="headerlink" title="答疑 6"></a>答疑 6</h3><p>请问下关于 SELECT 语句内部的执行步骤。</p>
<h3 id="解答-5"><a href="#解答-5" class="headerlink" title="解答"></a>解答</h3><p>一条完整的 SELECT 语句内部的执行顺序是这样的：</p>
<p>FROM 子句组装数据（包括通过 ON 进行连接）；<br>WHERE 子句进行条件筛选；<br>GROUP BY 分组 ；<br>使用聚集函数进行计算；<br>HAVING 筛选分组；<br>计算所有的表达式；<br>SELECT 的字段；<br>ORDER BY 排序；<br>LIMIT 筛选。</p>
<h3 id="答疑-7"><a href="#答疑-7" class="headerlink" title="答疑 7"></a>答疑 7</h3><p>不太理解哪种情况下应该使用 EXISTS，哪种情况应该用 IN。选择的标准是看能否使用表的索引吗？</p>
<h3 id="解答-6"><a href="#解答-6" class="headerlink" title="解答"></a>解答</h3><p>索引是个前提，其实选择与否还是要看表的大小。你可以将选择的标准理解为小表驱动大表。在这种方式下效率是最高的。</p>
<p>比如下面这样：</p>
<p> SELECT * FROM A WHERE cc IN (SELECT cc FROM B)<br> SELECT * FROM A WHERE EXISTS (SELECT cc FROM B WHERE B.cc=A.cc)<br>当 A 小于 B 时，用 EXISTS。因为 EXISTS 的实现，相当于外表循环，实现的逻辑类似于：</p>
<p> for i in A<br>     for j in B<br>         if j.cc == i.cc then …<br>当 B 小于 A 时用 IN，因为实现的逻辑类似于：</p>
<p> for i in B<br>     for j in A<br>         if j.cc == i.cc then …<br>哪个表小就用哪个表来驱动，A 表小就用 EXISTS，B 表小就用 IN。</p>
<h3 id="关于存储过程"><a href="#关于存储过程" class="headerlink" title="关于存储过程"></a>关于存储过程</h3><h3 id="答疑-1-2"><a href="#答疑-1-2" class="headerlink" title="答疑 1"></a>答疑 1</h3><p>在使用存储过程声明变量时，都支持哪些数据类型呢？</p>
<h3 id="解答-7"><a href="#解答-7" class="headerlink" title="解答"></a>解答</h3><p>不同的 DBMS 对数据类型的定义不同，你需要查询相关的 DBMS 文档。以 MySQL 为例，常见的数据类型可以分成三类，分别是数值类型、字符串类型和日期／时间类型。</p>
<h3 id="答疑-2"><a href="#答疑-2" class="headerlink" title="答疑 2"></a>答疑 2</h3><p>“IN 参数必须在调用存储过程时指定”的含义是什么？我查询了 MySQL 的存储过程定义，可以不包含 IN 参数。当存储过程的定义语句里有 IN 参数时，存储过程的语句中必须用到这个参数吗?</p>
<h3 id="解答-8"><a href="#解答-8" class="headerlink" title="解答"></a>解答</h3><p>如果存储过程定义了 IN 参数，就需要在调用的时候传入。当然在定义存储过程的时候，如果不指定参数类型，就默认是 IN 类型的参数。因为 IN 参数在存储过程中是默认值，可以省略不写。比如下面两种定义方式都是一样的：</p>
<p>CREATE PROCEDURE <code>add_num</code>(IN n INT)<br>CREATE PROCEDURE <code>add_num</code>(n INT)<br>在存储过程中的语句里，不一定要用到 IN 参数，只是在调用的时候需要传入这个。另外 IN 参数在存储过程中进行了修改，也不会进行返回的。如果想要返回参数，需要使用 OUT，或者 INOUT 参数类型。</p>
<h3 id="关于事务处理"><a href="#关于事务处理" class="headerlink" title="关于事务处理"></a>关于事务处理</h3><h3 id="答疑-1-3"><a href="#答疑-1-3" class="headerlink" title="答疑 1"></a>答疑 1</h3><p>如果INSERT INTO test SELECT ‘关羽’;之后没有执行 COMMIT，结果应该是空。但是我执行出来的结果是’关羽’，为什么 ROLLBACK 没有全部回滚？</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test(name varchar(255), PRIMARY KEY (name)) ENGINE=InnoDB;</span><br><span class="line">BEGIN;</span><br><span class="line">INSERT INTO test SELECT &apos;关羽&apos;;</span><br><span class="line">BEGIN;</span><br><span class="line">INSERT INTO test SELECT &apos;张飞&apos;;</span><br><span class="line">INSERT INTO test SELECT &apos;张飞&apos;;</span><br><span class="line">ROLLBACK;</span><br><span class="line">SELECT * FROM test;</span><br></pre></td></tr></table></figure>
<p>解答<br>先解释下连续 BEGIN 的情况。</p>
<p>在 MySQL 中 BEGIN 用于开启事务，如果是连续 BEGIN，当开启了第一个事务，还没有进行 COMMIT 提交时，会直接进行第二个事务的 BEGIN，这时数据库会隐式地 COMMIT 第一个事务，然后再进入到第二个事务。</p>
<p>为什么 ROLLBACK 没有全部回滚呢？</p>
<p>因为 ROLLBACK 是针对当前事务的，在 BEGIN 之后已经开启了第二个事务，当遇到 ROLLBACK 的时候，第二个事务都进行了回滚，也就得到了第一个事务执行之后的结果即“关羽”。</p>
<p>关于事务的 ACID，以及我们使用 COMMIT 和 ROLLBACK 来控制事务的时候，有一个容易出错的地方。</p>
<p>在一个事务的执行过程中可能会失败。遇到失败的时候是进行回滚，还是将事务执行过程中已经成功操作的来进行提交，这个逻辑是需要开发者自己来控制的。</p>
<p>这里开发者可以决定，如果遇到了小错误是直接忽略，提交事务，还是遇到任何错误都进行回滚。如果我们强行进行 COMMIT，数据库会将这个事务中成功的操作进行提交，它会认为你觉得已经是 ACID 了（就是你认为可以做 COMMIT 了，即使遇到了一些小问题也是可以忽略的）。</p>
<p>我在今天的文章里重点解答了一些问题，还有一些未解答的会留在评论里进行回复。最后出一道思考题吧。</p>
<p>请你自己写出下面操作的运行结果（你可以把它作为一道笔试题，自己写出结果，再与实际的运行结果进行比对）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS test;</span><br><span class="line">CREATE TABLE test(name varchar(255), PRIMARY KEY (name)) ENGINE=InnoDB;</span><br><span class="line">BEGIN;</span><br><span class="line">INSERT INTO test SELECT &apos;关羽&apos;;</span><br><span class="line">BEGIN;</span><br><span class="line">INSERT INTO test SELECT &apos;张飞&apos;;</span><br><span class="line">INSERT INTO test SELECT &apos;张飞&apos;;</span><br><span class="line">COMMIT;</span><br><span class="line">SELECT * FROM test</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/29/18%E4%B8%A8SQLAlchemy%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Python%20ORM%E6%A1%86%E6%9E%B6%E6%9D%A5%E6%93%8D%E4%BD%9CMySQL%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/29/18%E4%B8%A8SQLAlchemy%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Python%20ORM%E6%A1%86%E6%9E%B6%E6%9D%A5%E6%93%8D%E4%BD%9CMySQL%EF%BC%9F/" itemprop="url">18丨SQLAlchemy：如何使用Python ORM框架来操作MySQL？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-29T15:49:01+08:00">
                2020-03-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/" itemprop="url" rel="index">
                    <span itemprop="name">SQL必知必会</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/29/18%E4%B8%A8SQLAlchemy%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Python%20ORM%E6%A1%86%E6%9E%B6%E6%9D%A5%E6%93%8D%E4%BD%9CMySQL%EF%BC%9F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/03/29/18%E4%B8%A8SQLAlchemy%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Python%20ORM%E6%A1%86%E6%9E%B6%E6%9D%A5%E6%93%8D%E4%BD%9CMySQL%EF%BC%9F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上节课，我介绍了 Python DB API 规范的作用，以及如何使用 MySQL 官方的 mysql-connector 驱动来完成数据库的连接和使用。在项目比较小的时候，我们可以直接使用 SQL 语句，通过 mysql-connector 完成与 MySQL 的交互，但是任何事物都有两面性，随着项目规模的增加，代码会越来越复杂，维护的成本也越来越高，这时 mysql-connector 就不够用了，我们需要更好的设计模式。</p>
<p>Python 还有另一种方式可以与 MySQL 进行交互，这种方式采用的是 ORM 框架。我们今天就来讲解如何使用 ORM 框架操作 MySQL，那么今天的课程你需要掌握以下几个方面的内容：</p>
<ol>
<li>什么是 ORM 框架，以及为什么要使用 ORM 框架？</li>
<li>Python 中的 ORM 框架都有哪些？</li>
<li>如何使用 SQLAlchemy 来完成与 MySQL 的交互？<h3 id="我们为什么要使用-ORM-框架？"><a href="#我们为什么要使用-ORM-框架？" class="headerlink" title="我们为什么要使用 ORM 框架？"></a>我们为什么要使用 ORM 框架？</h3>在讲解 ORM 框架之前，我们需要先了解什么是持久化。如下图所示，持久化层在业务逻辑层和数据库层起到了衔接的作用，它可以将内存中的数据模型转化为存储模型，或者将存储模型转化为内存中的数据模型。</li>
</ol>
<p>你可能会想到，我们在讲事务的 4 大特性 ACID 时，提到过持久性。你可以简单地理解为，持久性就是将对象数据永久存储在数据库中。通常我们将数据库的作用理解为永久存储，将内存理解为暂时存储。我们在程序的层面操作数据，其实都是把数据放到内存中进行处理，如果需要数据就会通过持久化层，从数据库中取数据；如果需要保存数据，就是将对象数据通过持久化层存储到数据库中。</p>
<p>那么 ORM 解决的是什么问题呢？它提供了一种持久化模式，可以高效地对数据库进行访问。ORM 的英文是 Object Relation Mapping，中文叫对象关系映射。它是 RDBMS 和业务实体对象之间的一个映射，从图中你也能看到，它可以把底层的 RDBMS 封装成业务实体对象，提供给业务逻辑层使用。程序员往往关注业务逻辑层面，而不是底层数据库该如何访问，以及如何编写 SQL 语句获取数据等等。采用 ORM，就可以从数据库的设计层面转化成面向对象的思维。</p>
<p>我在开篇的时候提到过，随着项目规模的增大，在代码层编写 SQL 语句访问数据库会降低开发效率，也会提升维护成本，因此越来越多的开发人员会采用基于 ORM 的方式来操作数据库。这样做的好处就是一旦定义好了对象模型，就可以让它们简单可复用，从而不必关注底层的数据库访问细节，我们只要将注意力集中到业务逻辑层面就可以了。由此还可以带来另一点好处，那就是即便数据库本身进行了更换，在业务逻辑代码上也不会有大的调整。这是因为 ORM 抽象了数据的存取，同时也兼容多种 DBMS，我们不用关心底层采用的到底是哪种 DBMS，是 MySQL，SQL Server，PostgreSQL 还是 SQLite。</p>
<p>但没有一种模式是完美的，采用 ORM 当然也会付出一些代价，比如性能上的一些损失。面对一些复杂的数据查询，ORM 会显得力不从心。虽然可以实现功能，但相比于直接编写 SQL 查询语句来说，ORM 需要编写的代码量和花费的时间会比较多，这种情况下，直接编写 SQL 反而会更简单有效。</p>
<p>其实你也能看出来，没有一种方式是一劳永逸的，在实际工作中，我们需要根据需求选择适合的方式。</p>
<h3 id="Python-中的-ORM-框架都有哪些"><a href="#Python-中的-ORM-框架都有哪些" class="headerlink" title="Python 中的 ORM 框架都有哪些"></a>Python 中的 ORM 框架都有哪些</h3><p>ORM 框架帮我们适配了各种 DBMS，同时我们也可以选择不同的 ORM 框架。如果你用 Python 的话，有三种主流的 ORM 框架。</p>
<p>第一个是 Django，它是 Python 的 WEB 应用开发框架，本身走大而全的方式。Django 采用了 MTV 的框架模式，包括了 Model（模型），View（视图）和 Template（模版）。Model 模型只是 Django 的一部分功能，我们可以通过它来实现数据库的增删改查操作。</p>
<p>一个 Model 映射到一个数据表，如下图所示：</p>
<p>从这张图上你能直观地看到，ORM 的作用就是建立了对象关系映射。模型的每个属性代表数据表中的一个字段，我们通过操作类实例对象，对数据表中的数据行进行增删改查等操作。</p>
<p>第二个是 SQLALchemy，它也是 Python 中常用的 ORM 框架之一。它提供了 SQL 工具包及 ORM 工具，如果你想用支持 ORM 和支持原生 SQL 两种方式的工具，那么 SQLALchemy 是很好的选择。另外 SQLALchemy 的社区更加活跃，这对项目实施会很有帮助。</p>
<p>第三个是 peewee，这是一个轻量级的 ORM 框架，简单易用。peewee 采用了 Model 类、Field 实例和 Model 实例来与数据库建立映射关系，从而完成面向对象的管理方式。使用起来方便，学习成本也低。</p>
<h3 id="如何使用-SQLAlchemy-来操作-MySQL"><a href="#如何使用-SQLAlchemy-来操作-MySQL" class="headerlink" title="如何使用 SQLAlchemy 来操作 MySQL"></a>如何使用 SQLAlchemy 来操作 MySQL</h3><p>下面我们来看下如何使用 SQLAlchemy 工具对 player 数据表进行增删改查，在使用前，你需要先安装相应的工具包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pip install sqlalchemy</span><br><span class="line">初始化数据库连接</span><br><span class="line">from sqlalchemy import create_engine</span><br><span class="line"># 初始化数据库连接，修改为你的数据库用户名和密码</span><br><span class="line">engine = create_engine(&apos;mysql+mysqlconnector://root:password@localhost:3306/wucai&apos;)</span><br></pre></td></tr></table></figure>
<p>create_engine 的使用方法类似我们在上篇文章中提到的 mysql.connector，都需要提供数据<br>库 + 数据库连接框架，即对应的是mysql+mysqlconnector，后面的是用户名:密码@IP地址:端口号/数据库名称。</p>
<h3 id="创建模型"><a href="#创建模型" class="headerlink" title="创建模型"></a>创建模型</h3><p>我们已经创建了 player 数据表，这里需要创建相应的 player 模型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 定义 Player 对象:</span><br><span class="line">class Player(Base):</span><br><span class="line">    # 表的名字:</span><br><span class="line">    __tablename__ = &apos;player&apos;</span><br><span class="line"> </span><br><span class="line">    # 表的结构:</span><br><span class="line">    player_id = Column(Integer, primary_key=True, autoincrement=True)</span><br><span class="line">    team_id = Column(Integer)</span><br><span class="line">    player_name = Column(String(255))</span><br><span class="line">    height = Column(Float(3,2))</span><br></pre></td></tr></table></figure>
<p>这里需要说明的是，<strong>tablename</strong> 指明了模型对应的数据表名称，即 player 数据表。同时我们在 Player 模型中对采用的变量名进行定义，变量名需要和数据表中的字段名称保持一致，否则会找不到数据表中的字段。在 SQLAlchemy 中，我们采用 Column 对字段进行定义，常用的数据类型如下：</p>
<p>除了指定 Column 的数据类型以外，我们也可以指定 Column 的参数，这些参数可以帮我们对对象创建列约束：</p>
<p>这里需要说明的是，如果你使用相应的数据类型，那么需要提前在 SQLAlchemy 中进行引用，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from sqlalchemy import Column, String, Integer, Float</span><br></pre></td></tr></table></figure>
<p>###对数据表进行增删改查<br>假设我们想给 player 表增加一名新球员，姓名为“约翰·科林斯”，球队 ID 为 1003（即亚特兰大老鹰），身高为 2.08。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 创建 DBSession 类型:</span><br><span class="line">DBSession = sessionmaker(bind=engine)</span><br><span class="line"># 创建 session 对象:</span><br><span class="line">session = DBSession()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 创建 Player 对象:</span><br><span class="line">new_player = Player(team_id = 1003, player_name = &quot; 约翰 - 科林斯 &quot;, height = 2.08)</span><br><span class="line"># 添加到 session:</span><br><span class="line">session.add(new_player)</span><br><span class="line"># 提交即保存到数据库:</span><br><span class="line">session.commit()</span><br><span class="line"># 关闭 session:</span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure>
<p>这里，我们首先需要初始化 DBSession，相当于创建一个数据库的会话实例 session。通过 session 来完成新球员的添加。对于新球员的数据，我们可以通过 Player 类来完成创建，在参数中指定相应的team_id, player_name, height即可。</p>
<p>然后把创建好的对象 new_player 添加到 session 中，提交到数据库即可完成添加数据的操作。</p>
<p>接着，我们来看一下如何查询数据。</p>
<p>添加完插入的新球员之后，我们可以查询下身高 ≥ 2.08m 的球员都有哪些，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 增加 to_dict() 方法到 Base 类中</span><br><span class="line">def to_dict(self):</span><br><span class="line">    return &#123;c.name: getattr(self, c.name, None)</span><br><span class="line">            for c in self.__table__.columns&#125;</span><br><span class="line"># 将对象可以转化为 dict 类型</span><br><span class="line">Base.to_dict = to_dict</span><br><span class="line"># 查询身高 &gt;=2.08 的球员有哪些</span><br><span class="line">rows = session.query(Player).filter(Player.height &gt;= 2.08).all()</span><br><span class="line">print([row.to_dict() for row in rows])</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;&apos;player_id&apos;: 10003, &apos;team_id&apos;: 1001, &apos;player_name&apos;: &apos;安德烈 - 德拉蒙德&apos;, &apos;height&apos;: Decimal(&apos;2.1100000000&apos;)&#125;, &#123;&apos;player_id&apos;: 10004, &apos;team_id&apos;: 1001, &apos;player_name&apos;: &apos;索恩 - 马克&apos;, &apos;height&apos;: Decimal(&apos;2.1600000000&apos;)&#125;, &#123;&apos;player_id&apos;: 10009, &apos;team_id&apos;: 1001, &apos;player_name&apos;: &apos;扎扎 - 帕楚里亚&apos;, &apos;height&apos;: Decimal(&apos;2.1100000000&apos;)&#125;, &#123;&apos;player_id&apos;: 10010, &apos;team_id&apos;: 1001, &apos;player_name&apos;: &apos;乔恩 - 洛伊尔&apos;, &apos;height&apos;: Decimal(&apos;2.0800000000&apos;)&#125;, &#123;&apos;player_id&apos;: 10011, &apos;team_id&apos;: 1001, &apos;player_name&apos;: &apos;布雷克 - 格里芬&apos;, &apos;height&apos;: Decimal(&apos;2.0800000000&apos;)&#125;, &#123;&apos;player_id&apos;: 10015, &apos;team_id&apos;: 1001, &apos;player_name&apos;: &apos;亨利 - 埃伦森&apos;, &apos;height&apos;: Decimal(&apos;2.1100000000&apos;)&#125;, &#123;&apos;player_id&apos;: 10023, &apos;team_id&apos;: 1002, &apos;player_name&apos;: &apos;多曼塔斯 - 萨博尼斯&apos;, &apos;height&apos;: Decimal(&apos;2.1100000000&apos;)&#125;, &#123;&apos;player_id&apos;: 10024, &apos;team_id&apos;: 1002, &apos;player_name&apos;: &apos;迈尔斯 - 特纳&apos;, &apos;height&apos;: Decimal(&apos;2.1100000000&apos;)&#125;, &#123;&apos;player_id&apos;: 10032, &apos;team_id&apos;: 1002, &apos;player_name&apos;: &apos;TJ- 利夫&apos;, &apos;height&apos;: Decimal(&apos;2.0800000000&apos;)&#125;, &#123;&apos;player_id&apos;: 10033, &apos;team_id&apos;: 1002, &apos;player_name&apos;: &apos;凯尔 - 奥奎因&apos;, &apos;height&apos;: Decimal(&apos;2.0800000000&apos;)&#125;, &#123;&apos;player_id&apos;: 10037, &apos;team_id&apos;: 1002, &apos;player_name&apos;: &apos;伊凯·阿尼博古&apos;, &apos;height&apos;: Decimal(&apos;2.0800000000&apos;)&#125;, &#123;&apos;player_id&apos;: 10038, &apos;team_id&apos;: 1003, &apos;player_name&apos;: &apos;约翰 - 科林斯&apos;, &apos;height&apos;: Decimal(&apos;2.0800000000&apos;)&#125;]</span><br></pre></td></tr></table></figure>
<p>如果我们对整个数据行进行查询，采用的是session.query(Player)，相当于使用的是 SELECT *。这时如果我们想要在 Python 中对 query 结果进行打印，可以对 Base 类增加to_dict()方法，相当于将对象转化成了 Python 的字典类型。</p>
<p>在进行查询的时候，我们使用的是 filter 方法，对应的是 SQL 中的 WHERE 条件查询。除此之外，filter 也支持多条件查询。</p>
<p>如果是 AND 的关系，比如我们想要查询身高 ≥ 2.08，同时身高 ≤ 2.10 的球员，可以写成下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rows = session.query(Player).filter(Player.height &gt;=2.08, Player.height &lt;=2.10).all()</span><br></pre></td></tr></table></figure>
<p>如果是 OR 的关系，比如我们想要查询身高 ≥ 2.08，或者身高 ≤ 2.10 的球员，可以写成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rows = session.query(Player).filter(or_(Player.height &gt;=2.08, Player.height &lt;=2.10)).all()</span><br></pre></td></tr></table></figure>
<p>这里我们使用了 SQLAlchemy 的 or_ 操作符，在使用它之前你需要进行引入，即：from sqlalchemy import or_。</p>
<p>除了多条件查询，SQLAlchemy 也同样支持分组操作、排序和返回指定数量的结果。</p>
<p>比如我想要按照 team_id 进行分组，同时筛选分组后数据行数大于 5 的分组，并且按照分组后数据行数递增的顺序进行排序，显示 team_id 字段，以及每个分组的数据行数。那么代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from sqlalchemy import func</span><br><span class="line">rows = session.query(Player.team_id, func.count(Player.player_id)).group_by(Player.team_id).having(func.count(Player.player_id)&gt;5).order_by(func.count(Player.player_id).asc()).all()</span><br><span class="line">print(rows)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(1001, 20), (1002, 17)]</span><br></pre></td></tr></table></figure>
<p>这里有几点需要注意：</p>
<ol>
<li>我们把需要显示的字段 Player.team_id, func.count(Player.player_id) 作为 query 的参数，其中我们需要用到 sqlalchemy 的 func 类，它提供了各种聚集函数，比如 func.count 函数。</li>
<li>在 query() 后面使用了 group_by() 进行分组，参数设置为 Player.team_id 字段，再使用 having 对分组条件进行筛选，参数为func.count(Player.player_id)&gt;5。</li>
<li>使用 order_by 进行排序，参数为func.count(Player.player_id).asc()，也就是按照分组后的数据行数递增的顺序进行排序，最后使用.all() 方法需要返回全部的数据。<br>你能看到 SQLAlchemy 使用的规则和使用 SELECT 语句的规则差不多，只是封装到了类中作为方法进行调用。</li>
</ol>
<p>接着，我们再来看下如何删除数据。如果我们想要删除某些数据，需要先进行查询，然后再从 session 中把这些数据删除掉。</p>
<p>比如我们想要删除姓名为约翰·科林斯的球员，首先我们需要进行查询，然后从 session 对象中进行删除，最后进行 commit 提交，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">row = session.query(Player).filter(Player.player_name==&apos;约翰 - 科林斯&apos;).first()</span><br><span class="line">session.delete(row)</span><br><span class="line">session.commit()</span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure>
<p>需要说明的是，判断球员姓名是否为约翰·科林斯，这里需要使用（==）。</p>
<p>同样，如果我们想要修改某条数据，也需要进行查询，然后再进行修改。比如我想把球员索恩·马克的身高改成 2.17，那么执行完之后直接对 session 对象进行 commit 操作，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">row = session.query(Player).filter(Player.player_name==&apos;索恩 - 马克&apos;).first()</span><br><span class="line">row.height = 2.17</span><br><span class="line">session.commit()</span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>今天我们使用 SQLAlalchemy 对 MySQL 进行了操作，你能看到这些实现并不复杂，只是需要事先掌握一些使用方法，尤其是如何创建 seesion 对象，以及如何通过 session 对象来完成对数据的增删改查等操作。建议你把文章里的代码都跑一遍，在运行的过程中一定会有更深入的体会。</p>
<p>当然除了学习掌握 SQLAlalchemy 这个 Python ORM 工具以外，我还希望你能了解到 ORM 的价值和不足。如果项目本身不大，那么自己动手写 SQL 语句会比较简单，你可以不使用 ORM 工具，而是直接使用上节课讲到的 mysql-connector。但是随着项目代码量的增加，为了在业务逻辑层与数据库底层进行松耦合，采用 ORM 框架是更加适合的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/27/17%E4%B8%A8%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Python%E6%93%8D%E4%BD%9CMySQL%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/27/17%E4%B8%A8%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Python%E6%93%8D%E4%BD%9CMySQL%EF%BC%9F/" itemprop="url">17丨如何使用Python操作MySQL？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-27T20:30:01+08:00">
                2020-03-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/" itemprop="url" rel="index">
                    <span itemprop="name">SQL必知必会</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/27/17%E4%B8%A8%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Python%E6%93%8D%E4%BD%9CMySQL%EF%BC%9F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/03/27/17%E4%B8%A8%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Python%E6%93%8D%E4%BD%9CMySQL%EF%BC%9F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们之前都是直接在 DBMS 里面进行 SQL 的操作，实际上我们还可以通过后端语言对 DBMS 进行访问以及进行相应的操作，这样更具有灵活性，可以实现一些较为复杂的操作。作为一个后端开发人员，掌握一些 SQL 技术是必须的；作为一个数据库管理人员，了解后端语言如何开发和管理数据库也是很有必要的。</p>
<p>今天我以 Python 为例，讲解下如何对 MySQL 数据库进行操作。你需要掌握以下几个方面的内容：</p>
<p>Python 的 DB API 规范是什么，遵守这个规范有什么用？<br>基于 DB API，MySQL 官方提供了驱动器 mysql-connector，如何使用它来完成对数据库管理系统的操作？<br>CRUD 是最常见的数据库的操作，分别对应数据的增加、读取、修改和删除。在掌握了 mysql-connector 的使用方法之后，如何完成对数据表的 CRUD 操作？</p>
<h3 id="Python-DB-API-规范"><a href="#Python-DB-API-规范" class="headerlink" title="Python DB API 规范"></a>Python DB API 规范</h3><p>Python 可以支持非常多的数据库管理系统，比如 MySQL、Oracle、SQL Server 和 PostgreSQL 等。为了实现对这些 DBMS 的统一访问，Python 需要遵守一个规范，这就是 DB API 规范。我在下图中列出了 DB API 规范的作用，这个规范给我们提供了数据库对象连接、对象交互和异常处理的方式，为各种 DBMS 提供了统一的访问接口。这样做的好处就是如果项目需要切换数据库，Python 层的代码移植会比较简单。<br>我们在使用 Python 对 DBMS 进行操作的时候，需要经过下面的几个步骤：</p>
<p>引入 API 模块；<br>与数据库建立连接；<br>执行 SQL 语句；<br>关闭数据库连接。<br>如何使用 mysql-connector<br>使用 Python 对数据库进行访问需要基于 DB API 规范，这里有不少库供我们选择，比如 MySQLdb、mysqlclient、PyMySQL、peewee 和 SQLAIchemy 等。今天我讲解的是 mysql-connector，它是 MySQL 官方提供的驱动器，用来给后端语言，比如 Python 提供连接。</p>
<p>下面我们看下如何用 Python 使用 mysql-connector，以完成数据库的连接和使用。</p>
<p>首先安装 mysql-connector。在使用前，你需要先使用下面这句命令进行安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install mysql-connector</span><br></pre></td></tr></table></figure>
<p>在安装之后，你可以创建数据库连接，然后查看下数据库的版本号，来验证下数据库是否连接成功。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line">import mysql.connector</span><br><span class="line"># 打开数据库连接</span><br><span class="line">db = mysql.connector.connect(</span><br><span class="line">       host=&quot;localhost&quot;,</span><br><span class="line">       user=&quot;root&quot;,</span><br><span class="line">       passwd=&quot;XXX&quot;, # 写上你的数据库密码</span><br><span class="line">       database=&apos;wucai&apos;, </span><br><span class="line">       auth_plugin=&apos;mysql_native_password&apos;</span><br><span class="line">)</span><br><span class="line"># 获取操作游标 </span><br><span class="line">cursor = db.cursor()</span><br><span class="line"># 执行 SQL 语句</span><br><span class="line">cursor.execute(&quot;SELECT VERSION()&quot;)</span><br><span class="line"># 获取一条数据</span><br><span class="line">data = cursor.fetchone()</span><br><span class="line">print(&quot;MySQL 版本: %s &quot; % data)</span><br><span class="line"># 关闭游标 &amp; 数据库连接</span><br><span class="line">cursor.close()</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySQL 版本: 5.7.22</span><br></pre></td></tr></table></figure>

<p>上面这段代码中有两个重要的对象你需要了解下，分别是 Connection 和 Cursor。</p>
<p>Connection 就是对数据库的当前连接进行管理，我们可以通过它来进行以下操作：</p>
<ol>
<li><p>通过指定 host、user、passwd 和 port 等参数来创建数据库连接，这些参数分别对应着数据库 IP 地址、用户名、密码和端口号；</p>
</li>
<li><p>使用 db.close() 关闭数据库连接；</p>
</li>
<li><p>使用 db.cursor() 创建游标，操作数据库中的数据；</p>
</li>
<li><p>使用 db.begin() 开启事务；</p>
</li>
<li><p>使用 db.commit() 和 db.rollback()，对事务进行提交以及回滚。<br>当我们通过cursor = db.cursor()创建游标后，就可以通过面向过程的编程方式对数据库中的数据进行操作：</p>
</li>
<li><p>使用cursor.execute(query_sql)，执行数据库查询；</p>
</li>
<li><p>使用cursor.fetchone()，读取数据集中的一条数据；</p>
</li>
<li><p>使用cursor.fetchall()，取出数据集中的所有行，返回一个元组 tuples 类型；</p>
</li>
<li><p>使用cursor.fetchmany(n)，取出数据集中的多条数据，同样返回一个元组 tuples；</p>
</li>
<li><p>使用cursor.rowcount，返回查询结果集中的行数。如果没有查询到数据或者还没有查询，则结果为 -1，否则会返回查询得到的数据行数；</p>
</li>
<li><p>使用cursor.close()，关闭游标。</p>
<h3 id="对数据表进行增删改查"><a href="#对数据表进行增删改查" class="headerlink" title="对数据表进行增删改查"></a>对数据表进行增删改查</h3><p>了解了 Connection 和 Cursor 的使用方式之后，我们来看下如何来对 heros 数据表进行 CRUD 的操作，即增加、读取、更新和删除。</p>
</li>
</ol>
<p>首先是增加数据。</p>
<p>假设我们想在 player 表中增加一名新球员，姓名为“约翰·科林斯”，球队 ID 为 1003（即亚特兰大老鹰），身高为 2.08m。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 插入新球员</span><br><span class="line">sql = &quot;INSERT INTO player (team_id, player_name, height) VALUES (%s, %s, %s)&quot;</span><br><span class="line">val = (1003, &quot; 约翰 - 科林斯 &quot;, 2.08)</span><br><span class="line">cursor.execute(sql, val)</span><br><span class="line">db.commit()</span><br><span class="line">print(cursor.rowcount, &quot; 记录插入成功。&quot;)</span><br></pre></td></tr></table></figure>
<p>我们使用 cursor.execute 来执行相应的 SQL 语句，val 为 SQL 语句中的参数，SQL 执行后使用 db.commit() 进行提交。需要说明的是，我们在使用 SQL 语句的时候，可以向 SQL 语句传递参数，这时 SQL 语句里要统一用（%s）进行占位，否则就会报错。不论插入的数值为整数类型，还是浮点类型，都需要统一用（%s）进行占位。</p>
<p>另外在用游标进行 SQL 操作之后，还需要使用 db.commit() 进行提交，否则数据不会被插入。</p>
<p>然后是读取数据。我们来看下数据是否被插入成功，这里我们查询下身高大于等于 2.08m 的球员都有哪些，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查询身高大于等于 2.08 的球员</span><br><span class="line">sql = &apos;SELECT player_id, player_name, height FROM player WHERE height&gt;=2.08&apos;</span><br><span class="line">cursor.execute(sql)</span><br><span class="line">data = cursor.fetchall()</span><br><span class="line">for each_player in data:</span><br><span class="line">  print(each_player)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(10003, &apos;安德烈 - 德拉蒙德&apos;, 2.11)</span><br><span class="line">(10004, &apos;索恩 - 马克&apos;, 2.16)</span><br><span class="line">(10009, &apos;扎扎 - 帕楚里亚&apos;, 2.11)</span><br><span class="line">(10010, &apos;乔恩 - 洛伊尔&apos;, 2.08)</span><br><span class="line">(10011, &apos;布雷克 - 格里芬&apos;, 2.08)</span><br><span class="line">(10015, &apos;亨利 - 埃伦森&apos;, 2.11)</span><br><span class="line">(10023, &apos;多曼塔斯 - 萨博尼斯&apos;, 2.11)</span><br><span class="line">(10024, &apos;迈尔斯 - 特纳&apos;, 2.11)</span><br><span class="line">(10032, &apos;TJ- 利夫&apos;, 2.08)</span><br><span class="line">(10033, &apos;凯尔 - 奥奎因&apos;, 2.08)</span><br><span class="line">(10037, &apos;伊凯·阿尼博古&apos;, 2.08)</span><br><span class="line">(10038, &apos;约翰 - 科林斯&apos;, 2.08)</span><br></pre></td></tr></table></figure>
<p>你能看到球员约翰·科林斯被正确插入。</p>
<p>那么如何修改数据呢？</p>
<p>假如我想修改刚才插入的球员约翰·科林斯的身高，将身高修改成 2.09，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 修改球员约翰 - 科林斯</span><br><span class="line">sql = &apos;UPDATE player SET height = %s WHERE player_name = %s&apos;</span><br><span class="line">val = (2.09, &quot; 约翰 - 科林斯 &quot;)</span><br><span class="line">cursor.execute(sql, val)</span><br><span class="line">db.commit()</span><br><span class="line">print(cursor.rowcount, &quot; 记录被修改。&quot;)</span><br></pre></td></tr></table></figure>
<p>最后我们看下如何删除约翰·科林斯这个球员的数据，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sql = &apos;DELETE FROM player WHERE player_name = %s&apos;</span><br><span class="line">val = (&quot; 约翰 - 科林斯 &quot;,)</span><br><span class="line">cursor.execute(sql, val)</span><br><span class="line">db.commit()</span><br><span class="line">print(cursor.rowcount, &quot; 记录删除成功。&quot;)</span><br></pre></td></tr></table></figure>
<p>最后都执行完了，我们来关闭游标和数据库的连接，使用以下代码即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cursor.close()</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>
<p>针对上面的操作过程，你可以模拟下数据的 CRUD 操作，但有几点你需要注意。</p>
<ol>
<li><p>打开数据库连接以后，如果不再使用，则需要关闭数据库连接，以免造成资源浪费。</p>
</li>
<li><p>在对数据进行增加、删除和修改的时候，可能会出现异常，这时就需要用try…except捕获异常信息。比如针对插入球员约翰·科林斯这个操作，你可以写成下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import traceback</span><br><span class="line">try:</span><br><span class="line">  sql = &quot;INSERT INTO player (team_id, player_name, height) VALUES (%s, %s, %s)&quot;</span><br><span class="line">  val = (1003, &quot; 约翰 - 科林斯 &quot;, 2.08)</span><br><span class="line">  cursor.execute(sql, val)</span><br><span class="line">  db.commit()</span><br><span class="line">  print(cursor.rowcount, &quot; 记录插入成功。&quot;)</span><br><span class="line">except Exception as e:</span><br><span class="line">  # 打印异常信息</span><br><span class="line">  traceback.print_exc()</span><br><span class="line">  # 回滚  </span><br><span class="line">  db.rollback()</span><br><span class="line">finally:</span><br><span class="line">  # 关闭数据库连接</span><br><span class="line">  db.close()</span><br></pre></td></tr></table></figure>
<p>运行结果告诉我们记录插入成功。</p>
</li>
<li><p>如果你在使用 mysql-connector 连接的时候，系统报的错误为authentication plugin caching_sha2，这时你需要下载最新的版本更新来解决，点击这里进行更新。</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我今天讲解了如何使用 Python 来操作 MySQL，这里我们使用的是官方提供的 mysql-connector，当然除了它之外，还有很多库可以进行选择。</p>
<p>在使用基于 DB API 规范的协议时，重点需要掌握 Connection 和 Cursor 这两个对象，Connection 就是对数据库的连接进行管理，而 Cursor 是对数据库的游标进行管理，通过它们，我们可以执行具体的 SQL 语句，以及处理复杂的数据。</p>
<p>用 Python 操作 MySQL，还有很多种姿势，mysql-connector 只是其中一种，实际上还有另外一种方式，就是采用 ORM 框架。ORM 的英文是 Object Relational Mapping，也就是采用对象关系映射的模式，使用这种模式可以将数据库中各种数据表之间的关系映射到程序中的对象。这种模式可以屏蔽底层的数据库的细节，不需要我们与复杂的 SQL 语句打交道，直接采用操作对象的形式操作就可以。</p>
<p>不过如果应用数据实体少，其实没有必要使用 ORM 框架，针对少量对象的管理，自己实现起来也很简单，比如本篇文章中我讲到的采用官方提供的 mysql-connector 驱动的方式来实现 CRUD。引入一个框架的学习成本很高，代码膨胀也很厉害，所以如果是相对简单的操作，完全可以自己动手来实现。<br>使用 Python 对数据库进行操作，关键在于实战，所以这里我出一个练习题。请你使用 Python 对 heros 表中最大生命值大于 6000 的英雄进行查询，并且输出相应的属性值。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/27/16%E4%B8%A8%E6%B8%B8%E6%A0%87%EF%BC%9A%E5%BD%93%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E9%80%90%E6%9D%A1%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E6%97%B6%EF%BC%8C%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/27/16%E4%B8%A8%E6%B8%B8%E6%A0%87%EF%BC%9A%E5%BD%93%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E9%80%90%E6%9D%A1%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E6%97%B6%EF%BC%8C%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F/" itemprop="url">15丨初识事务隔离：隔离的级别有哪些，它们都解决了哪些异常问题？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-27T20:07:01+08:00">
                2020-03-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/" itemprop="url" rel="index">
                    <span itemprop="name">SQL必知必会</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/27/16%E4%B8%A8%E6%B8%B8%E6%A0%87%EF%BC%9A%E5%BD%93%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E9%80%90%E6%9D%A1%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E6%97%B6%EF%BC%8C%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/03/27/16%E4%B8%A8%E6%B8%B8%E6%A0%87%EF%BC%9A%E5%BD%93%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E9%80%90%E6%9D%A1%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E6%97%B6%EF%BC%8C%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们在编写 SQL 语句的时候通常是面向集合进行思考，这种思考方式更让我们关注结果集的特征，而不是具体的实现过程。面向集合的思考方式与面向过程的思考方式各有特点，我们该如何理解它们呢？</p>
<p>我们用下面这张图开启今天的学习。这张图中一共有 9 个图形，每个图形有不同的特征，包括形状、纹理、颜色和个数等。<br>当我们看到这张图时，有时候会不由自主地按照某个属性进行分类，比如说按照红色分类，那么 1、4、9 就是一类。这实际上就是属于同一个条件下的查询结果集。或者我们也可以按照物体的个数来划分，比如都有 3 个物体的，那么对应的就是 2、5、6、8，这就是对应着“都包括 3 个物体”的查询结果集。</p>
<p>你能看出来集合思维更像是从整体的角度来考虑，然后把整个数据集按照不同的属性进行划分，形成不同的子集合。面向集合的思考方式，让我们关注“获取什么”，而不是“如何获取”，这也可以说是 SQL 与传统编程最大的区别之一，因为 SQL 本身是以关系模型和集合论为基础的。</p>
<p>然而也有一些情况，我们不需要对查询结果集中的所有数据行都采用相同的处理方式，需要每次处理一行或者一部分行，这时就需要面向过程的编程方法了。游标就是这种编程方式的体现。如果你之前已经有了一些面向过程的编程经验，那么对于游标的理解也会比较容易。</p>
<p>关于游标，你需要掌握以下几个方面的内容：</p>
<ol>
<li>什么是游标？我们为什么要使用游标？</li>
<li>如何使用游标？使用游标的常用步骤都包括哪些？</li>
<li>如何使用游标来解决一些常见的问题？<h3 id="什么是游标？"><a href="#什么是游标？" class="headerlink" title="什么是游标？"></a>什么是游标？</h3>在数据库中，游标是个重要的概念，它提供了一种灵活的操作方式，可以让我们从数据结果集中每次提取一条数据记录进行操作。游标让 SQL 这种面向集合的语言有了面向过程开发的能力。可以说，游标是面向过程的编程方式，这与面向集合的编程方式有所不同。</li>
</ol>
<p>在 SQL 中，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标充当了指针的作用，我们可以通过操作游标来对数据行进行操作。</p>
<p>比如我们查询了 heros 数据表中最大生命值大于 8500 的英雄都有哪些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, name, hp_max FROM heros WHERE hp_max &gt; 8500</span><br></pre></td></tr></table></figure>

<p>这里我们就可以通过游标来操作数据行，如图所示此时游标所在的行是“白起”的记录，我们也可以在结果集上滚动游标，指向结果集中的任意一行。</p>
<h3 id="如何使用游标？"><a href="#如何使用游标？" class="headerlink" title="如何使用游标？"></a>如何使用游标？</h3><p>游标实际上是一种控制数据集的更加灵活的处理方式。</p>
<p>如果我们想要使用游标，一般需要经历五个步骤。不同 DBMS 中，使用游标的语法可能略有不同。</p>
<p>第一步，定义游标。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE cursor_name CURSOR FOR select_statement</span><br></pre></td></tr></table></figure>
<p>这个语法适用于 MySQL，SQL Server，DB2 和 MariaDB。如果是用 Oracle 或者 PostgreSQL，需要写成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE cursor_name CURSOR IS select_statement</span><br></pre></td></tr></table></figure>
<p>要使用 SELECT 语句来获取数据结果集，而此时还没有开始遍历数据，这里 select_statement 代表的是 SELECT 语句。</p>
<p>下面我用 MySQL 举例讲解游标的使用，如果你使用的是其他的 RDBMS，具体的游标语法可能略有差异。我们定义一个能够存储 heros 数据表中的最大生命值的游标，可以写为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DECLARE cur_hero CURSOR FOR </span><br><span class="line">	SELECT hp_max FROM heros;</span><br></pre></td></tr></table></figure>
<p>第二步，打开游标。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPEN cursor_name</span><br></pre></td></tr></table></figure>
<p>当我们定义好游标之后，如果想要使用游标，必须先打开游标。打开游标的时候 SELECT 语句的查询结果集就会送到游标工作区。</p>
<p>第三步，从游标中取得数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FETCH cursor_name INTO var_name ...</span><br></pre></td></tr></table></figure>
<p>这句的作用是使用 cursor_name 这个游标来读取当前行，并且将数据保存到 var_name 这个变量中，游标指针指到下一行。如果游标读取的数据行有多个列名，则在 INTO 关键字后面赋值给多个变量名即可。</p>
<p>第四步，关闭游标。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLOSE cursor_name</span><br></pre></td></tr></table></figure>
<p>有 OPEN 就会有 CLOSE，也就是打开和关闭游标。当我们使用完游标后需要关闭掉该游标。关闭游标之后，我们就不能再检索查询结果中的数据行，如果需要检索只能再次打开游标。</p>
<p>最后一步，释放游标。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEALLOCATE PREPARE</span><br></pre></td></tr></table></figure>

<p>有 DECLARE 就需要有 DEALLOCATE，DEALLOCATE 的作用是释放游标。我们一定要养成释放游标的习惯，否则游标会一直存在于内存中，直到进程结束后才会自动释放。当你不需要使用游标的时候，释放游标可以减少资源浪费。</p>
<p>上面就是 5 个常用的游标步骤。我来举一个简单的例子，假设我想用游标来扫描 heros 数据表中的数据行，然后累计最大生命值，那么该怎么做呢？</p>
<p>我先创建一个存储过程 calc_hp_max，然后在存储过程中定义游标 cur_hero，使用 FETCH 获取每一行的具体数值，然后赋值给变量 hp，再用变量 hp_sum 做累加求和，最后再输出 hp_sum，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE `calc_hp_max`()</span><br><span class="line">BEGIN</span><br><span class="line">       -- 创建接收游标的变量</span><br><span class="line">       DECLARE hp INT;  </span><br><span class="line">       -- 创建总数变量 </span><br><span class="line">       DECLARE hp_sum INT DEFAULT 0;</span><br><span class="line">       -- 创建结束标志变量  </span><br><span class="line">       DECLARE done INT DEFAULT false;</span><br><span class="line">       -- 定义游标     </span><br><span class="line">       DECLARE cur_hero CURSOR FOR SELECT hp_max FROM heros;</span><br><span class="line">       </span><br><span class="line">       OPEN cur_hero;</span><br><span class="line">       read_loop:LOOP </span><br><span class="line">       FETCH cur_hero INTO hp;</span><br><span class="line">       SET hp_sum = hp_sum + hp;</span><br><span class="line">       END LOOP;</span><br><span class="line">       CLOSE cur_hero;</span><br><span class="line">       SELECT hp_sum;</span><br><span class="line">       DEALLOCATE PREPARE cur_hero;</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<p>你会发现执行call calc_hp_max()这一句的时候系统会提示 1329 错误，也就是在 LOOP 中当游标没有取到数据时会报的错误。</p>
<p>当游标溢出时（也就是当游标指向到最后一行数据后继续执行会报的错误），我们可以定义一个 continue 的事件，指定这个事件发生时修改变量 done 的值，以此来判断游标是否已经溢出，即：</p>
<p>DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = true;<br>同时在循环中我们需要加上对 done 的判断，如果游标的循环已经结束，就需要跳出 read_loop 循环，完善的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE `calc_hp_max`()</span><br><span class="line">BEGIN</span><br><span class="line">       -- 创建接收游标的变量</span><br><span class="line">       DECLARE hp INT;  </span><br><span class="line"> </span><br><span class="line">       -- 创建总数变量 </span><br><span class="line">       DECLARE hp_sum INT DEFAULT 0;</span><br><span class="line">       -- 创建结束标志变量  </span><br><span class="line">     DECLARE done INT DEFAULT false;</span><br><span class="line">       -- 定义游标     </span><br><span class="line">       DECLARE cur_hero CURSOR FOR SELECT hp_max FROM heros;</span><br><span class="line">       -- 指定游标循环结束时的返回值  </span><br><span class="line">     DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = true;  </span><br><span class="line">       </span><br><span class="line">       OPEN cur_hero;</span><br><span class="line">       read_loop:LOOP </span><br><span class="line">       FETCH cur_hero INTO hp;</span><br><span class="line">       -- 判断游标的循环是否结束  </span><br><span class="line">       IF done THEN  </span><br><span class="line">                     LEAVE read_loop;</span><br><span class="line">       END IF; </span><br><span class="line">              </span><br><span class="line">       SET hp_sum = hp_sum + hp;</span><br><span class="line">       END LOOP;</span><br><span class="line">       CLOSE cur_hero;</span><br><span class="line">       SELECT hp_sum;</span><br><span class="line">       DEALLOCATE PREPARE cur_hero;</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<p>运行结果（1 行数据）：</p>
<p>在游标中的循环中，除了使用 LOOP 循环以外，你还可以使用 REPEAT… UNTIL…以及 WHILE 循环。它们同样需要设置 CONTINUE 事件来处理游标溢出的情况。</p>
<p>所以你能看出，使用游标可以让我们对 SELECT 结果集中的每一行数据进行相同或者不同的操作，从而很精细化地管理结果集中的每一条数据。</p>
<h3 id="使用游标来解决一些常见的问题"><a href="#使用游标来解决一些常见的问题" class="headerlink" title="使用游标来解决一些常见的问题"></a>使用游标来解决一些常见的问题</h3><p>我刚才讲了一个简单的使用案例，实际上如果想要统计 hp_sum，完全可以通过 SQL 语句来完成，比如：</p>
<p>SELECT SUM(hp_max) FROM heros<br>运行结果（1 行数据）：</p>
<p>那么游标都有什么用呢？</p>
<p>当你需要处理一些复杂的数据行计算的时候，游标就会起到作用了。我举个例子，还是针对 heros 数据表，假设我们想要对英雄的物攻成长（对应 attack_growth）进行升级，在新版本中大范围提升英雄的物攻成长数值，但是针对不同的英雄情况，提升的幅度也不同，具体提升的方式如下。</p>
<p>如果这个英雄原有的物攻成长小于 5，那么将在原有基础上提升 7%-10%。如果物攻成长的提升空间（即最高物攻 attack_max- 初始物攻 attack_start）大于 200，那么在原有的基础上提升 10%；如果物攻成长的提升空间在 150 到 200 之间，则提升 8%；如果物攻成长的提升空间不足 150，则提升 7%。</p>
<p>如果原有英雄的物攻成长在 5—10 之间，那么将在原有基础上提升 5%。</p>
<p>如果原有英雄的物攻成长大于 10，则保持不变。</p>
<p>以上所有的更新后的物攻成长数值，都需要保留小数点后 3 位。</p>
<p>你能看到上面这个计算的情况相对复杂，实际工作中你可能会遇到比这个更加复杂的情况，这时你可以采用面向过程的思考方式来完成这种任务，也就是说先取出每行的数值，然后针对数值的不同情况采取不同的计算方式。</p>
<p>针对上面这个情况，你自己可以用游标来完成转换，具体的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE `alter_attack_growth`()</span><br><span class="line">BEGIN</span><br><span class="line">       -- 创建接收游标的变量</span><br><span class="line">       DECLARE temp_id INT;  </span><br><span class="line">       DECLARE temp_growth, temp_max, temp_start, temp_diff FLOAT;  </span><br><span class="line"> </span><br><span class="line">       -- 创建结束标志变量  </span><br><span class="line">       DECLARE done INT DEFAULT false;</span><br><span class="line">       -- 定义游标     </span><br><span class="line">       DECLARE cur_hero CURSOR FOR SELECT id, attack_growth, attack_max, attack_start FROM heros;</span><br><span class="line">       -- 指定游标循环结束时的返回值  </span><br><span class="line">       DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = true;  </span><br><span class="line">       </span><br><span class="line">       OPEN cur_hero;  </span><br><span class="line">       FETCH cur_hero INTO temp_id, temp_growth, temp_max, temp_start;</span><br><span class="line">       REPEAT</span><br><span class="line">                     IF NOT done THEN</span><br><span class="line">                            SET temp_diff = temp_max - temp_start;</span><br><span class="line">                            IF temp_growth &lt; 5 THEN</span><br><span class="line">                                   IF temp_diff &gt; 200 THEN</span><br><span class="line">                                          SET temp_growth = temp_growth * 1.1;</span><br><span class="line">                                   ELSEIF temp_diff &gt;= 150 AND temp_diff &lt;=200 THEN</span><br><span class="line">                                          SET temp_growth = temp_growth * 1.08;</span><br><span class="line">                                   ELSEIF temp_diff &lt; 150 THEN</span><br><span class="line">                                          SET temp_growth = temp_growth * 1.07;</span><br><span class="line">                                   END IF;                       </span><br><span class="line">                            ELSEIF temp_growth &gt;=5 AND temp_growth &lt;=10 THEN</span><br><span class="line">                                   SET temp_growth = temp_growth * 1.05;</span><br><span class="line">                            END IF;</span><br><span class="line">                            UPDATE heros SET attack_growth = ROUND(temp_growth,3) WHERE id = temp_id;</span><br><span class="line">                     END IF;</span><br><span class="line">       FETCH cur_hero INTO temp_id, temp_growth, temp_max, temp_start;</span><br><span class="line">       UNTIL done = true END REPEAT;</span><br><span class="line">       </span><br><span class="line">       CLOSE cur_hero;</span><br><span class="line">       DEALLOCATE PREPARE cur_hero;</span><br><span class="line">END</span><br><span class="line">这里我创建了 alter_attack_growth 这个存储过程，使用了 REPEAT…UNTIL…的循环方式，针对不同的情况计算了新的物攻成长 temp_growth，然后对原有的 attack_growth 进行了更新，最后调用 call alter_attack_growth(); 执行存储过程。</span><br><span class="line"></span><br><span class="line">有一点需要注意的是，我们在对数据表进行更新前，需要备份之前的表，我们可以将备份后的表命名为 heros_copy1。更新完 heros 数据表之后，你可以看下两张表在 attack_growth 字段上的对比，我们使用 SQL 进行查询：</span><br></pre></td></tr></table></figure>
<p>SELECT heros.id, heros.attack_growth, heros_copy1.attack_growth FROM heros JOIN heros_copy1 WHERE heros.id = heros_copy1.id</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">运行结果（69 条记录）：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">通过前后两张表的 attack_growth 对比你也能看出来，存储过程通过游标对不同的数据行进行了更新。</span><br><span class="line"></span><br><span class="line">需要说明的是，以上代码适用于 MySQL，如果在 SQL Server 或 Oracle 中，使用方式会有些差别。</span><br><span class="line"></span><br><span class="line">### 总结</span><br><span class="line">今天我们讲解了如何在 SQL 中使用游标，游标实际上是面向过程的思维方式，与面向集合的思维方式不同的地方在于，游标更加关注“如何执行”。我们可以通过游标更加精细、灵活地查询和管理想要的数据行。</span><br><span class="line"></span><br><span class="line">有的时候，我们需要找特定数据，用 SQL 查询写起来会比较困难，比如两表或多表之间的嵌套循环查找，如果用 JOIN 会非常消耗资源，效率也可能不高，而用游标则会比较高效。</span><br><span class="line"></span><br><span class="line">虽然在处理某些复杂的数据情况下，使用游标可以更灵活，但同时也会带来一些性能问题，比如在使用游标的过程中，会对数据行进行加锁，这样在业务并发量大的时候，不仅会影响业务之间的效率，还会消耗系统资源，造成内存不足，这是因为游标是在内存中进行的处理。如果有游标的替代方案，我们可以采用替代方案。</span><br><span class="line">我们今天讲解了游标，你能用自己的语言介绍下游标的作用吗？另外，我们之前提到过，SQL 本身是一门结构化查询语言，但我们也可以在 SQL 的基础上进行面向过程的开发，完成较为复杂的功能，你能说一下面向过程和面向集合这两种编程方式的区别吗？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```python</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/27/15%E4%B8%A8%E5%88%9D%E8%AF%86%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%EF%BC%9A%E9%9A%94%E7%A6%BB%E7%9A%84%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%AE%83%E4%BB%AC%E9%83%BD%E8%A7%A3%E5%86%B3%E4%BA%86%E5%93%AA%E4%BA%9B%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/27/15%E4%B8%A8%E5%88%9D%E8%AF%86%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%EF%BC%9A%E9%9A%94%E7%A6%BB%E7%9A%84%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%AE%83%E4%BB%AC%E9%83%BD%E8%A7%A3%E5%86%B3%E4%BA%86%E5%93%AA%E4%BA%9B%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%EF%BC%9F/" itemprop="url">15丨初识事务隔离：隔离的级别有哪些，它们都解决了哪些异常问题？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-27T19:39:01+08:00">
                2020-03-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/" itemprop="url" rel="index">
                    <span itemprop="name">SQL必知必会</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/27/15%E4%B8%A8%E5%88%9D%E8%AF%86%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%EF%BC%9A%E9%9A%94%E7%A6%BB%E7%9A%84%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%AE%83%E4%BB%AC%E9%83%BD%E8%A7%A3%E5%86%B3%E4%BA%86%E5%93%AA%E4%BA%9B%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%EF%BC%9F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/03/27/15%E4%B8%A8%E5%88%9D%E8%AF%86%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%EF%BC%9A%E9%9A%94%E7%A6%BB%E7%9A%84%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%AE%83%E4%BB%AC%E9%83%BD%E8%A7%A3%E5%86%B3%E4%BA%86%E5%93%AA%E4%BA%9B%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%EF%BC%9F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上一篇文章中，我们讲到了事务的四大特性 ACID，分别是原子性、一致性、隔离性和持久性，其中隔离性是事务的基本特性之一，它可以防止数据库在并发处理时出现数据不一致的情况。最严格的情况下，我们可以采用串行化的方式来执行每一个事务，这就意味着事务之间是相互独立的，不存在并发的情况。然而在实际生产环境下，考虑到随着用户量的增多，会存在大规模并发访问的情况，这就要求数据库有更高的吞吐能力，这个时候串行化的方式就无法满足数据库高并发访问的需求，我们还需要降低数据库的隔离标准，来换取事务之间的并发能力。</p>
<p>有时候我们需要牺牲一定的正确性来换取效率的提升，也就是说，我们需要通过设置不同的隔离等级，以便在正确性和效率之间进行平衡。同时，随着 RDBMS 种类和应用场景的增多，数据库的设计者需要统一对数据库隔离级别进行定义，说明这些隔离标准都解决了哪些问题。</p>
<p>我们今天主要讲解事务的异常以及隔离级别都有哪些，如果你已经对它们有所了解，可以跳过本次章节，当然你也可以通过今天的课程快速复习一遍：</p>
<ol>
<li>事务并发处理可能存在的三种异常有哪些？什么是脏读、不可重复读和幻读？</li>
<li>针对可能存在的异常情况，四种事务隔离的级别分别是什么？</li>
<li>如何使用 MySQL 客户端来模拟脏读、不可重复读和幻读？<h3 id="事务并发处理可能存在的异常都有哪些？"><a href="#事务并发处理可能存在的异常都有哪些？" class="headerlink" title="事务并发处理可能存在的异常都有哪些？"></a>事务并发处理可能存在的异常都有哪些？</h3>在了解数据库隔离级别之前，我们需要了解设定事务的隔离级别都要解决哪些可能存在的问题，也就是事务并发处理时会存在哪些异常情况。实际上，SQL-92 标准中已经对 3 种异常情况进行了定义，这些异常情况级别分别为脏读（Dirty Read）、不可重复读（Nnrepeatable Read）和幻读（Phantom Read）。</li>
</ol>
<p>脏读、不可重复读和幻读都代表了什么，我用一个例子来给你讲解下。比如说我们有个英雄表 heros_temp，如下所示：</p>
<p>这张英雄表，我们会记录很多英雄的姓名，假设我们不对事务进行隔离操作，那么数据库在进行事务的并发处理时会出现怎样的情况？</p>
<p>第一天，小张访问数据库，正在进行事务操作，往里面写入一个新的英雄“吕布”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; BEGIN;</span><br><span class="line">SQL&gt; INSERT INTO heros_temp values(4, &apos;吕布&apos;);</span><br></pre></td></tr></table></figure>
<p>当小张还没有提交该事务的时候，小李又对数据表进行了访问，他想看下这张英雄表里都有哪些英雄：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; SELECT * FROM heros_temp;</span><br></pre></td></tr></table></figure>
<p>这时，小李看到的结果如下：</p>
<p>你有没有发现什么异常？这个时候小张还没有提交事务，但是小李却读到了小张还没有提交的数据，这种现象我们称之为“脏读”。</p>
<p>那么什么是不可重复读呢？</p>
<p>第二天，小张想查看 id=1 的英雄是谁，于是他进行了 SQL 查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; SELECT name FROM heros_temp WHERE id = 1;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p>然而此时，小李开始了一个事务操作，他对 id=1 的英雄姓名进行了修改，把原来的“张飞”改成了“张翼德”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; BEGIN;</span><br><span class="line">SQL&gt; UPDATE heros_temp SET name = &apos;张翼德&apos; WHERE id = 1;</span><br></pre></td></tr></table></figure>
<p>然后小张再一次进行查询，同样也是查看 id=1 的英雄是谁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; SELECT name FROM heros_temp WHERE id = 1;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p>这个时候你会发现，两次查询的结果并不一样。小张会想这是怎么回事呢？他明明刚执行了一次查询，马上又进行了一次查询，结果两次的查询结果不同。实际上小张遇到的情况我们称之为“不可重复读”，也就是同一条记录，两次读取的结果不同。</p>
<p>什么是幻读？</p>
<p>第三天，小张想要看下数据表里都有哪些英雄，他开始执行下面这条语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; SELECT * FROM heros_temp;</span><br></pre></td></tr></table></figure>
<p>这时当小张执行完之后，小李又开始了一个事务，往数据库里插入一个新的英雄“吕布”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; BEGIN;</span><br><span class="line">SQL&gt; INSERT INTO heros_temp values(4, &apos;吕布&apos;);</span><br></pre></td></tr></table></figure>
<p>不巧的是，小张这时忘记了英雄都有哪些，又重新执行了一遍查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; SELECT * FROM heros_temp;</span><br></pre></td></tr></table></figure>
<p>他发现这一次查询多了一个英雄，原来只有 3 个，现在变成了 4 个。这种异常情况我们称之为“幻读”。</p>
<p>我来总结下这三种异常情况的特点：</p>
<ol>
<li>脏读：读到了其他事务还没有提交的数据。</li>
<li>不可重复读：对某数据进行读取，发现两次读取的结果不同，也就是说没有读到相同的内容。这是因为有其他事务对这个数据同时进行了修改或删除。</li>
<li>幻读：事务 A 根据条件查询得到了 N 条数据，但此时事务 B 更改或者增加了 M 条符合事务 A 查询条件的数据，这样当事务 A 再次进行查询的时候发现会有 N+M 条数据，产生了幻读。<h3 id="事务隔离的级别有哪些？"><a href="#事务隔离的级别有哪些？" class="headerlink" title="事务隔离的级别有哪些？"></a>事务隔离的级别有哪些？</h3>脏读、不可重复读和幻读这三种异常情况，是在 SQL-92 标准中定义的，同时 SQL-92 标准还定义了 4 种隔离级别来解决这些异常情况。</li>
</ol>
<p>解决异常数量从少到多的顺序（比如读未提交可能存在 3 种异常，可串行化则不会存在这些异常）决定了隔离级别的高低，这四种隔离级别从低到高分别是：读未提交（READ UNCOMMITTED ）、读已提交（READ COMMITTED）、可重复读（REPEATABLE READ）和可串行化（SERIALIZABLE）。这些隔离级别能解决的异常情况如下表所示：</p>
<p>你能看到可串行化能避免所有的异常情况，而读未提交则允许异常情况发生。</p>
<p>关于这四种级别，我来简单讲解下。</p>
<p>读未提交，也就是允许读到未提交的数据，这种情况下查询是不会使用锁的，可能会产生脏读、不可重复读、幻读等情况。</p>
<p>读已提交就是只能读到已经提交的内容，可以避免脏读的产生，属于 RDBMS 中常见的默认隔离级别（比如说 Oracle 和 SQL Server），但如果想要避免不可重复读或者幻读，就需要我们在 SQL 查询的时候编写带加锁的 SQL 语句（我会在进阶篇里讲加锁）。</p>
<p>可重复读，保证一个事务在相同查询条件下两次查询得到的数据结果是一致的，可以避免不可重复读和脏读，但无法避免幻读。MySQL 默认的隔离级别就是可重复读。</p>
<p>可串行化，将事务进行串行化，也就是在一个队列中按照顺序执行，可串行化是最高级别的隔离等级，可以解决事务读取中所有可能出现的异常情况，但是它牺牲了系统的并发性。</p>
<h3 id="使用-MySQL-客户端来模拟三种异常"><a href="#使用-MySQL-客户端来模拟三种异常" class="headerlink" title="使用 MySQL 客户端来模拟三种异常"></a>使用 MySQL 客户端来模拟三种异常</h3><p>我在讲解这三种异常的时候举了一个英雄数据表查询的例子，你还可以自己写 SQL 来模拟一下这三种异常。</p>
<p>首先我们需要一个英雄数据表 heros_temp，具体表结构和数据，你可以从GitHub上下载 heros_temp.sql 文件。</p>
<p>你也可以执行下面的 SQL 文件，来完成 heros_temp 数据表的创建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-- ----------------------------</span><br><span class="line">-- Table structure for heros_temp</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS `heros_temp`;</span><br><span class="line">CREATE TABLE `heros_temp`  (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE</span><br><span class="line">) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;</span><br><span class="line"> </span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Records of heros_temp</span><br><span class="line">-- ----------------------------</span><br><span class="line">INSERT INTO `heros_temp` VALUES (1, &apos;张飞&apos;);</span><br><span class="line">INSERT INTO `heros_temp` VALUES (2, &apos;关羽&apos;);</span><br><span class="line">INSERT INTO `heros_temp` VALUES (3, &apos;刘备&apos;);</span><br></pre></td></tr></table></figure>
<p>模拟的时候我们需要开两个 MySQL 客户端，分别是客户端 1 和客户端 2。</p>
<p>在客户端 1 中，我们先来查看下当前会话的隔离级别，使用命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &apos;transaction_isolation&apos;;</span><br></pre></td></tr></table></figure>
<p>然后你能看到当前的隔离级别是 REPEATABLE-READ，也就是可重复读。</p>
<p>现在我们把隔离级别降到最低，设置为 READ UNCOMMITTED（读未提交）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br></pre></td></tr></table></figure>
<p>然后再查看下当前会话（SESSION）下的隔离级别，结果如下：</p>
<p>因为 MySQL 默认是事务自动提交，这里我们还需要将 autocommit 参数设置为 0，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET autocommit = 0;</span><br></pre></td></tr></table></figure>
<p>然后我们再来查看 SESSION 中的 autocommit 取值，结果如下：</p>
<p>接着我们以同样的操作启动客户端 2，也就是将隔离级别设置为 READ UNCOMMITTED（读未提交），autocommit 设置为 0。</p>
<p>模拟“脏读”<br>我们在客户端 2 中开启一个事务，在 heros_temp 表中写入一个新的英雄“吕布”，注意这个时候不要提交。</p>
<p>然后我们在客户端 1 中，查看当前的英雄表：</p>
<p>你能发现客户端 1 中读取了客户端 2 未提交的新英雄“吕布”，实际上客户端 2 可能马上回滚，从而造成了“脏读”。</p>
<h3 id="模拟“不可重复读”"><a href="#模拟“不可重复读”" class="headerlink" title="模拟“不可重复读”"></a>模拟“不可重复读”</h3><p>我们用客户端 1 来查看 id=1 的英雄：</p>
<p>然后用客户端 2 对 id=1 的英雄姓名进行修改：</p>
<p>这时用客户端 1 再次进行查询：</p>
<p>你能发现对于客户端 1 来说，同一条查询语句出现了“不可重复读”。</p>
<h3 id="模拟“幻读”"><a href="#模拟“幻读”" class="headerlink" title="模拟“幻读”"></a>模拟“幻读”</h3><p>我们先用客户端 1 查询数据表中的所有英雄：</p>
<p>然后用客户端 2，开始插入新的英雄“吕布”：</p>
<p>这时，我们再用客户端 1 重新进行查看：</p>
<p>你会发现数据表多出一条数据。</p>
<p>如果你是初学者，那么你可以采用 heros_temp 数据表简单模拟一下以上的过程，加深对脏读、不可重复读以及幻读的理解。对应的，你也会更了解不同的隔离级别解决的异常问题。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们今天只是简单讲解了 4 种隔离级别，以及对应的要解决的三种异常问题。我会在优化篇这一模块里继续讲解隔离级别以及锁的使用。</p>
<p>你能看到，标准的价值在于，即使是不同的 RDBMS 都需要达成对异常问题和隔离级别定义的共识。这就意味着一个隔离级别的实现满足了下面的两个条件：</p>
<p>正确性：只要能满足某一个隔离级别，一定能解决这个隔离级别对应的异常问题。<br>与实现无关：实际上 RDBMS 种类很多，这就意味着有多少种 RDBMS，就有多少种锁的实现方式，因此它们实现隔离级别的原理可能不同，然而一个好的标准不应该限制其实现的方式。<br>隔离级别越低，意味着系统吞吐量（并发程度）越大，但同时也意味着出现异常问题的可能性会更大。在实际使用过程中我们往往需要在性能和正确性上进行权衡和取舍，没有完美的解决方案，只有适合与否。</p>
<p>今天的内容到这里就结束了，你能思考一下为什么隔离级别越高，就越影响系统的并发性能吗？以及不可重复读和幻读的区别是什么？</p>
<p>欢迎你在评论区写下你的思考，也欢迎把这篇文章分享给你的朋友或者同事。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/26/14%E4%B8%A8%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8COMMIT%E5%92%8CROLLBACK%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/26/14%E4%B8%A8%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8COMMIT%E5%92%8CROLLBACK%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C%EF%BC%9F/" itemprop="url">14丨什么是事务处理，如何使用COMMIT和ROLLBACK进行操作？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-26T20:39:01+08:00">
                2020-03-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/" itemprop="url" rel="index">
                    <span itemprop="name">SQL必知必会</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/26/14%E4%B8%A8%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8COMMIT%E5%92%8CROLLBACK%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C%EF%BC%9F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/03/26/14%E4%B8%A8%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8COMMIT%E5%92%8CROLLBACK%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C%EF%BC%9F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们知道在 MySQL 5.5 版本之前，默认的存储引擎是 MyISAM，在 5.5 版本之后默认存储引擎是 InnoDB。InnoDB 和 MyISAM 区别之一就是 InnoDB 支持事务，也可以说这是 InnoDB 取代 MyISAM 的重要原因。那么什么是事务呢？事务的英文是 transaction，从英文中你也能看出来它是进行一次处理的基本单元，要么完全执行，要么都不执行。</p>
<p>这么讲，你可能觉得有些抽象，我换一种方式讲。</p>
<p>不知道你是否遇到过这样的情况，你去家门口的小卖铺买东西，已经交了钱，但是老板比较忙接了个电话，忘记你是否交过钱，然后让你重新付款，这时你还要找之前的付款记录证明你已经完成了付款。</p>
<p>实际上如果我们线下的交易也能支持事务（满足事务的特性），就不会出现交了钱却拿不到商品的烦恼了，同样，对于小卖铺的老板来说，也不存在给出了商品但没有收到款的风险。总之，事务保证了一次处理的完整性，也保证了数据库中的数据一致性。它是一种高级的数据处理方式，如果我们在增加、删除、修改的时候某一个环节出了错，它允许我们回滚还原。正是因为这个特点，事务非常适合应用在安全性高的场景里，比如金融行业等。</p>
<p>我们今天就来学习下 SQL 中的事务。今天的课程你将重点掌握以下的内容：</p>
<ol>
<li><p>事务的特性是什么？如何理解它们？</p>
</li>
<li><p>如何对事务进行控制？控制的命令都有哪些？</p>
</li>
<li><p>为什么我们执行 COMMIT、ROLLBACK 这些命令的时候，有时会成功，有时会失败？</p>
<h3 id="事务的特性：ACID"><a href="#事务的特性：ACID" class="headerlink" title="事务的特性：ACID"></a>事务的特性：ACID</h3><p>我刚才提到了事务的特性：要么完全执行，要么都不执行。不过要对事务进行更深一步的理解，还要从事务的 4 个特性说起，这 4 个特性用英文字母来表达就是 ACID。</p>
</li>
<li><p>A，也就是原子性（Atomicity）。原子的概念就是不可分割，你可以把它理解为组成物质的基本单位，也是我们进行数据处理操作的基本单位。</p>
</li>
<li><p>C，就是一致性（Consistency）。一致性指的就是数据库在进行事务操作后，会由原来的一致状态，变成另一种一致的状态。也就是说当事务提交后，或者当事务发生回滚后，数据库的完整性约束不能被破坏。</p>
</li>
<li><p>I，就是隔离性（Isolation）。它指的是每个事务都是彼此独立的，不会受到其他事务的执行影响。也就是说一个事务在提交之前，对其他事务都是不可见的。</p>
</li>
<li><p>最后一个 D，指的是持久性（Durability）。事务提交之后对数据的修改是持久性的，即使在系统出故障的情况下，比如系统崩溃或者存储介质发生故障，数据的修改依然是有效的。因为当事务完成，数据库的日志就会被更新，这时可以通过日志，让系统恢复到最后一次成功的更新状态。<br>ACID 可以说是事务的四大特性，在这四个特性中，原子性是基础，隔离性是手段，一致性是约束条件，而持久性是我们的目的。原子性和隔离性比较好理解，这里我讲下对一致性的理解（国内很多网站上对一致性的阐述有误，具体你可以参考 Wikipedia 对Consistency的阐述）。</p>
</li>
</ol>
<p>我之前讲到过数据表的 7 种常见约束（对应 04 篇）。这里指的一致性本身是由具体的业务定义的，也就是说，任何写入数据库中的数据都需要满足我们事先定义的约束规则。</p>
<p>比如说，在数据表中我们将姓名字段设置为唯一性约束，这时当事务进行提交或者事务发生回滚的时候，如果数据表中的姓名非唯一，就破坏了事务的一致性要求。所以说，事务操作会让数据表的状态变成另一种一致的状态，如果事务中的某个操作失败了，系统就会自动撤销当前正在执行的事务，返回到事务操作之前的状态。</p>
<p>事务的另一个特点就是持久性，持久性是通过事务日志来保证的。日志包括了回滚日志和重做日志。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。</p>
<h3 id="事务的控制"><a href="#事务的控制" class="headerlink" title="事务的控制"></a>事务的控制</h3><p>当我们了解了事务的特性后，再来看下如何使用事务。我们知道 Oracle 是支持事务的，而在 MySQL 中，则需要选择适合的存储引擎才可以支持事务。如果你使用的是 MySQL，可以通过 SHOW ENGINES 命令来查看当前 MySQL 支持的存储引擎都有哪些，以及这些存储引擎是否支持事务。</p>
<p>你能看出在 MySQL 中，InnoDB 是支持事务的，而 MyISAM 存储引擎不支持事务。</p>
<p>看到这里，我们已经对事务有了一定的了解，现在我们再来看下事务的常用控制语句都有哪些。</p>
<ol>
<li>START TRANSACTION 或者 BEGIN，作用是显式开启一个事务。</li>
<li>COMMIT：提交事务。当提交事务后，对数据库的修改是永久性的。</li>
<li>ROLLBACK 或者 ROLLBACK TO [SAVEPOINT]，意为回滚事务。意思是撤销正在进行的所有没有提交的修改，或者将事务回滚到某个保存点。</li>
<li>SAVEPOINT：在事务中创建保存点，方便后续针对保存点进行回滚。一个事务中可以存在多个保存点。</li>
<li>RELEASE SAVEPOINT：删除某个保存点。</li>
<li>SET TRANSACTION，设置事务的隔离级别。<br>需要说明的是，使用事务有两种方式，分别为隐式事务和显式事务。隐式事务实际上就是自动提交，Oracle 默认不自动提交，需要手写 COMMIT 命令，而 MySQL 默认自动提交，当然我们可以配置 MySQL 的参数：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set autocommit =0;  // 关闭自动提交</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ysql&gt; set autocommit =1;  // 开启自动提交</span><br></pre></td></tr></table></figure>
我们看下在 MySQL 的默认状态下，下面这个事务最后的处理结果是什么：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test(name varchar(255), PRIMARY KEY (name)) ENGINE=InnoDB;</span><br><span class="line">BEGIN;</span><br><span class="line">INSERT INTO test SELECT &apos;关羽&apos;;</span><br><span class="line">COMMIT;</span><br><span class="line">BEGIN;</span><br><span class="line">INSERT INTO test SELECT &apos;张飞&apos;;</span><br><span class="line">INSERT INTO test SELECT &apos;张飞&apos;;</span><br><span class="line">ROLLBACK;</span><br><span class="line">SELECT * FROM test;</span><br><span class="line">运行结果（1 行数据）：</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>在这个事务中，整个 SQL 一共执行了 2 个事务，第一个是插入“关羽”，提交后执行成功，第二个是插入两次“张飞”，这里需要注意的是，我们将 name 设置为了主键，也就是说主键的值是唯一的，那么第二次插入“张飞”时就会产生错误，然后执行 ROLLBACK 相当于对事务进行了回滚，所以我们看到最终结果只有一行数据，也就是第一个事务执行之后的结果，即“关羽”。</p>
<p>那么如果我们进行下面的操作又会怎样呢？</p>
<p>CREATE TABLE test(name varchar(255), PRIMARY KEY (name)) ENGINE=InnoDB;<br>BEGIN;<br>INSERT INTO test SELECT ‘关羽’;<br>COMMIT;<br>INSERT INTO test SELECT ‘张飞’;<br>INSERT INTO test SELECT ‘张飞’;<br>ROLLBACK;<br>SELECT * FROM test;<br>运行结果（2 行数据）：</p>
<p>你能看到这次数据是 2 行，上一次操作我把两次插入“张飞”放到一个事务里，而这次操作它们不在同一个事务里，那么对于 MySQL 来说，默认情况下这实际上就是两个事务，因为在 autocommit=1 的情况下，MySQL 会进行隐式事务，也就是自动提交，因此在进行第一次插入“张飞”后，数据表里就存在了两行数据，而第二次插入“张飞”就会报错：1062 - Duplicate entry ‘张飞’ for key ‘PRIMARY’。</p>
<p>最后我们在执行 ROLLBACK 的时候，实际上事务已经自动提交了，就没法进行回滚了。</p>
<p>同样的我们再来看下这段代码，你又能发现什么不同呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test(name varchar(255), PRIMARY KEY (name)) ENGINE=InnoDB;</span><br><span class="line">SET @@completion_type = 1;</span><br><span class="line">BEGIN;</span><br><span class="line">INSERT INTO test SELECT &apos;关羽&apos;;</span><br><span class="line">COMMIT;</span><br><span class="line">INSERT INTO test SELECT &apos;张飞&apos;;</span><br><span class="line">INSERT INTO test SELECT &apos;张飞&apos;;</span><br><span class="line">ROLLBACK;</span><br><span class="line">SELECT * FROM test;</span><br></pre></td></tr></table></figure>
<p>运行结果（1 行数据）：</p>
<p>你能看到还是相同的 SQL 代码，只是我在事务开始之前设置了SET @@completion_type = 1;，结果就和我们第一次处理的一样，只有一个“关羽”。这是为什么呢？</p>
<p>这里我讲解下 MySQL 中 completion_type 参数的作用，实际上这个参数有 3 种可能：</p>
<ol>
<li>completion=0，这是默认情况。也就是说当我们执行 COMMIT 的时候会提交事务，在执行下一个事务时，还需要我们使用 START TRANSACTION 或者 BEGIN 来开启。</li>
<li>completion=1，这种情况下，当我们提交事务后，相当于执行了 COMMIT AND CHAIN，也就是开启一个链式事务，即当我们提交事务之后会开启一个相同隔离级别的事务（隔离级别会在下一节中进行介绍）。</li>
<li>completion=2，这种情况下 COMMIT=COMMIT AND RELEASE，也就是当我们提交后，会自动与服务器断开连接。</li>
</ol>
<p>在上面这段代码里，我使用了 completion=1，也就是说当我提交之后，相当于在下一行写了一个 START TRANSACTION 或 BEGIN。这时两次插入“张飞”会被认为是在同一个事务之内的操作，那么第二次插入“张飞”就会导致事务失败，而回滚也将这次事务进行了撤销，所以你能看到的结果就只有一个“关羽”。</p>
<p>通过这样简单的练习，你应该能体会到事务提交和回滚的操作。</p>
<p>当我们设置 autocommit=0 时，不论是否采用 START TRANSACTION 或者 BEGIN 的方式来开启事务，都需要用 COMMIT 进行提交，让事务生效，使用 ROLLBACK 对事务进行回滚。</p>
<p>当我们设置 autocommit=1 时，每条 SQL 语句都会自动进行提交。<br>不过这时，如果你采用 START TRANSACTION 或者 BEGIN 的方式来显式地开启事务，那么这个事务只有在 COMMIT 时才会生效，在 ROLLBACK 时才会回滚。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于 SQL 中的事务处理，内容相对比较多，因此我会采用两节来进行讲解。今天我们对事务的概念进行了理解，并进行了简单的事务操作。我们在做数据库操作的时候，可能会失败，但正是因为有事务的存在，即使在数据库操作失败的情况下，也能保证数据的一致性。同样，多个应用程序访问数据库的时候，事务可以提供隔离，保证事务之间不被干扰。最后，事务一旦提交，结果就会是永久性的，这就意味着，即使系统崩溃了，数据库也可以对数据进行恢复。</p>
<p>在使用事务的过程中，我们会采用控制流语句对事务进行操作，不过在实际操作中，不一定每次使用 COMMIT 或 ROLLBACK 都会成功，你还需要知道当前系统的事务执行方式，也就是一些常用的参数情况，比如 MySQL 中的 autocommit 和 completion_type 等。</p>
<p>事务是数据库区别于文件系统的重要特性之一，当我们有了事务就会让数据库始终保持一致性，同时我们还能通过事务的机制恢复到某个时间点，这样可以保证已提交到数据库的修改不会因为系统崩溃而丢失。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/26/13%E4%B8%A8%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%8C%E5%9C%A8%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%BE%97%E5%A4%9A%E4%B9%88%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/26/13%E4%B8%A8%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%8C%E5%9C%A8%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%BE%97%E5%A4%9A%E4%B9%88%EF%BC%9F/" itemprop="url">13丨什么是存储过程，在实际项目中用得多么？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-26T20:09:01+08:00">
                2020-03-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/" itemprop="url" rel="index">
                    <span itemprop="name">SQL必知必会</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/26/13%E4%B8%A8%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%8C%E5%9C%A8%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%BE%97%E5%A4%9A%E4%B9%88%EF%BC%9F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/03/26/13%E4%B8%A8%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%8C%E5%9C%A8%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%BE%97%E5%A4%9A%E4%B9%88%EF%BC%9F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上一节我介绍了视图，它是 SQL 中的一个重要应用，使用视图对 SQL 查询进行封装，可以让 SQL 的代码结构更清晰，让用户权限管理更安全。</p>
<p>今天我来讲一下 SQL 的存储过程，它是 SQL 中另一个重要应用，和视图一样，都是对 SQL 代码进行封装，可以反复利用。它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。不过它和视图不同，视图是虚拟表，通常不对底层数据表直接操作，而存储过程是程序化的 SQL，可以直接操作底层数据表，相比于面向集合的操作方式，能够实现一些更复杂的数据处理。存储过程可以说是由 SQL 语句和流控制语句构成的语句集合，它和我们之前学到的函数一样，可以接收输入参数，也可以返回输出参数给调用者，返回计算结果。</p>
<p>今天有关存储过程的内容，你将重点掌握以下几个部分：</p>
<ol>
<li>什么是存储过程，如何创建一个存储过程？</li>
<li>流控制语句都有哪些，如何使用它们？</li>
<li>各大公司是如何看待存储过程的？在实际工作中，我们该如何使用存储过程？<h3 id="什么是存储过程，如何创建一个存储过程"><a href="#什么是存储过程，如何创建一个存储过程" class="headerlink" title="什么是存储过程，如何创建一个存储过程"></a>什么是存储过程，如何创建一个存储过程</h3>存储过程的英文是 Stored Procedure。它的思想很简单，就是 SQL 语句的封装。一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。我在前面讲过，存储过程实际上由 SQL 语句和流控制语句共同组成。流控制语句都有哪些呢？这个我稍后讲解。</li>
</ol>
<p>我们先来看下如何定义一个存储过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE 存储过程名称 ([参数列表])</span><br><span class="line">BEGIN</span><br><span class="line">    需要执行的语句</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<p>在这里，我们使用 CREATE PROCEDURE 创建一个存储过程，后面是存储过程的名称，以及过程所带的参数，可以包括输入参数和输出参数。最后由 BEGIN 和 END 来定义我们所要执行的语句块。</p>
<p>和视图一样，我们可以删除已经创建的存储过程，使用的是 DROP PROCEDURE。如果要更新存储过程，我们需要使用 ALTER PROCEDURE。</p>
<p>讲完了如何创建，更新和删除一个存储过程，下面我们来看下如何实现一个简单的存储过程。比如我想做一个累加运算，计算 1+2+…+n 等于多少，我们可以通过参数 n 来表示想要累加的个数，那么如何用存储过程实现这一目的呢？这里我做一个 add_num 的存储过程，具体的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE `add_num`(IN n INT)</span><br><span class="line">BEGIN</span><br><span class="line">       DECLARE i INT;</span><br><span class="line">       DECLARE sum INT;</span><br><span class="line">       </span><br><span class="line">       SET i = 1;</span><br><span class="line">       SET sum = 0;</span><br><span class="line">       WHILE i &lt;= n DO</span><br><span class="line">              SET sum = sum + i;</span><br><span class="line">              SET i = i +1;</span><br><span class="line">       END WHILE;</span><br><span class="line">       SELECT sum;</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<p>当我们需要再次使用这个存储过程的时候，直接使用 CALL add_num(50);即可。这里我传入的参数为 50，也就是统计 1+2+…+50 的积累之和，查询结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SUM</span><br><span class="line">1275</span><br></pre></td></tr></table></figure>

<p>这就是一个简单的存储过程，除了理解 1+2+…+n 的实现过程，还有两点你需要理解，一个是 DELIMITER 定义语句的结束符，另一个是存储过程的三种参数类型。</p>
<p>我们先来看下 DELIMITER 的作用。如果你使用 Navicat 这个工具来管理 MySQL 执行存储过程，那么直接执行上面这段代码就可以了。如果用的是 MySQL，你还需要用 DELIMITER 来临时定义新的结束符。因为默认情况下 SQL 采用（；）作为结束符，这样当存储过程中的每一句 SQL 结束之后，采用（；）作为结束符，就相当于告诉 SQL 可以执行这一句了。但是存储过程是一个整体，我们不希望 SQL 逐条执行，而是采用存储过程整段执行的方式，因此我们就需要临时定义新的 DELIMITER，新的结束符可以用（//）或者（$$）。如果你用的是 MySQL，那么上面这段代码，应该写成下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE `add_num`(IN n INT)</span><br><span class="line">BEGIN</span><br><span class="line">       DECLARE i INT;</span><br><span class="line">       DECLARE sum INT;</span><br><span class="line">       </span><br><span class="line">       SET i = 1;</span><br><span class="line">       SET sum = 0;</span><br><span class="line">       WHILE i &lt;= n DO</span><br><span class="line">              SET sum = sum + i;</span><br><span class="line">              SET i = i +1;</span><br><span class="line">       END WHILE;</span><br><span class="line">       SELECT sum;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
<p>首先我用（//）作为结束符，又在整个存储过程结束后采用了（//）作为结束符号，告诉 SQL 可以执行了，然后再将结束符还原成默认的（;）。</p>
<p>需要注意的是，如果你用的是 Navicat 工具，那么在编写存储过程的时候，Navicat 会自动设置 DELIMITER 为其他符号，我们不需要再进行 DELIMITER 的操作。</p>
<p>我们再来看下存储过程的 3 种参数类型。在刚才的存储过程中，我们使用了 IN 类型的参数，另外还有 OUT 类型和 INOUT 类型，作用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">参数类型  是否返回         作用</span><br><span class="line">IN       否              向存储过程传入参数,存储过程中修改该参数的值,不能被返回.</span><br><span class="line">OUT      是              把存储过程计算的结果放到该参数中, 调用者可以得到返回值.</span><br><span class="line">INOUT    是              IN和OUT的结合,既用于存储过程的传入参数,同时又可以把计算结果放入参数中,调用者可以得到返回参数.</span><br></pre></td></tr></table></figure>
<p>IN 和 OUT 的结合，既用于存储过程的传入参数，同时又可以把计算结果放到参数中，调用者可以得到返回值。</p>
<p>你能看到，IN 参数必须在调用存储过程时指定，而在存储过程中修改该参数的值不能被返回。而 OUT 参数和 INOUT 参数可以在存储过程中被改变，并可返回。</p>
<p>举个例子，这里会用到我们之前讲过的王者荣耀的英雄数据表 heros。假设我想创建一个存储类型 get_hero_scores，用来查询某一类型英雄中的最大的最大生命值，最小的最大魔法值，以及平均最大攻击值，那么该怎么写呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE `get_hero_scores`(</span><br><span class="line">       OUT max_max_hp FLOAT,</span><br><span class="line">       OUT min_max_mp FLOAT,</span><br><span class="line">       OUT avg_max_attack FLOAT,  </span><br><span class="line">       s VARCHAR(255)</span><br><span class="line">       )</span><br><span class="line">BEGIN</span><br><span class="line">       SELECT MAX(hp_max), MIN(mp_max), AVG(attack_max) FROM heros WHERE role_main = s INTO max_max_hp, min_max_mp, avg_max_attack;</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<p>你能看到我定义了 4 个参数类型，其中 3 个为 OUT 类型，分别为 max_max_hp、min_max_mp 和 avg_max_attack，另一个参数 s 为 IN 类型。<br>这里我们从 heros 数据表中筛选主要英雄定位为 s 的英雄数据，即筛选条件为 role_main=s，提取这些数据中的最大的最大生命值，最小的最大魔法值，以及平均最大攻击值，分别赋值给变量 max_max_hp、min_max_mp 和 avg_max_attack。<br>然后我们就可以调用存储过程，使用下面这段代码即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALL get_hero_scores(@max_max_hp, @min_max_mp, @avg_max_attack, &apos;战士&apos;);</span><br><span class="line">SELECT @max_max_hp, @min_max_mp, @avg_max_attack;</span><br></pre></td></tr></table></figure>
<p>流控制语句<br>流控制语句是用来做流程控制的，我刚才讲了两个简单的存储过程的例子，一个是 1+2+…+n 的结果计算，一个是王者荣耀的数据查询，你能看到这两个例子中，我用到了下面的流控制语句：</p>
<ol>
<li>BEGIN…END：BEGIN…END 中间包含了多个语句，每个语句都以（;）号为结束符。</li>
<li>DECLARE：DECLARE 用来声明变量，使用的位置在于 BEGIN…END 语句中间，而且需要在其他语句使用之前进行变量的声明。</li>
<li>SET：赋值语句，用于对变量进行赋值。</li>
<li>SELECT…INTO：把从数据表中查询的结果存放到变量中，也就是为变量赋值。<br>除了上面这些用到的流控制语句以外，还有一些常用的流控制语句：</li>
</ol>
<p>1.IF…THEN…ENDIF：条件判断语句，我们还可以在 IF…THEN…ENDIF 中使用 ELSE 和 ELSEIF 来进行条件判断。<br>2.CASE：CASE 语句用于多条件的分支判断，使用的语法是下面这样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CASE </span><br><span class="line">	WHEN expression1 THEN ...</span><br><span class="line">	WHEN expression2 THEN ...</span><br><span class="line">	...</span><br><span class="line">    ELSE </span><br><span class="line">    --ELSE 语句可以加，也可以不加。加的话代表的所有条件都不满足时采用的方式。</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<p>3.LOOP、LEAVE 和 ITERATE：LOOP 是循环语句，使用 LEAVE 可以跳出循环，使用 ITERATE 则可以进入下一次循环。如果你有面向过程的编程语言的使用经验，你可以把 LEAVE 理解为 BREAK，把 ITERATE 理解为 CONTINUE。<br>4.REPEAT…UNTIL…END REPEAT：这是一个循环语句，首先会执行一次循环，然后在 UNTIL 中进行表达式的判断，如果满足条件就退出，即 END REPEAT；如果条件不满足，则会就继续执行循环，直到满足退出条件为止。<br>5.WHILE…DO…END WHILE：这也是循环语句，和 REPEAT 循环不同的是，这个语句需要先进行条件判断，如果满足条件就进行循环，如果不满足条件就退出循环。</p>
<p>我们之前说过 SQL 是声明型语言，使用 SQL 就像在使用英语，简单直接。今天讲的存储过程，尤其是在存储过程中使用到的流控制语句，属于过程性语言，类似于 C++ 语言中函数，这些语句可以帮我们解决复杂的业务逻辑。</p>
<h3 id="关于存储过程使用的争议"><a href="#关于存储过程使用的争议" class="headerlink" title="关于存储过程使用的争议"></a>关于存储过程使用的争议</h3><p>尽管存储过程有诸多优点，但是对于存储过程的使用，一直都存在着很多争议，比如有些公司对于大型项目要求使用存储过程，而有些公司在手册中明确禁止使用存储过程，为什么这些公司对存储过程的使用需求差别这么大呢？</p>
<p>我们得从存储过程的特点来找答案。</p>
<p>你能看到存储过程有很多好处。</p>
<p>首先存储过程可以一次编译多次使用。存储过程只在创造时进行编译，之后的使用都不需要重新编译，这就提升了 SQL 的执行效率。其次它可以减少开发工作量。将代码封装成模块，实际上是编程的核心思想之一，这样可以把复杂的问题拆解成不同的模块，然后模块之间可以重复使用，在减少开发工作量的同时，还能保证代码的结构清晰。还有一点，存储过程的安全性强，我们在设定存储过程的时候可以设置对用户的使用权限，这样就和视图一样具有较强的安全性。最后它可以减少网络传输量，因为代码封装到存储过程中，每次使用只需要调用存储过程即可，这样就减少了网络传输量。同时在进行相对复杂的数据库操作时，原本需要使用一条一条的 SQL 语句，可能要连接多次数据库才能完成的操作，现在变成了一次存储过程，只需要连接一次即可。</p>
<p>基于上面这些优点，不少大公司都要求大型项目使用存储过程，比如微软、IBM 等公司。但是国内的阿里并不推荐开发人员使用存储过程，这是为什么呢？</p>
<p>存储过程虽然有诸如上面的好处，但缺点也是很明显的。</p>
<p>它的可移植性差，存储过程不能跨数据库移植，比如在 MySQL、Oracle 和 SQL Server 里编写的存储过程，在换成其他数据库时都需要重新编写。</p>
<p>其次调试困难，只有少数 DBMS 支持存储过程的调试。对于复杂的存储过程来说，开发和维护都不容易。</p>
<p>此外，存储过程的版本管理也很困难，比如数据表索引发生变化了，可能会导致存储过程失效。我们在开发软件的时候往往需要进行版本管理，但是存储过程本身没有版本控制，版本迭代更新的时候很麻烦。</p>
<p>最后它不适合高并发的场景，高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护，增加数据库的压力，显然就不适用了。</p>
<p>了解了存储过程的优缺点之后，我想说的是，存储过程既方便，又有局限性。尽管不同的公司对存储过程的态度不一，但是对于我们开发人员来说，不论怎样，掌握存储过程都是必备的技能之一。</p>
<p>最后我们做一个小练习吧。针对王者荣耀的英雄数据表 heros 表，请编写存储过程 get_sum_score，用来得到某一类型英雄（主要定位为某一类型即可）的最大生命值的总和。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;i class=&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/">&lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">LvYang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">71</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LvYang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    





  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'qcq1G35cOv9sG5BrpbdXJwtJ-gzGzoHsz',
        appKey: 'VtFEF7WhBgSXbcGzdO1GztzO',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
