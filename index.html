<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="LvYang">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="LvYang">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>LvYang</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LvYang</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/04/35%20%7C%20RESTful%20&%20Socket%E8%A1%8C%E6%83%85%E6%95%B0%E6%8D%AE%E5%AF%B9%E6%8E%A5%E5%92%8C%E6%8A%93%E5%8F%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/04/35%20%7C%20RESTful%20&%20Socket%E8%A1%8C%E6%83%85%E6%95%B0%E6%8D%AE%E5%AF%B9%E6%8E%A5%E5%92%8C%E6%8A%93%E5%8F%96/" itemprop="url">35 | RESTful & Socket行情数据对接和抓取</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-04T20:10:07+08:00">
                2020-01-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/" itemprop="url" rel="index">
                    <span itemprop="name">python核心技术与实战</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/04/35%20%7C%20RESTful%20&%20Socket%E8%A1%8C%E6%83%85%E6%95%B0%E6%8D%AE%E5%AF%B9%E6%8E%A5%E5%92%8C%E6%8A%93%E5%8F%96/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/01/04/35%20%7C%20RESTful%20&%20Socket%E8%A1%8C%E6%83%85%E6%95%B0%E6%8D%AE%E5%AF%B9%E6%8E%A5%E5%92%8C%E6%8A%93%E5%8F%96/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="行情数据"><a href="#行情数据" class="headerlink" title="行情数据"></a>行情数据</h3><p>回顾上一节我们提到的，交易所是一个买方、卖方之间的公开撮合平台。买卖方把需要 / 可提供的商品数量和愿意出 / 接受的价格提交给交易所，交易所按照公平原则进行撮合交易。</p>
<p>那么撮合交易是怎么进行的呢？假设你是一个人肉比特币交易所，大量的交易订单往你这里汇总，你应该如何选择才能让交易公平呢？</p>
<p>显然，最直观的操作就是，把买卖订单分成两个表，按照价格由高到低排列。下面的图，就是买入和卖出的委托表。</p>
<p>如果最高的买入价格小于最低的卖出价格，那就不会有任何交易发生。这通常是你看到的委托列表的常态。</p>
<p>如果最高的买入价格和最低的卖出价格相同，那么就尝试进行撮合。比如 BTC 在 9002.01 就会发生撮合，最后按照 9002.01 的价格，成交 0.0330 个 BTC。当然，交易完成后，小林未完成部分的订单（余下 0.1126 - 0.0330 = 0.0796 个 BTC 未卖出），还会继续在委托表里。</p>
<p>不过你可能会想，如果买入和卖出的价格有交叉，那么成交价格又是什么呢？事实上，这种情况并不会发生。我们来试想一下下面这样的场景。</p>
<p>如果你尝试给一个委托列表里加入一个新买入订单，它的价格比所有已有的最高买入价格高，也比所有的卖出价格高。那么此时，它会直接从最低的卖出价格撮合。等到最低价格的卖出订单吃完了，它便开始吃价格第二低的卖出订单，直到这个买入订单完全成交。反之亦然。所以，委托列表价格不会出现交叉。</p>
<p>当然，请注意，这里我说的只是限价订单的交易方式。而对于市价订单，交易规则会有一些轻微的区别，这里我就不详细解释了，主要是让你有个概念。</p>
<p>其实说到这里，所谓的“交易所行情”概念就呼之欲出了。交易所主要有两种行情数据：委托账本（Order Book）和活动行情（Tick data）。</p>
<p>我们把委托表里的具体用户隐去，相同价格的订单合并，就得到了下面这种委托账本。我们主要观察右边的数字部分，其中：</p>
<ul>
<li>上半部分里，第一列红色数字代表 BTC 的卖出价格，中间一列数字是这个价格区间的订单 BTC 总量，最右边一栏是从最低卖出价格到当前价格区间的积累订单量。</li>
<li>中间的大字部分，9994.10 USD 是当前的市场价格，也就是上一次成交交易的价格。</li>
<li>下面绿色部分的含义与上半部分类似，不过指的是买入委托和对应的数量。</li>
</ul>
<p>这张图中，最低的卖出价格比最高的买入价格要高 6.51 USD，这个价差通常被称为 Spread。这里验证了我们前面提到的，委托账本的价格永不交叉； 同时，Spread 很小也能说明这是一个非常活跃的交易所。</p>
<p>每一次撮合发生，意味着一笔交易（Trade）的发生。卖方买方都很开心，于是交易所也很开心地通知行情数据的订阅者：刚才发生了一笔交易，交易的价格是多少，成交数量是多少。这个数据就是活动行情 Tick。</p>
<p>有了这些数据，我们也就掌握了这个交易所的当前状态，可以开始搞事情了。</p>
<h3 id="Websocket-介绍"><a href="#Websocket-介绍" class="headerlink" title="Websocket 介绍"></a>Websocket 介绍</h3><p>在本文的开头我们提到过：行情数据很讲究时效性。所以，行情从交易所产生到传播给我们的程序之间的延迟，应该越低越好。通常，交易所也提供了 REST 的行情数据抓取接口。比如下面这段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_orderbook</span><span class="params">()</span>:</span></span><br><span class="line">  orderbook = requests.get(<span class="string">"https://api.gemini.com/v1/book/btcusd"</span>).json()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">n = <span class="number">10</span></span><br><span class="line">latency = timeit.timeit(<span class="string">'get_orderbook()'</span>, setup=<span class="string">'from __main__ import get_orderbook'</span>, number=n) * <span class="number">1.0</span> / n</span><br><span class="line">print(<span class="string">'Latency is &#123;&#125; ms'</span>.format(latency * <span class="number">1000</span>))</span><br></pre></td></tr></table></figure>

<pre><code>Latency is 1216.6739538000002 ms</code></pre><p>我在美国纽约附近城市的一个服务器上测试了这段代码，你可以看到，平均每次访问 orderbook 的延迟有 0.25 秒左右。显然，如果在国内，这个延迟只会更大。按理说，这两个美国城市的距离很短，为什么延迟会这么大呢？</p>
<p>这是因为，REST 接口本质上是一个 HTTP 接口，在这之下是 TCP/TSL 套接字（Socket）连接。每一次 REST 请求，通常都会重新建立一次 TCP/TSL 握手；然后，在请求结束之后，断开这个链接。这个过程，比我们想象的要慢很多。</p>
<p>举个例子来验证这一点，在同一个城市我们试验一下。我从纽约附近的服务器和 Gemini 在纽约的服务器进行连接，TCP/SSL 握手花了多少时间呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -w <span class="string">"TCP handshake: %&#123;time_connect&#125;s, SSL handshake: %&#123;time_appconnect&#125;s\n"</span> -so /dev/null https://www.gemini.com</span><br></pre></td></tr></table></figure>


<pre><code>  File &quot;&lt;ipython-input-2-946ae0cd5ce7&gt;&quot;, line 1
    curl -w &quot;TCP handshake: %{time_connect}s, SSL handshake: %{time_appconnect}s\n&quot; -so /dev/null https://www.gemini.com
                                                                                  ^
SyntaxError: invalid syntax</code></pre><p>结果显示，HTTP 连接构建的过程，就占了一大半时间！也就是说，我们每次用 REST 请求，都要浪费一大半的时间在和服务器建立连接上，这显然是非常低效的。很自然的你会想到，我们能否实现一次连接、多次通信呢？</p>
<p>事实上，Python 的某些 HTTP 请求库，也可以支持重用底层的 TCP/SSL 连接。但那种方法，一来比较复杂，二来也需要服务器的支持。该怎么办呢？其实，在有 WebSocket 的情况下，我们完全不需要舍近求远。</p>
<p>我先来介绍一下 WebSocket。WebSocket 是一种在单个 TCP/TSL 连接上，进行全双工、双向通信的协议。WebSocket 可以让客户端与服务器之间的数据交换变得更加简单高效，服务端也可以主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就可以直接创建持久性的连接，并进行双向数据传输。</p>
<p>概念听着很痛快，不过还是有些抽象。为了让你快速理解刚刚的这段话，我们还是来看两个简单的例子。二话不说，先看一段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> websocket</span><br><span class="line"><span class="keyword">import</span> thread</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 在接收到服务器发送消息时调用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span><span class="params">(ws, message)</span>:</span></span><br><span class="line">    print(<span class="string">'Received: '</span> + message)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 在和服务器建立完成连接时调用   </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_open</span><span class="params">(ws)</span>:</span></span><br><span class="line">    <span class="comment"># 线程运行函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gao</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="comment"># 往服务器依次发送 0-4，每次发送完休息 0.1 秒</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">            time.sleep(<span class="number">0.01</span>)</span><br><span class="line">            msg=<span class="string">"&#123;0&#125;"</span>.format(i)</span><br><span class="line">            ws.send(msg)</span><br><span class="line">            print(<span class="string">'Sent: '</span> + msg)</span><br><span class="line">        <span class="comment"># 休息 1 秒用于接受服务器回复的消息</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 关闭 Websocket 的连接</span></span><br><span class="line">        ws.close()</span><br><span class="line">        print(<span class="string">"Websocket closed"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 在另一个线程运行 gao() 函数</span></span><br><span class="line">    thread.start_new_thread(gao, ())</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    ws = websocket.WebSocketApp(<span class="string">"ws://echo.websocket.org/"</span>,</span><br><span class="line">                              on_message = on_message,</span><br><span class="line">                              on_open = on_open)</span><br><span class="line">    </span><br><span class="line">    ws.run_forever()</span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

ModuleNotFoundError                       Traceback (most recent call last)

&lt;ipython-input-1-f88baa1bc71c&gt; in &lt;module&gt;
      1 import websocket
----&gt; 2 import thread
      3 
      4 # 在接收到服务器发送消息时调用
      5 def on_message(ws, message):


ModuleNotFoundError: No module named &apos;thread&apos;</code></pre><p>这段代码尝试和wss://echo.websocket.org建立连接。当连接建立的时候，就会启动一条线程，连续向服务器发送 5 条消息。</p>
<p>通过输出可以看出，我们在连续发送的同时，也在不断地接受消息。这并没有像 REST 一样，每发送一个请求，要等待服务器完成请求、完全回复之后，再进行下一个请求。换句话说，我们在请求的同时也在接受消息，这也就是前面所说的”全双工“。</p>
<p>再来看第二段代码。为了解释”双向“，我们来看看获取 Gemini 的委托账单的例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line"><span class="keyword">import</span> websocket</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 全局计数器</span></span><br><span class="line">count = <span class="number">5</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span><span class="params">(ws, message)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> count</span><br><span class="line">    print(message)</span><br><span class="line">    count -= <span class="number">1</span></span><br><span class="line">    <span class="comment"># 接收了 5 次消息之后关闭 websocket 连接</span></span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">        ws.close()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    ws = websocket.WebSocketApp(</span><br><span class="line">        <span class="string">"wss://api.gemini.com/v1/marketdata/btcusd?top_of_book=true&amp;offers=true"</span>,</span><br><span class="line">        on_message=on_message)</span><br><span class="line">    ws.run_forever(sslopt=&#123;<span class="string">"cert_reqs"</span>: ssl.CERT_NONE&#125;)</span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

AttributeError                            Traceback (most recent call last)

&lt;ipython-input-4-00b6ecb101b9&gt; in &lt;module&gt;
     15 
     16 if __name__ == &quot;__main__&quot;:
---&gt; 17     ws = websocket.WebSocketApp(
     18         &quot;wss://api.gemini.com/v1/marketdata/btcusd?top_of_book=true&amp;offers=true&quot;,
     19         on_message=on_message)


AttributeError: module &apos;websocket&apos; has no attribute &apos;WebSocketApp&apos;</code></pre><p>可以看到，在和 Gemini 建立连接后，我们并没有向服务器发送任何消息，没有任何请求，但是服务器却源源不断地向我们推送数据。这可比 REST 接口“每请求一次获得一次回复”的沟通方式高效多了！</p>
<p>因此，相对于 REST 来说，Websocket 是一种更加实时、高效的数据交换方式。当然缺点也很明显：因为请求和回复是异步的，这让我们程序的状态控制逻辑更加复杂。这一点，后面的内容里我们会有更深刻的体会。</p>
<h3 id="行情抓取模块"><a href="#行情抓取模块" class="headerlink" title="行情抓取模块"></a>行情抓取模块</h3><p>有了 Websocket 的基本概念，我们就掌握了和交易所连接的第二种方式。</p>
<p>事实上，Gemini 提供了两种 Websocket 接口，一种是 Public 接口，一种为 Private 接口。</p>
<p>Public 接口，即公开接口，提供 orderbook 服务，即每个人都能看到的当前挂单价和深度，也就是我们这节课刚刚详细讲过的 orderbook。</p>
<p>而 Private 接口，和我们上节课讲的挂单操作有关，订单被完全执行、被部分执行等等其他变动，你都会得到通知。</p>
<p>我们以 orderbook 爬虫为例，先来看下如何抓取 orderbook 信息。下面的代码详细写了一个典型的爬虫，同时使用了类进行封装，希望你不要忘记我们这们课的目的，了解 Python 是如何应用于工程实践中的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> websocket</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderBook</span><span class="params">(object)</span>:</span></span><br><span class="line"> </span><br><span class="line">    BIDS = <span class="string">'bid'</span></span><br><span class="line">    ASKS = <span class="string">'ask'</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, limit=<span class="number">20</span>)</span>:</span></span><br><span class="line"> </span><br><span class="line">        self.limit = limit</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># (price, amount)</span></span><br><span class="line">        self.bids = &#123;&#125;</span><br><span class="line">        self.asks = &#123;&#125;</span><br><span class="line"> </span><br><span class="line">        self.bids_sorted = []</span><br><span class="line">        self.asks_sorted = []</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, price, amount, direction)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> direction == self.BIDS:</span><br><span class="line">            <span class="keyword">if</span> amount == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> price <span class="keyword">in</span> self.bids:</span><br><span class="line">                    <span class="keyword">del</span> self.bids[price]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.bids[price] = amount</span><br><span class="line">        <span class="keyword">elif</span> direction == self.ASKS:</span><br><span class="line">            <span class="keyword">if</span> amount == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> price <span class="keyword">in</span> self.asks:</span><br><span class="line">                    <span class="keyword">del</span> self.asks[price]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.asks[price] = amount</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'WARNING: unknown direction &#123;&#125;'</span>.format(direction))</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sort_and_truncate</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># sort</span></span><br><span class="line">        self.bids_sorted = sorted([(price, amount) <span class="keyword">for</span> price, amount <span class="keyword">in</span> self.bids.items()], reverse=<span class="literal">True</span>)</span><br><span class="line">        self.asks_sorted = sorted([(price, amount) <span class="keyword">for</span> price, amount <span class="keyword">in</span> self.asks.items()])</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># truncate</span></span><br><span class="line">        self.bids_sorted = self.bids_sorted[:self.limit]</span><br><span class="line">        self.asks_sorted = self.asks_sorted[:self.limit]</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># copy back to bids and asks</span></span><br><span class="line">        self.bids = dict(self.bids_sorted)</span><br><span class="line">        self.asks = dict(self.asks_sorted)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_copy_of_bids_and_asks</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> copy.deepcopy(self.bids_sorted), copy.deepcopy(self.asks_sorted)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crawler</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, symbol, output_file)</span>:</span></span><br><span class="line">        self.orderbook = OrderBook(limit=<span class="number">10</span>)</span><br><span class="line">        self.output_file = output_file</span><br><span class="line"> </span><br><span class="line">        self.ws = websocket.WebSocketApp(<span class="string">'wss://api.gemini.com/v1/marketdata/&#123;&#125;'</span>.format(symbol),</span><br><span class="line">                                         on_message = <span class="keyword">lambda</span> ws, message: self.on_message(message))</span><br><span class="line">        self.ws.run_forever(sslopt=&#123;<span class="string">'cert_reqs'</span>: ssl.CERT_NONE&#125;)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_message</span><span class="params">(self, message)</span>:</span></span><br><span class="line">        <span class="comment"># 对收到的信息进行处理，然后送给 orderbook</span></span><br><span class="line">        data = json.loads(message)</span><br><span class="line">        <span class="keyword">for</span> event <span class="keyword">in</span> data[<span class="string">'events'</span>]:</span><br><span class="line">            price, amount, direction = float(event[<span class="string">'price'</span>]), float(event[<span class="string">'remaining'</span>]), event[<span class="string">'side'</span>]</span><br><span class="line">            self.orderbook.insert(price, amount, direction)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 整理 orderbook，排序，只选取我们需要的前几个</span></span><br><span class="line">        self.orderbook.sort_and_truncate()</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 输出到文件</span></span><br><span class="line">        <span class="keyword">with</span> open(self.output_file, <span class="string">'a+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            bids, asks = self.orderbook.get_copy_of_bids_and_asks()</span><br><span class="line">            output = &#123;</span><br><span class="line">                <span class="string">'bids'</span>: bids,</span><br><span class="line">                <span class="string">'asks'</span>: asks,</span><br><span class="line">                <span class="string">'ts'</span>: int(time.time() * <span class="number">1000</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            f.write(json.dumps(output) + <span class="string">'\n'</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    crawler = Crawler(symbol=<span class="string">'BTCUSD'</span>, output_file=<span class="string">'BTCUSD.txt'</span>)</span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

AttributeError                            Traceback (most recent call last)

&lt;ipython-input-1-cec014539940&gt; in &lt;module&gt;
     86 
     87 if __name__ == &apos;__main__&apos;:
---&gt; 88     crawler = Crawler(symbol=&apos;BTCUSD&apos;, output_file=&apos;BTCUSD.txt&apos;)


&lt;ipython-input-1-cec014539940&gt; in __init__(self, symbol, output_file)
     60         self.output_file = output_file
     61 
---&gt; 62         self.ws = websocket.WebSocketApp(&apos;wss://api.gemini.com/v1/marketdata/{}&apos;.format(symbol),
     63                                          on_message = lambda ws, message: self.on_message(message))
     64         self.ws.run_forever(sslopt={&apos;cert_reqs&apos;: ssl.CERT_NONE})


AttributeError: module &apos;websocket&apos; has no attribute &apos;WebSocketApp&apos;</code></pre><p>代码比较长，接下来我们具体解释一下。</p>
<p>这段代码的最开始，封装了一个叫做 orderbook 的 class，专门用来存放与之相关的数据结构。其中的 bids 和 asks 两个字典，用来存储当前时刻下的买方挂单和卖方挂单。</p>
<p>此外，我们还专门维护了一个排过序的 bids_sorted 和 asks_sorted。构造函数有一个参数 limit，用来指示 orderbook 的 bids 和 asks 保留多少条数据。对于很多策略，top 5 的数据往往足够，这里我们选择的是前 10 个。</p>
<p>再往下看，insert() 函数用于向 orderbook 插入一条数据。需要注意，这里的逻辑是，如果某个 price 对应的 amount 是 0，那么意味着这一条数据已经不存在了，删除即可。insert 的数据可能是乱序的，因此在需要的时候，我们要对 bids 和 asks 进行排序，然后选取前面指定数量的数据。这其实就是 sort_and_truncate() 函数的作用，调用它来对 bids 和 asks 排序后截取，最后保存回 bids 和 asks。</p>
<p>接下来的 get_copy_of_bids_and_asks() 函数，用来返回排过序的 bids 和 asks 数组。这里使用深拷贝，是因为如果直接返回，将会返回 bids_sorted 和 asks_sorted 的指针；那么，在下一次调用 sort_and_truncate() 函数的时候，两个数组的内容将会被改变，这就造成了潜在的 bug。</p>
<p>最后来看一下 Crawler 类。构造函数声明 orderbook，然后定义 Websocket 用来接收交易所数据。这里需要注意的一点是，回调函数 on_message() 是一个类成员函数。因此，应该你注意到了，它的第一个参数是 self，这里如果直接写成 on_message = self.on_message 将会出错。</p>
<p>为了避免这个问题，我们需要将函数再次包装一下。这里我使用了前面学过的匿名函数，来传递中间状态，注意我们只需要 message，因此传入 message 即可。</p>
<p>剩下的部分就很清晰了，on_message 回调函数在收到一个新的 tick 时，先将信息解码，枚举收到的所有改变；然后插入 orderbook，排序；最后连同 timestamp 一并输出即可。</p>
<p>虽然这段代码看起来挺长，但是经过我这么一分解，是不是发现都是学过的知识点呢？这也是我一再强调基础的原因，如果对你来说哪部分内容变得陌生了（比如面向对象编程的知识点），一定要记得及时往前复习，这样你学起新的更复杂的东西，才能轻松很多。</p>
<p>回到正题。刚刚的代码，主要是为了抓取 orderbook 的信息。事实上，Gemini 交易所在建立数据流 Websocket 的时候，第一条信息往往非常大，因为里面包含了那个时刻所有的 orderbook 信息。这就叫做初始数据。之后的消息，都是基于初始数据进行修改的，直接处理即可。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这节课我们继承上一节，从委托账本讲起，然后讲述了 WebSocket 的定义、工作机制和使用方法，最后以一个例子收尾，带你学会如何爬取 Orderbook 的信息。希望你在学习这节课的内容时，能够和上节课的内容联系起来，仔细思考 Websocket 和 RESTFul 的区别，并试着总结网络编程中不同模型的适用范围。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/03/34%20%7C%20RESTful%20&%20Socket%E6%90%AD%E5%BB%BA%E4%BA%A4%E6%98%93%E6%89%A7%E8%A1%8C%E5%B1%82%E6%A0%B8%E5%BF%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/03/34%20%7C%20RESTful%20&%20Socket%E6%90%AD%E5%BB%BA%E4%BA%A4%E6%98%93%E6%89%A7%E8%A1%8C%E5%B1%82%E6%A0%B8%E5%BF%83/" itemprop="url">34 | RESTful & Socket搭建交易执行层核心</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-03T20:10:07+08:00">
                2020-01-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/" itemprop="url" rel="index">
                    <span itemprop="name">python核心技术与实战</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/03/34%20%7C%20RESTful%20&%20Socket%E6%90%AD%E5%BB%BA%E4%BA%A4%E6%98%93%E6%89%A7%E8%A1%8C%E5%B1%82%E6%A0%B8%E5%BF%83/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/01/03/34%20%7C%20RESTful%20&%20Socket%E6%90%AD%E5%BB%BA%E4%BA%A4%E6%98%93%E6%89%A7%E8%A1%8C%E5%B1%82%E6%A0%B8%E5%BF%83/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>从这节课开始，我们将实打实地从代码出发，一步步设计出一套清晰完整、易于理解的量化交易系统。</p>
<p>一个量化交易系统，可以说是一个黑箱。这个黑箱连接交易所获取到的数据，通过策略运算，然后再连接交易所进行下单操作。正如我们在输入输出那节课说的那样，黑箱的特性是输入和输出。每一个设计网络交互的同学，都需要在大脑中形成清晰的交互状态图：</p>
<p>知道包是怎样在网络间传递的；<br>知道每一个节点是如何处理不同的输入包，然后输出并分发给下一级的。<br>在你搞不明白的时候，可以先在草稿纸上画出交互拓扑图，标注清楚每个节点的输入和输出格式，然后想清楚网络是怎么流动的。这一点，对网络编程至关重要。</p>
<p>现在，我假设你对网络编程只有很基本的了解。所以接下来，我将先从 REST 的定义讲起，然后过渡到具体的交互方式——如何通过 Python 和交易所进行交互，从而执行下单、撤单、查询订单等网络交互方式。</p>
<h3 id="REST-简介"><a href="#REST-简介" class="headerlink" title="REST 简介"></a>REST 简介</h3><p>什么是 REST API？什么是 Socket？有过网络编程经验的同学，一定对这两个词汇不陌生。</p>
<p>REST 的全称是表征层状态转移（REpresentational State Transfer），本意是指一种操作资源方法。不过，你不用纠结于这个绕口的名字。换种方式来说，REST 的实质可以理解为：通过 URL 定位资源，用 GET、POST、PUT、DELETE 等动词来描述操作。而满足 REST 要求的接口，就被称为 RESTful 的接口。</p>
<p>为了方便你更容易理解这些概念，这里我举个例子来类比。小明同学不是很聪明但很懂事，每天会在他的妈妈下班回来后给妈妈泡茶。刚开始，他的妈妈会发出这样的要求：</p>
<p>这里的“茶”就是资源，“厨房的茶”就是资源的地址（URI）；“泡”是动词；后面的要求，都是接口参数。这样的一个接口，就是小明提供的一个 REST 接口。</p>
<p>如果小明是一台机器，那么解析这个请求就会非常容易；而我们作为维护者，查看小明的代码也很简单。当小明把这个接口暴露到网上时，这就是一个 RESTful 的接口。</p>
<p>总的来说，RESTful 接口通常以 HTTP GET 和 POST 形式出现。但并非所有的 GET、POST 请求接口，都是 RESTful 的接口。</p>
<p>这话可能有些拗口，我们举个例子来看。上节课中，我们获取了 Gemini 交易所中，BTC 对 USD 价格的 ticker 接口：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET https://api.gemini.com/v1/pubticker/btcusd</span><br></pre></td></tr></table></figure>

<p>这里的“GET“是动词，后边的 URI 是“Ticker“这个资源的地址。所以，这是一个 RESTful 的接口。</p>
<p>但下面这样的接口，就不是一个严格的 RESTful 接口：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST https://api.restful.cn/accounts/delete/:username</span><br></pre></td></tr></table></figure>

<p>因为 URI 中包含动词“delete”（删除），所以这个 URI 并不是指向一个资源。如果要修改成严格的 RESTful 接口，我们可以把它改成下面这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE https://api.rest.cn/accounts/:username</span><br></pre></td></tr></table></figure>

<p>然后，我们带着这个观念去看 Gemini 的取消订单接口：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST https://api.gemini.com/v1/order/cancel</span><br></pre></td></tr></table></figure>

<p>注：Private API Invocation 的网址链接为<a href="https://docs.gemini.com/rest-api/#private-api-invocation" target="_blank" rel="noopener">https://docs.gemini.com/rest-api/#private-api-invocation</a></p>
<p>你会发现，这个接口不够“RESTful”的地方有：</p>
<ul>
<li>动词设计不准确，接口使用“POST”而不是重用 HTTP 动词“DELETE”；</li>
<li>URI 里包含动词 cancel；</li>
<li>ID 代表的订单是资源，但订单 ID 是放在参数列表而不是URI里的，因此 URI 并没有指向资源。</li>
</ul>
<p>所以严格来说，这不是一个 RESTful 的接口。</p>
<p>此外，如果我们去检查 Gemini 的其他私有接口（Private，私有接口是指需要附加身份验证信息才能访问的接口），我们会发现，那些接口的设计都不是严格 RESTful 的。不仅如此，大部分的交易所，比如 Bitmex、Bitfinex、OKCoin 等等，它们提供的“REST 接口”，也都不是严格 RESTful 的。这些接口之所以还能被称为“REST 接口”，是因为他们大部分满足了 REST 接口的另一个重要要求：无状态。</p>
<p>无状态的意思是，每个 REST 请求都是独立的，不需要服务器在会话（Session）中缓存中间状态来完成这个请求。简单来说，如果服务器 A 接收到请求的时候宕机了，而此时把这个请求发送给交易所的服务器 B，也能继续完成，那么这个接口就是无状态的。</p>
<p>这里，我再给你举一个简单的有状态的接口的例子。服务器要求，在客户端请求取消订单的时候，必须发送两次不一样的 HTTP 请求。并且，第一次发送让服务器“等待取消”；第二次发送“确认取消”。那么，就算这个接口满足了 RESTful 的动词、资源分离原则，也不是一个 REST 接口。</p>
<p>当然，对于交易所的 REST 接口，你并不需要过于纠结“RESTful”这个概念，否则很容易就被这些名词给绕晕了。你只需要把握住最核心的一点：一个 HTTP 请求完成一次完整操作。</p>
<h3 id="交易所-API-简介"><a href="#交易所-API-简介" class="headerlink" title="交易所 API 简介"></a>交易所 API 简介</h3><p>现在，你对 REST 和 Web Socket 应该有一个大致了解了吧。接下来，我们就开始做点有意思的事情。</p>
<p>首先，我来介绍一下交易所是什么。区块链交易所是个撮合交易平台： 它兼容了传统撮合规则撮合引擎，将资金托管和交割方式替换为区块链。数字资产交易所，则是一个中心化的平台，通过 Web 页面或 PC、手机客户端的形式，让用户将数字资产充值到指定钱包地址（交易所创建的钱包），然后在平台挂买单、卖单以实现数字资产之间的兑换。</p>
<p>通俗来说，交易所就是一个买和卖的菜市场。有人在摊位上大声喊着：“二斤羊肉啊，二斤羊肉，四斤牛肉来换！”这种人被称为 maker（挂单者）。有的人则游走于不同摊位，不动声色地掏出两斤牛肉，顺手拿走一斤羊肉。这种人被称为 taker（吃单者）。</p>
<p>交易所存在的意义，一方面是为 maker 和 taker 提供足够的空间活动；另一方面，让一个名叫撮合引擎的玩意儿，尽可能地把单子撮合在一起，然后收取一定比例的保护费…啊不对，是手续费，从而保障游戏继续进行下去。</p>
<p>市场显然是个很伟大的发明，这里我们就不进行更深入的哲学讨论了。</p>
<p>然后，我再来介绍一个叫做 Gemini 的交易所。Gemini，双子星交易所，全球首个获得合法经营许可的、首个推出期货合约的、专注于撮合大宗交易的数字货币交易所。Gemini 位于纽约，是一家数字货币交易所和托管机构，允许客户交易和存储数字资产，并直接受纽约州金融服务部门（NYDFS）的监管。</p>
<p>Gemini 的界面清晰，API 完整而易用，更重要的是，还提供了完整的测试网络，也就是说，功能和正常的 Gemini 完全一样。但是他家的交易采用虚拟币，非常方便从业者在平台上进行对接测试。</p>
<p>另一个做得很好的交易所，是 Bitmex，他家的 API UI 界面和测试网络也是币圈一流。不过，鉴于这家是期货交易所，对于量化初学者来说有一定的门槛，我们还是选择 Gemini 更方便一些。</p>
<p>在进入正题之前，我们最后再以比特币和美元之间的交易为例，介绍四个基本概念（orderbook 的概念这里就不介绍了，你也不用深究，你只需要知道比特币的价格是什么就行了）。</p>
<ul>
<li>买（buy）：用美元买入比特币的行为。</li>
<li>卖（sell）：用比特币换取美元的行为。</li>
<li>市价单（market order）：给交易所一个方向（买或者卖）和一个数量，交易所把给定数量的美元（或者比特币）换成比特币（或者美元）的单子。</li>
<li>限价单（limit order）：给交易所一个价格、一个方向（买或者卖）和一个数量，交易所在价格达到给定价格的时候，把给定数量的美元（或者比特币）换成比特币（或者美元）的单子。</li>
</ul>
<p>这几个概念都不难懂。其中，市价单和限价单，最大的区别在于，限价单多了一个给定价格。如何理解这一点呢？我们可以来看下面这个例子。</p>
<p>大宝在某一天中午 12:00:00，告诉交易所，我要用一千美元买比特币。交易所收到消息，在 12:00:01 回复小明，现在你的账户多了 0.099 个比特币，少了 1000 美元，交易成功。这是一个市价买单。</p>
<p>而小宝在某一天中午 11:59:00，告诉交易所，我要挂一个单子，数量为 0.1 比特币，价格为 1000 美元，低于这个价格不卖。交易所收到消息，在 11:59:01 告诉小强，挂单成功，你的账户余额中 0.1 比特币的资金被冻结。又过了一分钟，交易所告诉小强，你的单子被完全执行了（fully executed），现在你的账户多了 1000 美元，少了 0.1 个比特币。这就是一个限价卖单。</p>
<p>（这里肯定有人发现不对了：貌似少了一部分比特币，到底去哪儿了呢？嘿嘿，你不妨自己猜猜看。）</p>
<p>显然，市价单，在交给交易所后，会立刻得到执行，当然执行价格也并不受你的控制。它很快，但是也非常不安全。而限价单，则限定了交易价格和数量，安全性相对高很多。缺点呢，自然就是如果市场朝相反方向走，你挂的单子可能没有任何人去接，也就变成了干吆喝却没人买。因为我没有讲解 orderbook，所以这里的说辞不完全严谨，但是对于初学者理解今天的内容，已经够用了。</p>
<p>储备了这么久的基础知识，想必你已经跃跃欲试了吧？下面，我们正式进入正题，手把手教你使用 API 下单。</p>
<h3 id="手把手教你使用-API-下单"><a href="#手把手教你使用-API-下单" class="headerlink" title="手把手教你使用 API 下单"></a>手把手教你使用 API 下单</h3><p>手动挂单显然太慢，也不符合量化交易的初衷。我们就来看看如何用代码实现自动化下单吧。</p>
<p>第一步，你需要做的是，注册一个 Gemini Sandbox 账号。请放心，这个测试账号不需要你充值任何金额，注册后即送大量虚拟现金。这口吻是不是听着特像网游宣传语，接下来就是“快来贪玩蓝月里找我吧”？哈哈，不过这个设定确实如此，所以赶紧来注册一个吧。</p>
<p>注册后，为了满足好奇，你可以先尝试着使用 web 界面自行下单。不过，事实上，未解锁的情况下是无法正常下单的，因此这样尝试并没啥太大意义。</p>
<p>所以第二步，我们需要来配置 API Key。User Settings，API Settings，然后点 GENERATE A NEW ACCOUNT API KEY.，记下 Key 和 Secret 这两串字符。因为窗口一旦消失，这两个信息就再也找不到了，需要你重新生成。</p>
<p>配置到此结束。接下来，我们来看具体实现。</p>
<p>先强调一点，在量化系统开发的时候，你的心中一定要有清晰的数据流图。下单逻辑是一个很简单的 RESTful 的过程，和你在网页操作的一样，构造你的请求订单、加密请求，然后 post 给 gemini 交易所即可。</p>
<p>不过，因为涉及到的知识点较多，带你一步一步从零来写代码显然不太现实。所以，我们采用“先读懂后记忆并使用”的方法来学，下面即为这段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line">base_url = <span class="string">"https://api.sandbox.gemini.com"</span></span><br><span class="line">endpoint = <span class="string">"/v1/order/new"</span></span><br><span class="line">url = base_url + endpoint</span><br><span class="line"> </span><br><span class="line">gemini_api_key = <span class="string">"account-zmidXEwP72yLSSybXVvn"</span></span><br><span class="line">gemini_api_secret = <span class="string">"375b97HfE7E4tL8YaP3SJ239Pky9"</span>.encode()</span><br><span class="line"> </span><br><span class="line">t = datetime.datetime.now()</span><br><span class="line">payload_nonce = str(int(time.mktime(t.timetuple())*<span class="number">1000</span>))</span><br><span class="line"> </span><br><span class="line">payload = &#123;</span><br><span class="line">   <span class="string">"request"</span>: <span class="string">"/v1/order/new"</span>,</span><br><span class="line">   <span class="string">"nonce"</span>: payload_nonce,</span><br><span class="line">   <span class="string">"symbol"</span>: <span class="string">"btcusd"</span>,</span><br><span class="line">   <span class="string">"amount"</span>: <span class="string">"5"</span>,</span><br><span class="line">   <span class="string">"price"</span>: <span class="string">"3633.00"</span>,</span><br><span class="line">   <span class="string">"side"</span>: <span class="string">"buy"</span>,</span><br><span class="line">   <span class="string">"type"</span>: <span class="string">"exchange limit"</span>,</span><br><span class="line">   <span class="string">"options"</span>: [<span class="string">"maker-or-cancel"</span>]</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">encoded_payload = json.dumps(payload).encode()</span><br><span class="line">b64 = base64.b64encode(encoded_payload)</span><br><span class="line">signature = hmac.new(gemini_api_secret, b64, hashlib.sha384).hexdigest()</span><br><span class="line"> </span><br><span class="line">request_headers = &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">"text/plain"</span>,</span><br><span class="line">    <span class="string">'Content-Length'</span>: <span class="string">"0"</span>,</span><br><span class="line">    <span class="string">'X-GEMINI-APIKEY'</span>: gemini_api_key,</span><br><span class="line">    <span class="string">'X-GEMINI-PAYLOAD'</span>: b64,</span><br><span class="line">    <span class="string">'X-GEMINI-SIGNATURE'</span>: signature,</span><br><span class="line">    <span class="string">'Cache-Control'</span>: <span class="string">"no-cache"</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">response = requests.post(url,</span><br><span class="line">                         data=<span class="literal">None</span>,</span><br><span class="line">                         headers=request_headers)</span><br><span class="line"> </span><br><span class="line">new_order = response.json()</span><br><span class="line">print(new_order)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">########## 输出 ##########</span></span><br><span class="line"> </span><br><span class="line">&#123;<span class="string">'order_id'</span>: <span class="string">'239088767'</span>, <span class="string">'id'</span>: <span class="string">'239088767'</span>, <span class="string">'symbol'</span>: <span class="string">'btcusd'</span>, <span class="string">'exchange'</span>: <span class="string">'gemini'</span>, <span class="string">'avg_execution_price'</span>: <span class="string">'0.00'</span>, <span class="string">'side'</span>: <span class="string">'buy'</span>, <span class="string">'type'</span>: <span class="string">'exchange limit'</span>, <span class="string">'timestamp'</span>: <span class="string">'1561956976'</span>, <span class="string">'timestampms'</span>: <span class="number">1561956976535</span>, <span class="string">'is_live'</span>: <span class="literal">True</span>, <span class="string">'is_cancelled'</span>: <span class="literal">False</span>, <span class="string">'is_hidden'</span>: <span class="literal">False</span>, <span class="string">'was_forced'</span>: <span class="literal">False</span>, <span class="string">'executed_amount'</span>: <span class="string">'0'</span>, <span class="string">'remaining_amount'</span>: <span class="string">'5'</span>, <span class="string">'options'</span>: [<span class="string">'maker-or-cancel'</span>], <span class="string">'price'</span>: <span class="string">'3633.00'</span>, <span class="string">'original_amount'</span>: <span class="string">'5'</span>&#125;</span><br></pre></td></tr></table></figure>

<p>我们来深入看一下这段代码。</p>
<p>RESTful 的 POST 请求，通过 requests.post 来实现。post 接受三个参数，url、data 和 headers。</p>
<p>这里的 url 等价于 <a href="https://api.sandbox.gemini.com/v1/order/new，但是在代码中分两部分写。第一部分是交易所" target="_blank" rel="noopener">https://api.sandbox.gemini.com/v1/order/new，但是在代码中分两部分写。第一部分是交易所</a> API 地址；第二部分，以斜杠开头，用来表示统一的 API endpoint。我们也可以在其他交易所的 API 中看到类似的写法，两者连接在一起，就构成了最终的 url。</p>
<p>而接下来大段命令的目的，是为了构造 request_headers。</p>
<p>这里我简单说一下 HTTP request，这是互联网中基于 TCP 的基础协议。HTTP 协议是 Hyper Text Transfer Protocol（超文本传输协议）的缩写，用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。而 TCP（Transmission Control Protocol）则是面向连接的、可靠的、基于字节流的传输层通信协议。</p>
<p>多提一句，如果你开发网络程序，建议利用闲暇时间认真读一读《计算机网络：自顶向下方法》这本书，它也是国内外计算机专业必修课中广泛采用的课本之一。一边学习，一边应用，对于初学者的能力提升是全面而充分的。</p>
<p>回到 HTTP，它的主要特点是，连接简单、灵活，可以使用“简单请求，收到回复，然后断开连接”的方式，也是一种无状态的协议，因此充分符合 RESTful 的思想。</p>
<p>HTTP 发送需要一个请求头（request header），也就是代码中的 request_headers，用 Python 的语言表示，就是一个 str 对 str 的字典。</p>
<p>这个字典里，有一些字段有特殊用途， ‘Content-Type’: “text/plain” 和 ‘Content-Length’: “0” 描述 Content 的类型和长度，这里的 Content 对应于参数 data。但是 Gemini 这里的 request 的 data 没有任何用处，因此长度为 0。</p>
<p>还有一些其他字段，例如 ‘keep-alive’ 来表示连接是否可持续化等，你也可以适当注意一下。要知道，网络编程很多 bug 都会出现在不起眼的细节之处。</p>
<p>继续往下走看代码。payload 是一个很重要的字典，它用来存储下单操作需要的所有的信息，也就是业务逻辑信息。这里我们可以下一个 limit buy，限价买单，价格为 3633 刀。</p>
<p>另外，请注意 nonce，这是个很关键并且在网络通信中很常见的字段。</p>
<p>因为网络通信是不可靠的，一个信息包有可能会丢失，也有可能重复发送，在金融操作中，这两者都会造成很严重的后果。丢包的话，我们重新发送就行了；但是重复的包，我们需要去重。虽然 TCP 在某种程度上可以保证，但为了在应用层面进一步减少错误发生的机会，Gemini 交易所要求所有的通信 payload 必须带有 nonce。</p>
<p>nonce 是个单调递增的整数。当某个后来的请求的 nonce，比上一个成功收到的请求的 nouce 小或者相等的时候，Gemini 便会拒绝这次请求。这样一来，重复的包就不会被执行两次了。另一方面，这样也可以在一定程度上防止中间人攻击：</p>
<ul>
<li>一则是因为 nonce 的加入，使得加密后的同样订单的加密文本完全混乱；</li>
<li>二则是因为，这会使得中间人无法通过“发送同样的包来构造重复订单“进行攻击。</li>
</ul>
<p>这样的设计思路是不是很巧妙呢？这就相当于每个包都增加了一个身份识别，可以极大地提高安全性。希望你也可以多注意，多思考一下这些巧妙的用法。</p>
<p>接下来的代码就很清晰了。我们要对 payload 进行 base64 和 sha384 算法非对称加密，其中 gemini_api_secret 为私钥；而交易所存储着公钥，可以对你发送的请求进行解密。最后，代码再将加密后的请求封装到 request_headers 中，发送给交易所，并收到 response，这个订单就完成了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这节课我们介绍了什么是 RESTFul API，带你了解了交易所的 RESTFul API 是如何工作的，以及如何通过 RESTFul API 来下单。同时，我简单讲述了网络编程中的一些技巧操作，希望你在网络编程中要注意思考每一个细节，尽可能在写代码之前，对业务逻辑和具体的技术细节有足够清晰的认识。</p>
<p>下一节，我们同样将从 Web Socket 的定义开始，讲解量化交易中数据模块的具体实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/02/33%20%7C%20%E5%B8%A6%E4%BD%A0%E5%88%9D%E6%8E%A2%E9%87%8F%E5%8C%96%E4%B8%96%E7%95%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/02/33%20%7C%20%E5%B8%A6%E4%BD%A0%E5%88%9D%E6%8E%A2%E9%87%8F%E5%8C%96%E4%B8%96%E7%95%8C/" itemprop="url">33 | 带你初探量化世界</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-02T20:10:07+08:00">
                2020-01-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/" itemprop="url" rel="index">
                    <span itemprop="name">python核心技术与实战</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/02/33%20%7C%20%E5%B8%A6%E4%BD%A0%E5%88%9D%E6%8E%A2%E9%87%8F%E5%8C%96%E4%B8%96%E7%95%8C/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/01/02/33%20%7C%20%E5%B8%A6%E4%BD%A0%E5%88%9D%E6%8E%A2%E9%87%8F%E5%8C%96%E4%B8%96%E7%95%8C/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="交易是什么？"><a href="#交易是什么？" class="headerlink" title="交易是什么？"></a>交易是什么？</h3><p>市场，是人类有史以来最伟大的发明之一。亚当斯在国富论中，用“看不见的手”这个概念，生动形象地阐释了市场和理性人之间是如何交互，最终让整个社会受益的。</p>
<p>而市场的核心，是交换。人类发展最开始是物物交换，原始的“以物易物”的方式产生于货币诞生之前。不过，这种方式非常低效，不便于流通交换，经常会出现的情况是，要走很长的交换链条才能拿到自己想要的物品。于是，一般等价物出现了，社会分工也逐渐出现了。人们把自己生产的商品换成一般等价物，然后再换成自己需要的其他商品。</p>
<p>而交换的核心，就是买和卖。当买卖双方对价格预期相等的时候，交易达成。随着金融和技术的发展，逐渐出现了股票、债券、期权、期货等越来越多的金融工具，金融衍生品也朝着复杂的方向发展。</p>
<p>在我们经常听到的投资银行中，量化基金交易员这种角色，所做的事情，就是在这些复杂的衍生品基础上，分析投资标的的价值，然后以某种策略来管理持有仓位，进行买进和卖出。</p>
<p>为什么交易能赚钱，是很多疑惑不解的地方。市场究竟有没有规律可循呢？可以肯定是有的，但虽有迹可循却无法可依。交易的多样性和人性的复杂性，使得金融数据的噪音极大，我们无法简单地从某一两个因子来确定地推导行情变化。</p>
<p>所以交易员这个行业本身，对自身素质要求是极高的。除了要具备扎实的专业素养（包括金融功底、数理逻辑、分析能力、决策能力），对心理素质的要求也非常高。这种直接和钱打交道、并直面人性深处欲望的行业，也因此吸引了无数高手的参与，很多人因此暴富，也有不少人破产，一无所有。</p>
<p>那么，有什么办法可以规避这种，因为心理素质原因带来的风险呢？</p>
<h3 id="量化交易"><a href="#量化交易" class="headerlink" title="量化交易"></a>量化交易</h3><p>回答这个问题之前，我先插一句题外话。刚接触量化交易的朋友，都很容易被这几个词绕晕：量化交易（Quantative Trading）、程序化交易（Program Trading）、算法交易（Algo-Trading）、高频交易（High Frequency Trading）和自动化交易平台（Automated Trading System）。</p>
<p>虽然我遇到过不少行业内的人也混用这词，但是作为初学者来说，厘清这些术语还是很有帮助的。至少，在别人说出这些高大上的词时，我们心里不用犯怵了。</p>
<p>先来看程序化交易，它通常用计算机程序代替交易员，来具体执行金融产品的买卖。比如，一个基金经理需要卖出大量股票。如果直接挂一个大的卖单，可能会影响市场，那就用计算机程序拆分成小单慢慢执行。所以，量化交易的下层通常是程序交易。</p>
<p>而算法交易通常用于高频交易中。它指的是，通过算法快速判定买卖的时间点，快速买卖多个产品。</p>
<p>量化交易则通常是指使用数学、统计甚至机器学习的方法，去找寻合适的买卖时机。所以，在这个维度的定义之下，算法交易、高频交易还有统计套利（Statistical Arbitrage）都可以算作量化交易。</p>
<p>简单而言，我们可以认为量化交易的涵盖范围最大。因此，当你不确定用哪个词的时候，用量化交易就行了。</p>
<p>回到我们刚刚的问题，规避心理素质原因带来的风险的方法，自然就是量化交易了。量化交易的好处显而易见。最直观来看，计算机不眠不休，不需要交易员实时操盘，满足了人们“躺着挣钱”的愿景。当然，这只是美好的想象，真要这么做的话，不久之后就要回工地搬砖了。现实场景中，成熟的量化交易也需要有人蹲守，适时干预，防止算法突然失效造成巨额的交易亏损。</p>
<p>在数字货币领域的交易，这一点更加显著。数字货币的交易在全球许多交易所进行，和股票不同，一支股票可能只在少数几个交易所交易，而一种数字货币可以在所有的交易所同时进行交易。同时，因为没有股市的开盘、收盘限制，数字货币的交易通常是 7 x 24 小时不眠不休，比前世的 “996 福报”凶残多了。要是真有交易员能在这个市场活下来，我们尊称一声“神仙”也不为过了。</p>
<p>多交易所交易，也意味着全球数字货币市场每时每刻都是紧密相连的。一个市场、一个局部的巨大变动，都会影响所有的市场。比如，2017 年朝鲜氢弹炸了的当天，新闻还没出来，隔壁韩国、日本的比特币价格马上拉升了一波；再比如，当比特币的负面消息半夜里传出来的时候，其价格也马上跟着暴跌一波。</p>
<p>因此，我们经常看到比特币的价格波动巨大。很有可能今天还是财富自由状态，明天的财富就没那么自由了。显然，在这种市场中交易，人力很难持久支撑，而量化交易就很合适了。</p>
<p>通常的电子盘交易（比如股票，数字货币），是通过券商或者软件，直接把买卖请求发送给交易所；而算法交易的底层，就是让程序来自动实现这类操作。券商或者交易所，通常也会提供 API 接口给投资者。比如，盈透证券（Interactive Broker）的接口，就可以支持股票、期权的行情数据获取和交易；而 Gemini、OKCoin 等交易所，也提供了对应的接口进行数字货币行情获取和交易。</p>
<p>Gemini 交易所的公开行情 API，就可以通过下面这种简单的 HTTP GET 请求，来获取最近的比特币（BTC）对美元（USD）的价格和最近的成交量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">########## GEMINI 行情接口 ##########</span></span><br><span class="line"><span class="comment">## https://api.gemini.com/v1/pubticker/:symbol</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"> </span><br><span class="line">gemini_ticker = <span class="string">'https://api.gemini.com/v1/pubticker/&#123;&#125;'</span></span><br><span class="line">symbol = <span class="string">'btcusd'</span></span><br><span class="line">btc_data = requests.get(gemini_ticker.format(symbol)).json()</span><br><span class="line">print(json.dumps(btc_data, indent=<span class="number">4</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment">########## 输出 ##########</span></span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"bid"</span>: <span class="string">"8825.88"</span>,</span><br><span class="line">   <span class="string">"ask"</span>: <span class="string">"8827.52"</span>,</span><br><span class="line">   <span class="string">"volume"</span>: &#123;</span><br><span class="line">       <span class="string">"BTC"</span>: <span class="string">"910.0838782726"</span>,</span><br><span class="line">       <span class="string">"USD"</span>: <span class="string">"7972904.560901317851"</span>,</span><br><span class="line">       <span class="string">"timestamp"</span>: <span class="number">1560643800000</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">"last"</span>: <span class="string">"8838.45"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>{
    &quot;bid&quot;: &quot;7128.73&quot;,
    &quot;ask&quot;: &quot;7132.64&quot;,
    &quot;volume&quot;: {
        &quot;BTC&quot;: &quot;414.0110753682&quot;,
        &quot;USD&quot;: &quot;2968817.768948525139&quot;,
        &quot;timestamp&quot;: 1577966400000
    },
    &quot;last&quot;: &quot;7128.73&quot;
}





{&apos;bid&apos;: &apos;8825.88&apos;,
 &apos;ask&apos;: &apos;8827.52&apos;,
 &apos;volume&apos;: {&apos;BTC&apos;: &apos;910.0838782726&apos;,
  &apos;USD&apos;: &apos;7972904.560901317851&apos;,
  &apos;timestamp&apos;: 1560643800000},
 &apos;last&apos;: &apos;8838.45&apos;}</code></pre><p>其中，</p>
<p>行情模块的主要功能是，尝试获取市场的行情数据，通常也负责获取交易账户的状态。<br>策略模块的主要功能是，订阅市场的数据，根据设定的算法发出买、卖指令给执行模块。<br>执行模块的主要功能是，接受并把策略模块发过来的买、卖指令封装并转发到交易所；同时，监督并确保策略买卖的完整执行。</p>
<h3 id="Python-算法交易"><a href="#Python-算法交易" class="headerlink" title="Python 算法交易"></a>Python 算法交易</h3><p>了解了这么多关于量化交易的知识，接下来我们就来说说 Python 算法交易。Python 在金融行业的许多方面都有用到，在算法交易领域，更是发挥了日益重要的作用。 Python 之所以能在这个行业这么流行，主要是因为下面四个原因。</p>
<h3 id="数据分析能力"><a href="#数据分析能力" class="headerlink" title="数据分析能力"></a>数据分析能力</h3><p>第一个原因，是 Python 的数据分析能力。算法交易领域的一个基本需求，就是高效数据处理能力，而数据处理则是 Python 的强项。特别是 NumPy+Pandas 的组合，简直让算法交易开发者的生活质量直线上升。</p>
<p>我们可以用一个简单的例子来展示一下，如何抓取、格式化和绘制，比特币过去一个小时在 Genimi 交易所的价格曲线。相关的代码我都附了详细注释，这里就不再多讲，你阅读了解一下即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 选择要获取的数据时间段</span></span><br><span class="line">periods = <span class="string">'3600'</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 通过 Http 抓取 btc 历史价格数据</span></span><br><span class="line">resp = requests.get(<span class="string">'https://api.cryptowat.ch/markets/gemini/btcusd/ohlc'</span>, </span><br><span class="line">  params=&#123;</span><br><span class="line">    <span class="string">'periods'</span>: periods</span><br><span class="line">  &#125;)</span><br><span class="line">data = resp.json()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 转换成 pandas data frame</span></span><br><span class="line">df = pd.DataFrame(</span><br><span class="line">  data[<span class="string">'result'</span>][periods], </span><br><span class="line">  columns=[</span><br><span class="line">    <span class="string">'CloseTime'</span>,</span><br><span class="line">    <span class="string">'OpenPrice'</span>,</span><br><span class="line">    <span class="string">'HighPrice'</span>,</span><br><span class="line">    <span class="string">'LowPrice'</span>,</span><br><span class="line">    <span class="string">'ClosePrice'</span>,</span><br><span class="line">    <span class="string">'Volume'</span>,</span><br><span class="line">    <span class="string">'NA'</span>])</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出 DataFrame 的头部几行</span></span><br><span class="line">print(df.head())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 绘制 btc 价格曲线</span></span><br><span class="line">df[<span class="string">'ClosePrice'</span>].plot(figsize=(<span class="number">14</span>, <span class="number">7</span>))</span><br></pre></td></tr></table></figure>

<pre><code>    CloseTime  OpenPrice  HighPrice  LowPrice  ClosePrice     Volume  \
0  1576166400    7159.70    7186.04   7144.03     7182.77  34.414275   
1  1576170000    7188.04    7208.56   7172.29     7195.71  43.790080   
2  1576173600    7195.71    7205.00   7190.00     7193.62  25.884217   
3  1576177200    7192.38    7218.69   7183.42     7207.21  35.922896   
4  1576180800    7210.00    7210.31   7188.56     7198.78  19.583916   

              NA  
0  246447.854569  
1  314855.561069  
2  186355.827725  
3  258405.637212  
4  140999.123537  





&lt;matplotlib.axes._subplots.AxesSubplot at 0x11c942c88&gt;</code></pre><h3 id="大量专有库"><a href="#大量专有库" class="headerlink" title="大量专有库"></a>大量专有库</h3><p>除了强大的数据处理能力之外，Python 还有许许多多已经开发成熟的算法交易库可供使用。比如，你可以使用 Zipline 进行策略回测，或者用 Pyfolio 进行投资组合分析。而许多交易所也都提供了基于 Python 的 API 客户端。</p>
<p>便利的交易平台<br>第三个原因，是因为便利的交易平台。有一些算法交易平台可以执行自定义 Python 策略，无需搭建量化交易框架。算法交易平台，实际上等效于帮用户完成了行情模块和执行模块。用户只需要在其中定义策略模块，即可进行算法交易和回测。</p>
<p>比如，Quantopian，就提供了基于 Zipline 的标准回测环境。用户可以选择 Python 作为开发语言，并且和社区的网友分享自己的策略。此外，国内也有诸如 BigQuant、果仁网等类似平台，提供不同市场和金融产品的交易。</p>
<p>广泛的行业应用<br>最后一个原因，则是 Python 本身广泛的行业应用了。目前，越来越多投资机构的交易部门，都开始使用 Python，因此也对优秀的 Python 开发者产生了更多的需求。自然，这也让学习 Python，成为了更有意义的“投资”。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这一节课，我们介绍了交易，以及算法交易中的基本概念，也简单介绍了为什么要学习 Python 来搭建量化交易系统。量化交易是交易行业的大趋势；同时， Python 作为最适合量化从业者的语言之一，对于初学者而言也有着非常重要的地位。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/25/2-Python%20%E5%B7%A5%E5%8C%A0%EF%BC%9A%E7%BC%96%E5%86%99%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/25/2-Python%20%E5%B7%A5%E5%8C%A0%EF%BC%9A%E7%BC%96%E5%86%99%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8A%80%E5%B7%A7/" itemprop="url">Python 工匠：2-编写条件分支代码的技巧</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-25T20:10:07+08:00">
                2019-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python%E5%B7%A5%E5%8C%A0/" itemprop="url" rel="index">
                    <span itemprop="name">Python工匠</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/25/2-Python%20%E5%B7%A5%E5%8C%A0%EF%BC%9A%E7%BC%96%E5%86%99%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8A%80%E5%B7%A7/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/12/25/2-Python%20%E5%B7%A5%E5%8C%A0%EF%BC%9A%E7%BC%96%E5%86%99%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8A%80%E5%B7%A7/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Python-工匠：编写条件分支代码的技巧"><a href="#Python-工匠：编写条件分支代码的技巧" class="headerlink" title="Python 工匠：编写条件分支代码的技巧"></a>Python 工匠：编写条件分支代码的技巧</h1><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><blockquote>
<p>这是 “Python 工匠”系列的第 2 篇文章。<a href="https://github.com/piglei/one-python-craftsman" target="_blank" rel="noopener">[查看系列所有文章]</a></p>
</blockquote>
<p>编写条件分支代码是编码过程中不可或缺的一部分。</p>
<p>如果用道路来做比喻，现实世界中的代码从来都不是一条笔直的高速公路，而更像是由无数个岔路口组成的某个市区地图。我们编码者就像是驾驶员，需要告诉我们的程序，下个路口需要往左还是往右。</p>
<p>编写优秀的条件分支代码非常重要，因为糟糕、复杂的分支处理非常容易让人困惑，从而降低代码质量。所以，这篇文章将会种重点谈谈在 Python 中编写分支代码应该注意的地方。</p>
<h3 id="内容目录"><a href="#内容目录" class="headerlink" title="内容目录"></a>内容目录</h3><ul>
<li><a href="#最佳实践">最佳实践</a><ul>
<li><a href="#1-避免多层分支嵌套">1. 避免多层分支嵌套</a></li>
<li><a href="#2-封装那些过于复杂的逻辑判断">2. 封装那些过于复杂的逻辑判断</a></li>
<li><a href="#3-留意不同分支下的重复代码">3. 留意不同分支下的重复代码</a></li>
<li><a href="#4-谨慎使用三元表达式">4. 谨慎使用三元表达式</a></li>
</ul>
</li>
<li><a href="#常见技巧">常见技巧</a><ul>
<li><a href="#1-使用德摩根定律">1. 使用“德摩根定律”</a></li>
<li><a href="#2-自定义对象的布尔真假">2. 自定义对象的“布尔真假”</a></li>
<li><a href="#3-在条件判断中使用-all--any">3. 在条件判断中使用 all() / any()</a></li>
<li><a href="#4-使用-trywhilefor-中-else-分支">4. 使用 try/while/for 中 else 分支</a></li>
</ul>
</li>
<li><a href="#常见陷阱">常见陷阱</a><ul>
<li><a href="#1-与-none-值的比较">1. 与 None 值的比较</a></li>
<li><a href="#2-留意-and-和-or-的运算优先级">2. 留意 and 和 or 的运算优先级</a></li>
</ul>
</li>
<li><a href="#结语">结语</a></li>
<li><a href="#注解">注解</a></li>
</ul>
<h3 id="Python-里的分支代码"><a href="#Python-里的分支代码" class="headerlink" title="Python 里的分支代码"></a>Python 里的分支代码</h3><p>Python 支持最为常见的 <code>if/else</code> 条件分支语句，不过它缺少在其他编程语言中常见的 <code>switch/case</code> 语句。</p>
<p>除此之外，Python 还为 <code>for/while</code> 循环以及 <code>try/except</code> 语句提供了 else 分支，在一些特殊的场景下，它们可以大显身手。</p>
<p>下面我会从 <code>最佳实践</code>、<code>常见技巧</code>、<code>常见陷阱</code> 三个方面讲一下如果编写优秀的条件分支代码。</p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="1-避免多层分支嵌套"><a href="#1-避免多层分支嵌套" class="headerlink" title="1. 避免多层分支嵌套"></a>1. 避免多层分支嵌套</h3><p>如果这篇文章只能删减成一句话就结束，那么那句话一定是<strong>“要竭尽所能的避免分支嵌套”</strong>。</p>
<p>过深的分支嵌套是很多编程新手最容易犯的错误之一。假如有一位新手 JavaScript 程序员写了很多层分支嵌套，那么你可能会看到一层又一层的大括号：<code>if { if { if { ... }}}</code>。俗称<em>“嵌套 if 地狱（Nested If Statement Hell）”</em>。</p>
<p>但是因为 Python 使用了缩进来代替 <code>{}</code>，所以过深的嵌套分支会产生比其他语言下更为严重的后果。比如过多的缩进层次很容易就会让代码超过 <a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">PEP8</a> 中规定的每行字数限制。让我们看看这段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buy_fruit</span><span class="params">(nerd, store)</span>:</span></span><br><span class="line">    <span class="string">"""去水果店买苹果</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    - 先得看看店是不是在营业</span></span><br><span class="line"><span class="string">    - 如果有苹果的话，就买 1 个</span></span><br><span class="line"><span class="string">    - 如果钱不够，就回家取钱再来</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> store.is_open():</span><br><span class="line">        <span class="keyword">if</span> store.has_stocks(<span class="string">"apple"</span>):</span><br><span class="line">            <span class="keyword">if</span> nerd.can_afford(store.price(<span class="string">"apple"</span>, amount=<span class="number">1</span>)):</span><br><span class="line">                nerd.buy(store, <span class="string">"apple"</span>, amount=<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nerd.go_home_and_get_money()</span><br><span class="line">                <span class="keyword">return</span> buy_fruit(nerd, store)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> MadAtNoFruit(<span class="string">"no apple in store!"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> MadAtNoFruit(<span class="string">"store is closed!"</span>)</span><br></pre></td></tr></table></figure>

<p>上面这段代码最大的问题，就是过于直接翻译了原始的条件分支要求，导致短短十几行代码包含了有三层嵌套分支。</p>
<p>这样的代码可读性和维护性都很差。不过我们可以用一个很简单的技巧：<strong>“提前结束”</strong> 来优化这段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buy_fruit</span><span class="params">(nerd, store)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> store.is_open():</span><br><span class="line">        <span class="keyword">raise</span> MadAtNoFruit(<span class="string">"store is closed!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> store.has_stocks(<span class="string">"apple"</span>):</span><br><span class="line">        <span class="keyword">raise</span> MadAtNoFruit(<span class="string">"no apple in store!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> nerd.can_afford(store.price(<span class="string">"apple"</span>, amount=<span class="number">1</span>)):</span><br><span class="line">        nerd.buy(store, <span class="string">"apple"</span>, amount=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        nerd.go_home_and_get_money()</span><br><span class="line">        <span class="keyword">return</span> buy_fruit(nerd, store)</span><br></pre></td></tr></table></figure>

<p>“提前结束”指：<strong>在函数内使用 <code>return</code> 或 <code>raise</code> 等语句提前在分支内结束函数。</strong>比如，在新的 <code>buy_fruit</code> 函数里，当分支条件不满足时，我们直接抛出异常，结束这段这代码分支。这样的代码没有嵌套分支，更直接也更易读。</p>
<h3 id="2-封装那些过于复杂的逻辑判断"><a href="#2-封装那些过于复杂的逻辑判断" class="headerlink" title="2. 封装那些过于复杂的逻辑判断"></a>2. 封装那些过于复杂的逻辑判断</h3><p>如果条件分支里的表达式过于复杂，出现了太多的 <code>not/and/or</code>，那么这段代码的可读性就会大打折扣，比如下面这段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果活动还在开放，并且活动剩余名额大于 10，为所有性别为女性，或者级别大于 3</span></span><br><span class="line"><span class="comment"># 的活跃用户发放 10000 个金币</span></span><br><span class="line"><span class="keyword">if</span> activity.is_active <span class="keyword">and</span> activity.remaining &gt; <span class="number">10</span> <span class="keyword">and</span> \</span><br><span class="line">        user.is_active <span class="keyword">and</span> (user.sex == <span class="string">'female'</span> <span class="keyword">or</span> user.level &gt; <span class="number">3</span>):</span><br><span class="line">    user.add_coins(<span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>对于这样的代码，我们可以考虑将具体的分支逻辑封装成函数或者方法，来达到简化代码的目的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> activity.allow_new_user() <span class="keyword">and</span> user.match_activity_condition():</span><br><span class="line">    user.add_coins(<span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>事实上，将代码改写后，之前的注释文字其实也可以去掉了。<strong>因为后面这段代码已经达到了自说明的目的。</strong>至于具体的 <em>什么样的用户满足活动条件？</em> 这种问题，就应由具体的 <code>match_activity_condition()</code> 方法来回答了。</p>
<blockquote>
<p><strong>Hint:</strong> 恰当的封装不光直接改善了代码的可读性，事实上，如果上面的活动判断逻辑在代码中出现了不止一次的话，封装更是必须的。不然重复代码会极大的破坏这段逻辑的可维护性。</p>
</blockquote>
<h3 id="3-留意不同分支下的重复代码"><a href="#3-留意不同分支下的重复代码" class="headerlink" title="3. 留意不同分支下的重复代码"></a>3. 留意不同分支下的重复代码</h3><p>重复代码是代码质量的天敌，而条件分支语句又非常容易成为重复代码的重灾区。所以，当我们编写条件分支语句时，需要特别留意，不要生产不必要的重复代码。</p>
<p>让我们看下这个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于新用户，创建新的用户资料，否则更新旧资料</span></span><br><span class="line"><span class="keyword">if</span> user.no_profile_exists:</span><br><span class="line">    create_user_profile(</span><br><span class="line">        username=user.username,</span><br><span class="line">        email=user.email,</span><br><span class="line">        age=user.age,</span><br><span class="line">        address=user.address,</span><br><span class="line">        <span class="comment"># 对于新建用户，将用户的积分置为 0</span></span><br><span class="line">        points=<span class="number">0</span>,</span><br><span class="line">        created=now(),</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    update_user_profile(</span><br><span class="line">        username=user.username,</span><br><span class="line">        email=user.email,</span><br><span class="line">        age=user.age,</span><br><span class="line">        address=user.address,</span><br><span class="line">        updated=now(),</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们可以一眼看出，在不同的分支下，程序调用了不同的函数，做了不一样的事情。但是，因为那些重复代码的存在，<strong>我们却很难简单的区分出，二者的不同点到底在哪。</strong></p>
<p>其实，得益于 Python 的动态特性，我们可以简单的改写一下上面的代码，让可读性可以得到显著的提升：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> user.no_profile_exists:</span><br><span class="line">    profile_func = create_user_profile</span><br><span class="line">    extra_args = &#123;<span class="string">'points'</span>: <span class="number">0</span>, <span class="string">'created'</span>: now()&#125;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    profile_func = update_user_profile</span><br><span class="line">    extra_args = &#123;<span class="string">'updated'</span>: now()&#125;</span><br><span class="line"></span><br><span class="line">profile_func(</span><br><span class="line">    username=user.username,</span><br><span class="line">    email=user.email,</span><br><span class="line">    age=user.age,</span><br><span class="line">    address=user.address,</span><br><span class="line">    **extra_args</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>当你编写分支代码时，请额外关注<strong>由分支产生的重复代码块</strong>，如果可以简单的消灭它们，那就不要迟疑。</p>
<h3 id="4-谨慎使用三元表达式"><a href="#4-谨慎使用三元表达式" class="headerlink" title="4. 谨慎使用三元表达式"></a>4. 谨慎使用三元表达式</h3><p>三元表达式是 Python 2.5 版本后才支持的语法。在那之前，Python 社区一度认为三元表达式没有必要，我们需要使用 <code>x and a or b</code> 的方式来模拟它。<a href="#annot1">[注]</a></p>
<p>事实是，在很多情况下，使用普通的 <code>if/else</code> 语句的代码可读性确实更好。盲目追求三元表达式很容易诱惑你写出复杂、可读性差的代码。</p>
<p>所以，请记得只用三元表达式处理简单的逻辑分支。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">language = <span class="string">"python"</span> <span class="keyword">if</span> you.favor(<span class="string">"dynamic"</span>) <span class="keyword">else</span> <span class="string">"golang"</span></span><br></pre></td></tr></table></figure>

<p>对于绝大多数情况，还是使用普通的 <code>if/else</code> 语句吧。</p>
<h2 id="常见技巧"><a href="#常见技巧" class="headerlink" title="常见技巧"></a>常见技巧</h2><h3 id="1-使用“德摩根定律”"><a href="#1-使用“德摩根定律”" class="headerlink" title="1. 使用“德摩根定律”"></a>1. 使用“德摩根定律”</h3><p>在做分支判断时，我们有时候会写成这样的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果用户没有登录或者用户没有使用 chrome，拒绝提供服务</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> user.has_logged_in <span class="keyword">or</span> <span class="keyword">not</span> user.is_from_chrome:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"our service is only available for chrome logged in user"</span></span><br></pre></td></tr></table></figure>

<p>第一眼看到代码时，是不是需要思考一会才能理解它想干嘛？这是因为上面的逻辑表达式里面出现了 2 个 <code>not</code> 和 1 个 <code>or</code>。而我们人类恰好不擅长处理过多的“否定”以及“或”这种逻辑关系。</p>
<p>这个时候，就该 <a href="https://zh.wikipedia.org/wiki/%E5%BE%B7%E6%91%A9%E6%A0%B9%E5%AE%9A%E5%BE%8B" target="_blank" rel="noopener">德摩根定律</a> 出场了。通俗的说，德摩根定律就是 <code>not A or not B</code> 等价于 <code>not (A and B)</code>。通过这样的转换，上面的代码可以改写成这样：</p>
<p>if not (user.has_logged_in and user.is_from_chrome):<br>    return “our service is only available for chrome logged in user”</p>
<p>怎么样，代码是不是易读了很多？记住德摩根定律，很多时候它对于简化条件分支里的代码逻辑非常有用。</p>
<h3 id="2-自定义对象的“布尔真假”"><a href="#2-自定义对象的“布尔真假”" class="headerlink" title="2. 自定义对象的“布尔真假”"></a>2. 自定义对象的“布尔真假”</h3><p>我们常说，在 Python 里，“万物皆对象”。其实，不光“万物皆对象”，我们还可以利用很多魔法方法<em>（文档中称为：<a href="https://docs.python.org/3/reference/datamodel.html" target="_blank" rel="noopener">user-defined method</a>）</em>，来自定义对象的各种行为。我们可以用很多在别的语言里面无法做到、有些魔法的方式来影响代码的执行。</p>
<p>比如，Python 的所有对象都有自己的“布尔真假”：</p>
<ul>
<li>布尔值为假的对象：<code>None</code>, <code>0</code>, <code>False</code>, <code>[]</code>, <code>()</code>, <code>{}</code>, <code>set()</code>, <code>frozenset()</code>, … …</li>
<li>布尔值为真的对象：非 <code>0</code> 的数值、<code>True</code>，非空的序列、元组，普通的用户类实例，… …</li>
</ul>
<p>通过内建函数 <code>bool()</code>，你可以很方便的查看某个对象的布尔真假。而 Python 进行条件分支判断时用到的也是这个值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool(object())</span><br></pre></td></tr></table></figure>




<pre><code>True</code></pre><p>重点来了，虽然所有用户类实例的布尔值都是真。但是 Python 提供了改变这个行为的办法：<strong>自定义类的 <code>__bool__</code> 魔法方法</strong> <em>（在 Python 2.X 版本中为 <code>__nonzero__</code>）</em>。当类定义了 <code>__bool__</code> 方法后，它的返回值将会被当作类实例的布尔值。</p>
<p>另外，<code>__bool__</code> 不是影响实例布尔真假的唯一方法。如果类没有定义 <code>__bool__</code> 方法，Python 还会尝试调用 <code>__len__</code> 方法<em>（也就是对任何序列对象调用 <code>len</code> 函数）</em>，通过结果是否为 <code>0</code> 判断实例真假。</p>
<p>那么这个特性有什么用呢？看看下面这段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserCollection</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, users)</span>:</span></span><br><span class="line">        self._users = users</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">users = UserCollection([piglei, raymond])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(users._users) &gt; <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">"There's some users in collection!"</span>)</span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

NameError                                 Traceback (most recent call last)

&lt;ipython-input-4-057c2af4e558&gt; in &lt;module&gt;
      5 
      6 
----&gt; 7 users = UserCollection([piglei, raymond])
      8 
      9 if len(users._users) &gt; 0:


NameError: name &apos;piglei&apos; is not defined</code></pre><p>上面的代码里，判断 <code>UserCollection</code> 是否有内容时用到了 <code>users._users</code> 的长度。其实，通过为 <code>UserCollection</code> 添加 <code>__len__</code> 魔法方法，上面的分支可以变得更简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserCollection</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, users)</span>:</span></span><br><span class="line">        self._users = users</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._users)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">users = UserCollection([piglei, raymond])</span><br><span class="line"><span class="comment"># 定义了 __len__ 方法后，UserCollection 对象本身就可以被用于布尔判断了</span></span><br><span class="line"><span class="keyword">if</span> users:</span><br><span class="line">    print(<span class="string">"There's some users in collection!"</span>)</span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

NameError                                 Traceback (most recent call last)

&lt;ipython-input-6-6468765412e2&gt; in &lt;module&gt;
      8 
      9 
---&gt; 10 users = UserCollection([piglei, raymond])
     11 # 定义了 __len__ 方法后，UserCollection 对象本身就可以被用于布尔判断了
     12 if users:


NameError: name &apos;piglei&apos; is not defined</code></pre><p>通过定义魔法方法 <code>__len__</code> 和 <code>__bool__</code> ，我们可以让类自己控制想要表现出的布尔真假值，让代码变得更 pythonic。</p>
<h3 id="3-在条件判断中使用-all-any"><a href="#3-在条件判断中使用-all-any" class="headerlink" title="3. 在条件判断中使用 all() / any()"></a>3. 在条件判断中使用 all() / any()</h3><p><code>all()</code> 和 <code>any()</code> 两个函数非常适合在条件判断中使用。这两个函数接受一个可迭代对象，返回一个布尔值，其中：</p>
<ul>
<li><code>all(seq)</code>：仅当 <code>seq</code> 中所有对象都为布尔真时返回 <code>True</code>，否则返回 <code>False</code></li>
<li><code>any(seq)</code>：只要 <code>seq</code> 中任何一个对象为布尔真就返回 <code>True</code>，否则返回 <code>False</code></li>
</ul>
<p>假如我们有下面这段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">all_numbers_gt_10</span><span class="params">(numbers)</span>:</span></span><br><span class="line">    <span class="string">"""仅当序列中所有数字大于 10 时，返回 True</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> numbers:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>如果使用 <code>all()</code> 内建函数，再配合一个简单的生成器表达式，上面的代码可以写成这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">all_numbers_gt_10_2</span><span class="params">(numbers)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> bool(numbers) <span class="keyword">and</span> all(n &gt; <span class="number">10</span> <span class="keyword">for</span> n <span class="keyword">in</span> numbers)</span><br></pre></td></tr></table></figure>

<p>简单、高效，同时也没有损失可用性。</p>
<h3 id="4-使用-try-while-for-中-else-分支"><a href="#4-使用-try-while-for-中-else-分支" class="headerlink" title="4. 使用 try/while/for 中 else 分支"></a>4. 使用 try/while/for 中 else 分支</h3><p>让我们看看这个函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_stuff</span><span class="params">()</span>:</span></span><br><span class="line">    first_thing_successed = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        do_the_first_thing()</span><br><span class="line">        first_thing_successed = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"Error while calling do_some_thing"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 仅当 first_thing 成功完成时，做第二件事</span></span><br><span class="line">    <span class="keyword">if</span> first_thing_successed:</span><br><span class="line">        <span class="keyword">return</span> do_the_second_thing()</span><br></pre></td></tr></table></figure>

<p>在函数 <code>do_stuff</code> 中，我们希望只有当 <code>do_the_first_thing()</code> 成功调用后<em>（也就是不抛出任何异常）</em>，才继续做第二个函数调用。为了做到这一点，我们需要定义一个额外的变量 <code>first_thing_successed</code> 来作为标记。</p>
<p>其实，我们可以用更简单的方法达到同样的效果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_stuff</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        do_the_first_thing()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"Error while calling do_some_thing"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> do_the_second_thing()</span><br></pre></td></tr></table></figure>

<p>在 <code>try</code> 语句块最后追加上 <code>else</code> 分支后，分支下的<code>do_the_second_thing()</code> 便只会在 <strong>try 下面的所有语句正常执行（也就是没有异常，没有 return、break 等）完成后执行</strong>。</p>
<p>类似的，Python 里的 <code>for/while</code> 循环也支持添加 <code>else</code> 分支，它们表示：当循环使用的迭代对象被正常耗尽、或 while 循环使用的条件变量变为 False 后才执行 else 分支下的代码。</p>
<h2 id="常见陷阱"><a href="#常见陷阱" class="headerlink" title="常见陷阱"></a>常见陷阱</h2><h3 id="1-与-None-值的比较"><a href="#1-与-None-值的比较" class="headerlink" title="1. 与 None 值的比较"></a>1. 与 None 值的比较</h3><p>在 Python 中，有两种比较变量的方法：<code>==</code> 和 <code>is</code>，二者在含义上有着根本的区别：</p>
<ul>
<li><code>==</code>：表示二者所指向的的<strong>值</strong>是否一致</li>
<li><code>is</code>：表示二者是否指向内存中的同一份内容，也就是 <code>id(x)</code> 是否等于 <code>id(y)</code></li>
</ul>
<p><code>None</code> 在 Python 语言中是一个单例对象，如果你要判断某个变量是否为 None 时，记得使用 <code>is</code> 而不是 <code>==</code>，因为只有 <code>is</code> 才能在严格意义上表示某个变量是否是 None。</p>
<p>否则，可能出现下面这样的情况：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">foo = Foo()</span><br><span class="line">foo == <span class="literal">None</span></span><br></pre></td></tr></table></figure>




<pre><code>True</code></pre><p>在上面代码中，Foo 这个类通过自定义 <code>__eq__</code> 魔法方法的方式，很容易就满足了 <code>== None</code> 这个条件。</p>
<p><strong>所以，当你要判断某个变量是否为 None 时，请使用 <code>is</code> 而不是 <code>==</code>。</strong></p>
<h3 id="2-留意-and-和-or-的运算优先级"><a href="#2-留意-and-和-or-的运算优先级" class="headerlink" title="2. 留意 and 和 or 的运算优先级"></a>2. 留意 and 和 or 的运算优先级</h3><p>看看下面这两个表达式，猜猜它们的值一样吗？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print((<span class="literal">True</span> <span class="keyword">or</span> <span class="literal">False</span>) <span class="keyword">and</span> <span class="literal">False</span>)</span><br><span class="line">print(<span class="literal">True</span> <span class="keyword">or</span> <span class="literal">False</span> <span class="keyword">and</span> <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>




<pre><code>True</code></pre><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上就是『Python 工匠』系列文章的第二篇。不知道文章的内容是否对你的胃口。</p>
<p>代码内的分支语句不可避免，我们在编写代码时，需要尤其注意它的可读性，避免对其他看到代码的人造成困扰。</p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><ol>
<li><a id="annot1"></a>事实上 <code>x and a or b</code> 不是总能给你正确的结果，只有当 a 与 b 的布尔值为真时，这个表达式才能正常工作，这是由逻辑运算的短路特性决定的。你可以在命令行中运行 <code>True and None or 0</code> 试试看，结果是 0 而非 None。</li>
</ol>
<blockquote>
<p>文章更新记录：</p>
<ul>
<li>2018.04.08：在与 @geishu 的讨论后，调整了“运算优先符”使用的代码样例</li>
<li>2018.04.10：根据 @dongweiming 的建议，添加注解说明 “x and y or c” 表达式的陷阱</li>
</ul>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/24/29%20%7C%20%E5%B7%A7%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8%E5%92%8CWith%E8%AF%AD%E5%8F%A5%E7%B2%BE%E7%AE%80%E4%BB%A3%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/24/29%20%7C%20%E5%B7%A7%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8%E5%92%8CWith%E8%AF%AD%E5%8F%A5%E7%B2%BE%E7%AE%80%E4%BB%A3%E7%A0%81/" itemprop="url">29 | 巧用上下文管理器和With语句精简代码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-24T20:10:07+08:00">
                2019-12-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/" itemprop="url" rel="index">
                    <span itemprop="name">python核心技术与实战</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/24/29%20%7C%20%E5%B7%A7%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8%E5%92%8CWith%E8%AF%AD%E5%8F%A5%E7%B2%BE%E7%AE%80%E4%BB%A3%E7%A0%81/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/12/24/29%20%7C%20%E5%B7%A7%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8%E5%92%8CWith%E8%AF%AD%E5%8F%A5%E7%B2%BE%E7%AE%80%E4%BB%A3%E7%A0%81/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我想你对 Python 中的 with 语句一定不陌生，在专栏里它也曾多次出现，尤其是在文件的输入输出操作中，不过我想，大部分人可能习惯了它的使用，却并不知道隐藏在其背后的“秘密”。</p>
<p>那么，究竟 with 语句要怎么用，与之相关的上下文管理器（context manager）是什么，它们之间又有着怎样的联系呢？这节课，我就带你一起揭开它们的神秘面纱。</p>
<h3 id="什么是上下文管理器？"><a href="#什么是上下文管理器？" class="headerlink" title="什么是上下文管理器？"></a>什么是上下文管理器？</h3><p>在任何一门编程语言中，文件的输入输出、数据库的连接断开等，都是很常见的资源管理操作。但资源都是有限的，在写程序时，我们必须保证这些资源在使用过后得到释放，不然就容易造成资源泄露，轻者使得系统处理缓慢，重则会使系统崩溃。</p>
<p>光说这些概念，你可能体会不到这一点，我们可以看看下面的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10000000</span>): </span><br><span class="line">    f = open(<span class="string">'test.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line">    f.write(<span class="string">'hello'</span>)</span><br></pre></td></tr></table></figure>

<p>这里我们一共打开了 10000000 个文件，但是用完以后都没有关闭它们，如果你运行该段代码，便会报错：</p>
<p>这就是一个典型的资源泄露的例子。因为程序中同时打开了太多的文件，占据了太多的资源，造成系统崩溃。</p>
<p>为了解决这个问题，不同的编程语言都引入了不同的机制。而在 Python 中，对应的解决方式便是上下文管理器（context manager）。上下文管理器，能够帮助你自动分配并且释放资源，其中最典型的应用便是 with 语句。所以，上面代码的正确写法应该如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10000000</span>):</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'test.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">'hello'</span>)</span><br></pre></td></tr></table></figure>

<p>这样，我们每次打开文件“test.txt”，并写入‘hello’之后，这个文件便会自动关闭，相应的资源也可以得到释放，防止资源泄露。当然，with 语句的代码，也可以用下面的形式表示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'test.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f.write(<span class="string">'hello'</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure>

<p>要注意的是，最后的 finally block 尤其重要，哪怕在写入文件时发生错误异常，它也可以保证该文件最终被关闭。不过与 with 语句相比，这样的代码就显得冗余了，并且还容易漏写，因此我们一般更倾向于使用 with 语句。</p>
<p>另外一个典型的例子，是 Python 中的 threading.lock 类。举个例子，比如我想要获取一个锁，执行相应的操作，完成后再释放，那么代码就可以写成下面这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">some_lock = threading.Lock()</span><br><span class="line">some_lock.acquire()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    some_lock.release()</span><br></pre></td></tr></table></figure>

<p>而对应的 with 语句，同样非常简洁：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">some_lock = threading.Lock()</span><br><span class="line"><span class="keyword">with</span> somelock:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>我们可以从这两个例子中看到，with 语句的使用，可以简化了代码，有效避免资源泄露的发生。</p>
<h3 id="上下文管理器的实现"><a href="#上下文管理器的实现" class="headerlink" title="上下文管理器的实现"></a>上下文管理器的实现</h3><h3 id="基于类的上下文管理器"><a href="#基于类的上下文管理器" class="headerlink" title="基于类的上下文管理器"></a>基于类的上下文管理器</h3><p>了解了上下文管理的概念和优点后，下面我们就通过具体的例子，一起来看看上下文管理器的原理，搞清楚它的内部实现。这里，我自定义了一个上下文管理类 FileManager，模拟 Python 的打开、关闭文件操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileManager</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, mode)</span>:</span></span><br><span class="line">        print(<span class="string">'calling __init__ method'</span>)</span><br><span class="line">        self.name = name</span><br><span class="line">        self.mode = mode </span><br><span class="line">        self.file = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'calling __enter__ method'</span>)</span><br><span class="line">        self.file = open(self.name, self.mode)</span><br><span class="line">        <span class="keyword">return</span> self.file</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        print(<span class="string">'calling __exit__ method'</span>)</span><br><span class="line">        <span class="keyword">if</span> self.file:</span><br><span class="line">            self.file.close()</span><br><span class="line">            </span><br><span class="line"><span class="keyword">with</span> FileManager(<span class="string">'test.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(<span class="string">'ready to write to file'</span>)</span><br><span class="line">    f.write(<span class="string">'hello world'</span>)</span><br></pre></td></tr></table></figure>

<p>需要注意的是，当我们用类来创建上下文管理器时，必须保证这个类包括方法”<strong>enter</strong>()”和方法“<strong>exit</strong>()”。其中，方法“<strong>enter</strong>()”返回需要被管理的资源，方法“<strong>exit</strong>()”里通常会存在一些释放、清理资源的操作，比如这个例子中的关闭文件等等。</p>
<p>而当我们用 with 语句，执行这个上下文管理器时：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> FileManager(<span class="string">'test.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">'hello world'</span>)</span><br></pre></td></tr></table></figure>

<p>下面这四步操作会依次发生：</p>
<ol>
<li>方法“<strong>init</strong>()”被调用，程序初始化对象 FileManager，使得文件名（name）是”test.txt”，文件模式 (mode) 是’w’；</li>
<li>方法“<strong>enter</strong>()”被调用，文件“test.txt”以写入的模式被打开，并且返回 FileManager 对象赋予变量 f；</li>
<li>字符串“hello world”被写入文件“test.txt”；</li>
<li>方法“<strong>exit</strong>()”被调用，负责关闭之前打开的文件流。</li>
</ol>
<p>因此，这个程序的输出是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">calling __init__ method</span><br><span class="line">calling __enter__ method</span><br><span class="line">ready to write to file</span><br><span class="line">calling __exit__ meth</span><br></pre></td></tr></table></figure>

<p>另外，值得一提的是，方法“<strong>exit</strong>()”中的参数“exc_type, exc_val, exc_tb”，分别表示 exception_type、exception_value 和 traceback。当我们执行含有上下文管理器的 with 语句时，如果有异常抛出，异常的信息就会包含在这三个变量中，传入方法“<strong>exit</strong>()”。</p>
<p>因此，如果你需要处理可能发生的异常，可以在“<strong>exit</strong>()”添加相应的代码，比如下面这样来写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'__init__ called'</span>)        </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'__enter__ called'</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_value, exc_tb)</span>:</span></span><br><span class="line">        print(<span class="string">'__exit__ called'</span>)</span><br><span class="line">        <span class="keyword">if</span> exc_type:</span><br><span class="line">            print(<span class="string">f'exc_type: <span class="subst">&#123;exc_type&#125;</span>'</span>)</span><br><span class="line">            print(<span class="string">f'exc_value: <span class="subst">&#123;exc_value&#125;</span>'</span>)</span><br><span class="line">            print(<span class="string">f'exc_traceback: <span class="subst">&#123;exc_tb&#125;</span>'</span>)</span><br><span class="line">            print(<span class="string">'exception handled'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">with</span> Foo() <span class="keyword">as</span> obj:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">'exception raised'</span>).with_traceback(<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>这里，我们在 with 语句中手动抛出了异常“exception raised”，你可以看到，“<strong>exit</strong>()”方法中异常，被顺利捕捉并进行了处理。不过需要注意的是，如果方法“<strong>exit</strong>()”没有返回 True，异常仍然会被抛出。因此，如果你确定异常已经被处理了，请在“<strong>exit</strong>()”的最后，加上“return True”这条语句。</p>
<p>同样的，数据库的连接操作，也常常用上下文管理器来表示，这里我给出了比较简化的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConnectionManager</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, hostname, port)</span>:</span> </span><br><span class="line">        self.hostname = hostname </span><br><span class="line">        self.port = port </span><br><span class="line">        self.connection = <span class="literal">None</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span> </span><br><span class="line">        self.connection = DBClient(self.hostname, self.port) </span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span> </span><br><span class="line">        self.connection.close() </span><br><span class="line">  </span><br><span class="line"><span class="keyword">with</span> DBConnectionManager(<span class="string">'localhost'</span>, <span class="string">'8080'</span>) <span class="keyword">as</span> db_client:</span><br></pre></td></tr></table></figure>

<p>与前面 FileManager 的例子类似：</p>
<ul>
<li>方法“<strong>init</strong>()”负责对数据库进行初始化，也就是将主机名、接口（这里是 localhost 和 8080）分别赋予变量 hostname 和 port；</li>
<li>方法“<strong>enter</strong>()”连接数据库，并且返回对象 DBConnectionManager；</li>
<li>方法“<strong>exit</strong>()”则负责关闭数据库的连接。<br>这样一来，只要你写完了 DBconnectionManager 这个类，那么在程序每次连接数据库时，我们都只需要简单地调用 with 语句即可，并不需要关心数据库的关闭、异常等等，显然大大提高了开发的效率。</li>
</ul>
<h3 id="基于生成器的上下文管理器"><a href="#基于生成器的上下文管理器" class="headerlink" title="基于生成器的上下文管理器"></a>基于生成器的上下文管理器</h3><p>诚然，基于类的上下文管理器，在 Python 中应用广泛，也是我们经常看到的形式，不过 Python 中的上下文管理器并不局限于此。除了基于类，它还可以基于生成器实现。接下来我们来看一个例子。</p>
<p>比如，你可以使用装饰器 contextlib.contextmanager，来定义自己所需的基于生成器的上下文管理器，用以支持 with 语句。还是拿前面的类上下文管理器 FileManager 来说，我们也可以用下面形式来表示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"> </span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file_manager</span><span class="params">(name, mode)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f = open(name, mode)</span><br><span class="line">        <span class="keyword">yield</span> f</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        f.close()</span><br><span class="line">        </span><br><span class="line"><span class="keyword">with</span> file_manager(<span class="string">'test.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">'hello world'</span>)</span><br></pre></td></tr></table></figure>

<p>这段代码中，函数 file_manager() 是一个生成器，当我们执行 with 语句时，便会打开文件，并返回文件对象 f；当 with 语句执行完后，finally block 中的关闭文件操作便会执行。</p>
<p>你可以看到，使用基于生成器的上下文管理器时，我们不再用定义“<strong>enter</strong>()”和“<strong>exit</strong>()”方法，但请务必加上装饰器 @contextmanager，这一点新手很容易疏忽。</p>
<p>讲完这两种不同原理的上下文管理器后，还需要强调的是，基于类的上下文管理器和基于生成器的上下文管理器，这两者在功能上是一致的。只不过，</p>
<ul>
<li>基于类的上下文管理器更加 flexible，适用于大型的系统开发；</li>
<li>而基于生成器的上下文管理器更加方便、简洁，适用于中小型程序。<br>无论你使用哪一种，请不用忘记在方法“<strong>exit</strong>()”或者是 finally block 中释放资源，这一点尤其重要。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这节课，我们先通过一个简单的例子，了解了资源泄露的易发生性，和其带来的严重后果，从而引入了应对方案——即上下文管理器的概念。上下文管理器，通常应用在文件的打开关闭和数据库的连接关闭等场景中，可以确保用过的资源得到迅速释放，有效提高了程序的安全性，</p>
<p>接着，我们通过自定义上下文管理的实例，了解了上下文管理工作的原理，并一起学习了基于类的上下文管理器和基于生成器的上下文管理器，这两者的功能相同，具体用哪个，取决于你的具体使用场景。</p>
<p>另外，上下文管理器通常和 with 语句一起使用，大大提高了程序的简洁度。需要注意的是，当我们用 with 语句执行上下文管理器的操作时，一旦有异常抛出，异常的类型、值等具体信息，都会通过参数传入“<strong>exit</strong>()”函数中。你可以自行定义相关的操作对异常进行处理，而处理完异常后，也别忘了加上“return True”这条语句，否则仍然会抛出异常。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/23/28%20%7C%20%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E5%88%A9%E7%94%A8assert%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/23/28%20%7C%20%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E5%88%A9%E7%94%A8assert%EF%BC%9F/" itemprop="url">28 | 如何合理利用assert？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-23T20:10:07+08:00">
                2019-12-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/" itemprop="url" rel="index">
                    <span itemprop="name">python核心技术与实战</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/23/28%20%7C%20%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E5%88%A9%E7%94%A8assert%EF%BC%9F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/12/23/28%20%7C%20%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E5%88%A9%E7%94%A8assert%EF%BC%9F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>相信你平时在写代码时，肯定或多或少看到过 assert 的存在。我也曾在日常的 code review 中，被一些同事要求增加 assert 语句，让代码更加健壮。</p>
<p>不过，尽管如此，我发现在很多情况下，assert 还是很容易被忽略，人们似乎对这么一个“不起眼”的东西并不关心。但事实上，这个看似“不起眼”的东西，如果能用好，对我们的程序大有裨益。</p>
<p>说了这么多，那么究竟什么是 assert，我们又该如何合理地使用 assert 呢？今天这节课，我就带你一起来学习它的用法。</p>
<h3 id="什么是-assert？"><a href="#什么是-assert？" class="headerlink" title="什么是 assert？"></a>什么是 assert？</h3><p>Python 的 assert 语句，可以说是一个 debug 的好工具，主要用于测试一个条件是否满足。如果测试的条件满足，则什么也不做，相当于执行了 pass 语句；如果测试条件不满足，便会抛出异常 AssertionError，并返回具体的错误信息（optional）。</p>
<p>它的具体语法是下面这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert_stmt ::=  <span class="string">"assert"</span> expression [<span class="string">","</span> expression]</span><br></pre></td></tr></table></figure>

<p>我们先来看一个简单形式的assert expression，比如下面这个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="number">1</span> == <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>它就相当于下面这两行代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __debug__:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> expression: <span class="keyword">raise</span> AssertionError</span><br></pre></td></tr></table></figure>

<p>再来看assert expression1, expression2的形式，比如下面这个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="number">1</span> == <span class="number">2</span>,  <span class="string">'assertion is wrong'</span></span><br></pre></td></tr></table></figure>

<p>它就相当于下面这两行代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __debug__:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> expression1: <span class="keyword">raise</span> AssertionError(expression2)</span><br></pre></td></tr></table></figure>

<p>这里的<strong>debug</strong>是一个常数。如果 Python 程序执行时附带了-O这个选项，比如Python test.py -O，那么程序中所有的 assert 语句都会失效，常数<strong>debug</strong>便为 False；反之<strong>debug</strong>则为 True。</p>
<p>不过，需要注意的是，直接对常数<strong>debug</strong>赋值是非法的，因为它的值在解释器开始运行时就已经决定了，中途无法改变。</p>
<p>此外，一定记住，不要在使用 assert 时加入括号，比如下面这个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>(<span class="number">1</span> == <span class="number">2</span>, <span class="string">'This should fail'</span>)</span><br></pre></td></tr></table></figure>

<pre><code>&lt;&gt;:1: SyntaxWarning: assertion is always true, perhaps remove parentheses?
&lt;&gt;:1: SyntaxWarning: assertion is always true, perhaps remove parentheses?
&lt;&gt;:1: SyntaxWarning: assertion is always true, perhaps remove parentheses?
&lt;ipython-input-1-2c057bd7fe24&gt;:1: SyntaxWarning: assertion is always true, perhaps remove parentheses?
  assert(1 == 2, &apos;This should fail&apos;)</code></pre><p>如果你按照这样来写，无论表达式对与错（比如这里的 1 == 2 显然是错误的），assert 检查永远不会 fail，程序只会给你 SyntaxWarning。</p>
<p>正确的写法，应该是下面这种不带括号的写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="number">1</span> == <span class="number">2</span>， <span class="string">'This should fail'</span></span><br></pre></td></tr></table></figure>


<pre><code>  File &quot;&lt;ipython-input-2-fc2fe8967c4a&gt;&quot;, line 1
    assert 1 == 2， &apos;This should fail&apos;
                 ^
SyntaxError: invalid character in identifier</code></pre><p>总的来说，assert 在程序中的作用，是对代码做一些 internal 的 self-check。使用 assert，就表示你很确定。这个条件一定会发生或者一定不会发生。</p>
<p>举个例子，比如你有一个函数，其中一个参数是人的性别，因为性别只有男女之分（这里只指生理性别），你便可以使用 assert，以防止程序的非法输入。如果你的程序没有 bug，那么 assert 永远不会抛出异常；而它一旦抛出了异常，你就知道程序存在问题了，并且可以根据错误信息，很容易定位出错误的源头。</p>
<h3 id="assert-的用法"><a href="#assert-的用法" class="headerlink" title="assert 的用法"></a>assert 的用法</h3><p>讲完了 assert 的基本语法与概念，我们接下来通过一些实际应用的例子，来看看 assert 在 Python 中的用法，并弄清楚 assert 的使用场景。</p>
<p>第一个例子，假设你现在使用的极客时间正在做专栏促销活动，准备对一些专栏进行打折，所以后台需要写一个 apply_discount() 函数，要求输入为原来的价格和折扣，输出是折后的价格。那么，我们可以大致写成下面这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply_discount</span><span class="params">(price, discount)</span>:</span></span><br><span class="line">    updated_price = price * (<span class="number">1</span> - discount)</span><br><span class="line">    <span class="keyword">assert</span> <span class="number">0</span> &lt;= updated_price &lt;= price, <span class="string">'price should be greater or equal to 0 and less or equal to original price'</span></span><br><span class="line">    <span class="keyword">return</span> updated_price</span><br></pre></td></tr></table></figure>

<p>可以看到，在计算新价格的后面，我们还写了一个 assert 语句，用来检查折后价格，这个值必须大于等于 0、小于等于原来的价格，否则就抛出异常。</p>
<p>我们可以试着输入几组数，来验证一下这个功能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apply_discount(<span class="number">100</span>, <span class="number">0.2</span>)</span><br><span class="line"><span class="number">80.0</span></span><br><span class="line"> </span><br><span class="line">apply_discount(<span class="number">100</span>, <span class="number">2</span>)</span><br><span class="line">AssertionError: price should be greater <span class="keyword">or</span> equal to <span class="number">0</span> <span class="keyword">and</span> less <span class="keyword">or</span> equal to original price</span><br></pre></td></tr></table></figure>

<p>显然，当 discount 是 0.2 时，输出 80，没有问题。但是当 discount 为 2 时，程序便抛出下面这个异常：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AssertionError：price should be greater <span class="keyword">or</span> equal to <span class="number">0</span> <span class="keyword">and</span> less <span class="keyword">or</span> equal to original price</span><br></pre></td></tr></table></figure>

<p>这样一来，如果开发人员修改相关的代码，或者是加入新的功能，导致 discount 数值的异常时，我们运行测试时就可以很容易发现问题。正如我开头所说，assert 的加入，可以有效预防 bug 的发生，提高程序的健壮性。</p>
<p>再来看一个例子，最常见的除法操作，这在任何领域的计算中都经常会遇到。同样还是以极客时间为例，假如极客时间后台想知道每个专栏的平均销售价格，那么就需要给定销售总额和销售数目，这样平均销售价格便很容易计算出来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_average_price</span><span class="params">(total_sales, num_sales)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> num_sales &gt; <span class="number">0</span>, <span class="string">'number of sales should be greater than 0'</span></span><br><span class="line">    <span class="keyword">return</span> total_sales / num_sales</span><br></pre></td></tr></table></figure>

<p>同样的，我们也加入了 assert 语句，规定销售数目必须大于 0，这样就可以防止后台计算那些还未开卖的专栏的价格。</p>
<p>除了这两个例子，在实际工作中，assert 还有一些很常见的用法，比如下面的场景：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(input)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> isinstance(input, list), <span class="string">'input must be type of list'</span></span><br><span class="line">    <span class="comment"># 下面的操作都是基于前提：input 必须是 list</span></span><br><span class="line">    <span class="keyword">if</span> len(input) == <span class="number">1</span>:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">elif</span> len(input) == <span class="number">2</span>:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>这里函数 func() 里的所有操作，都是基于输入必须是 list 这个前提。是不是很熟悉的需求呢？那我们就很有必要在开头加一句 assert 的检查，防止程序出错。</p>
<p>当然，我们也要根据具体情况具体分析。比如上面这个例子，之所以能加 assert，是因为我们很确定输入必须是 list，不能是其他数据类型。</p>
<p>如果你的程序中，允许 input 是其他数据类型，并且对不同的数据类型都有不同的处理方式，那你就应该写成 if else 的条件语句了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(input)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(input, list):</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<h3 id="assert-错误示例"><a href="#assert-错误示例" class="headerlink" title="assert 错误示例"></a>assert 错误示例</h3><p>前面我们讲了这么多 assert 的使用场景，可能给你一种错觉，也可能会让你有些迷茫：很多地方都可以使用 assert， 那么，很多 if 条件语句是不是都可以换成 assert 呢？这么想可就不准确了，接下来，我们就一起来看几个典型的错误用法，避免一些想当然的用法。</p>
<p>还是以极客时间为例，我们假设下面这样的场景：后台有时候需要删除一些上线时间较长的专栏，于是，相关的开发人员便设计出了下面这个专栏删除函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_course</span><span class="params">(user, course_id)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> user_is_admin(user), <span class="string">'user must be admin'</span></span><br><span class="line">    <span class="keyword">assert</span> course_exist(course_id), <span class="string">'course id must exist'</span></span><br><span class="line">    delete(course_id)</span><br></pre></td></tr></table></figure>

<p>极客时间规定，必须是 admin 才能删除专栏，并且这个专栏课程必须存在。有的同学一看，很熟悉的需求啊，所以在前面加了相应的 assert 检查。那么我想让你思考一下，这样写到底对不对呢？</p>
<p>答案显然是否定的。你可能觉得，从代码功能角度来说，这没错啊。但是在实际工程中，基本上没人会这么写。为什么呢？</p>
<p>要注意，前面我说过，assert 的检查是可以被关闭的，比如在运行 Python 程序时，加入-O这个选项就会让 assert 失效。因此，一旦 assert 的检查被关闭，user_is_admin() 和 course_exist() 这两个函数便不会被执行。这就会导致：</p>
<ul>
<li>任何用户都有权限删除专栏课程；</li>
<li>并且，不管这个课程是否存在，他们都可以强行执行删除操作。<br>这显然会给程序带来巨大的安全漏洞。所以，正确的做法，是使用条件语句进行相应的检查，并合理抛出异常：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_course</span><span class="params">(user, course_id)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> user_is_admin(user):</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'user must be admin'</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> course_exist(course_id):</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'coursde id must exist'</span>)</span><br><span class="line">    delete(course_id)</span><br></pre></td></tr></table></figure>

<p>再来看一个例子，如果你想打开一个文件，进行数据读取、处理等一系列操作，那么下面这样的写法，显然也是不正确的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_and_process</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> file_exist(path), <span class="string">'file must exist'</span></span><br><span class="line">    <span class="keyword">with</span> open(path) <span class="keyword">as</span> f:</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure>

<p>因为 assert 的使用，表明你强行指定了文件必须存在，但事实上在很多情况下，这个假设并不成立。另外，打开文件操作，也有可能触发其他的异常。所以，正确的做法是进行异常处理，用 try 和 except 来解决：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_and_process</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> open(path) <span class="keyword">as</span> f:</span><br><span class="line">            ...</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>

<p>总的来说，assert 并不适用 run-time error 的检查。比如你试图打开一个文件，但文件不存在；再或者是你试图从网上下载一个东西，但中途断网了了等等，这些情况下，还是应该参照我们前面所讲的错误与异常的内容，进行正确处理。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>今天这节课，我们一起学习了 assert 的用法。assert 通常用来对代码进行必要的 self check，表明你很确定这种情况一定发生，或者一定不会发生。需要注意的是，使用 assert 时，一定不要加上括号，否则无论表达式对与错，assert 检查永远不会 fail。另外，程序中的 assert 语句，可以通过-O等选项被全局 disable。</p>
<p>通过这节课的几个使用场景，你能看到，assert 的合理使用，可以增加代码的健壮度，同时也方便了程序出错时开发人员的定位排查。</p>
<p>不过，我们也不能滥用 assert。很多情况下，程序中出现的不同情况都是意料之中的，需要我们用不同的方案去处理，这时候用条件语句进行判断更为合适。而对于程序中的一些 run-time error，请记得使用异常处理。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/19/04%E4%B8%A8Python%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%EF%BC%9A%E7%94%A8NumPy%E5%BF%AB%E9%80%9F%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/19/04%E4%B8%A8Python%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%EF%BC%9A%E7%94%A8NumPy%E5%BF%AB%E9%80%9F%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE/" itemprop="url">04丨Python科学计算：用NumPy快速处理数据</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-19T21:25:07+08:00">
                2019-12-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%9845%E8%AE%B2/" itemprop="url" rel="index">
                    <span itemprop="name">数据分析实战45讲</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/19/04%E4%B8%A8Python%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%EF%BC%9A%E7%94%A8NumPy%E5%BF%AB%E9%80%9F%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/12/19/04%E4%B8%A8Python%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%EF%BC%9A%E7%94%A8NumPy%E5%BF%AB%E9%80%9F%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p> Python 数组结构中的列表 list，它实际上相当于一个数组的结构。而 NumPy 中一个关键数据类型就是关于数组的，那为什么还存在这样一个第三方的数组结构呢？</p>
<p>实际上，标准的 Python 中，用列表 list 保存数组的数值。由于列表中的元素可以是任意的对象，所以列表中 list 保存的是对象的指针。虽然在 Python 编程中隐去了指针的概念，但是数组有指针，Python 的列表 list 其实就是数组。这样如果我要保存一个简单的数组 [0,1,2]，就需要有 3 个指针和 3 个整数的对象，这样对于 Python 来说是非常不经济的，浪费了内存和计算时间。</p>
<h3 id="使用-NumPy-让你的-Python-科学计算更高效"><a href="#使用-NumPy-让你的-Python-科学计算更高效" class="headerlink" title="使用 NumPy 让你的 Python 科学计算更高效"></a>使用 NumPy 让你的 Python 科学计算更高效</h3><p>为什么要用 NumPy 数组结构而不是 Python 本身的列表 list？这是因为列表 list 的元素在系统内存中是分散存储的，而 NumPy 数组存储在一个均匀连续的内存块中。这样数组计算遍历所有的元素，不像列表 list 还需要对内存地址进行查找，从而节省了计算资源。</p>
<p>另外在内存访问模式中，缓存会直接把字节块从 RAM 加载到 CPU 寄存器中。因为数据连续的存储在内存中，NumPy 直接利用现代 CPU 的矢量化指令计算，加载寄存器中的多个连续浮点数。另外 NumPy 中的矩阵计算可以采用多线程的方式，充分利用多核 CPU 计算资源，大大提升了计算效率。</p>
<p>当然除了使用 NumPy 外，你还需要一些技巧来提升内存和提高计算资源的利用率。一个重要的规则就是：避免采用隐式拷贝，而是采用就地操作的方式。举个例子，如果我想让一个数值 x 是原来的两倍，可以直接写成 x<em>=2，而不要写成 y=x</em>2。</p>
<p>这样速度能快到 2 倍甚至更多。</p>
<p>既然 NumPy 这么厉害，你该从哪儿入手学习呢？在 NumPy 里有两个重要的对象：ndarray（N-dimensional array object）解决了多维数组问题，而 ufunc（universal function object）则是解决对数组进行处理的函数。下面，我就带你一一来看。</p>
<h4 id="ndarray-对象"><a href="#ndarray-对象" class="headerlink" title="ndarray 对象"></a>ndarray 对象</h4><p>ndarray 实际上是多维数组的含义。在 NumPy 数组中，维数称为秩（rank），一维数组的秩为 1，二维数组的秩为 2，以此类推。在 NumPy 中，每一个线性的数组称为一个轴（axes），其实秩就是描述轴的数量。</p>
<p>下面，你来看 ndarray 对象是如何创建数组的，又是如何处理结构数组的呢？</p>
<h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">b = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line">b[<span class="number">1</span>,<span class="number">1</span>]=<span class="number">10</span></span><br><span class="line">print(a.shape)</span><br><span class="line">print(b.shape)</span><br><span class="line">print(a.dtype)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>

<pre><code>(3,)
(3, 3)
int64
[[ 1  2  3]
 [ 4 10  6]
 [ 7  8  9]]</code></pre><p>创建数组前，你需要引用 NumPy 库，可以直接通过 array 函数创建数组，如果是多重数组，比如示例里的 b，那么该怎么做呢？你可以先把一个数组作为一个元素，然后嵌套起来，比如示例 b 中的 [1,2,3] 就是一个元素，然后 [4,5,6][7,8,9] 也是作为元素，然后把三个元素再放到 [] 数组里，赋值给变量 b。</p>
<p>当然数组也是有属性的，比如你可以通过函数 shape 属性获得数组的大小，通过 dtype 获得元素的属性。如果你想对数组里的数值进行修改的话，直接赋值即可，注意下标是从 0 开始计的，所以如果你想对 b 数组，九宫格里的中间元素进行修改的话，下标应该是 [1,1]。</p>
<h3 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a>结构数组</h3><p>如果你想统计一个班级里面学生的姓名、年龄，以及语文、英语、数学成绩该怎么办？当然你可以用数组的下标来代表不同的字段，比如下标为 0 的是姓名、下标为 1 的是年龄等，但是这样不显性。</p>
<p>实际上在 C 语言里，可以定义结构数组，也就是通过 struct 定义结构类型，结构中的字段占据连续的内存空间，每个结构体占用的内存大小都相同，那在 NumPy 中是怎样操作的呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">persontype = np.dtype(&#123;</span><br><span class="line">    <span class="string">'names'</span>:[<span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'chinese'</span>, <span class="string">'math'</span>, <span class="string">'english'</span>],</span><br><span class="line">    <span class="string">'formats'</span>:[<span class="string">'S32'</span>,<span class="string">'i'</span>, <span class="string">'i'</span>, <span class="string">'i'</span>, <span class="string">'f'</span>]&#125;)</span><br><span class="line">peoples = np.array([(<span class="string">"ZhangFei"</span>,<span class="number">32</span>,<span class="number">75</span>,<span class="number">100</span>, <span class="number">90</span>),(<span class="string">"GuanYu"</span>,<span class="number">24</span>,<span class="number">85</span>,<span class="number">96</span>,<span class="number">88.5</span>),</span><br><span class="line">       (<span class="string">"ZhaoYun"</span>,<span class="number">28</span>,<span class="number">85</span>,<span class="number">92</span>,<span class="number">96.5</span>),(<span class="string">"HuangZhong"</span>,<span class="number">29</span>,<span class="number">65</span>,<span class="number">85</span>,<span class="number">100</span>)],</span><br><span class="line">    dtype=persontype)</span><br><span class="line">ages = peoples[:][<span class="string">'age'</span>]</span><br><span class="line">chineses = peoples[:][<span class="string">'chinese'</span>]</span><br><span class="line">maths = peoples[:][<span class="string">'math'</span>]</span><br><span class="line">englishs = peoples[:][<span class="string">'english'</span>]</span><br><span class="line">print(np.mean(ages))</span><br><span class="line">print(np.mean(chineses))</span><br><span class="line">print(np.mean(maths))</span><br><span class="line">print(np.mean(englishs))</span><br></pre></td></tr></table></figure>

<pre><code>28.25
77.5
93.25
93.75</code></pre><p>你看下这个例子，首先在 NumPy 中是用 dtype 定义的结构类型，然后在定义数组的时候，用 array 中指定了结构数组的类型 dtype=persontype，这样你就可以自由地使用自定义的 persontype 了。比如想知道每个人的语文成绩，就可以用 chineses = peoples[:][‘chinese’]，当然 NumPy 中还有一些自带的数学运算，比如计算平均值使用 np.mean。</p>
<h3 id="ufunc-运算"><a href="#ufunc-运算" class="headerlink" title="ufunc 运算"></a>ufunc 运算</h3><p>ufunc 是 universal function 的缩写，是不是听起来就感觉功能非常强大？确如其名，它能对数组中每个元素进行函数操作。NumPy 中很多 ufunc 函数计算速度非常快，因为都是采用 C 语言实现的。</p>
<h3 id="连续数组的创建"><a href="#连续数组的创建" class="headerlink" title="连续数组的创建"></a>连续数组的创建</h3><p>NumPy 可以很方便地创建连续数组，比如我使用 arange 或 linspace 函数进行创建：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x1 = np.arange(<span class="number">1</span>,<span class="number">11</span>,<span class="number">2</span>)</span><br><span class="line">x2 = np.linspace(<span class="number">1</span>,<span class="number">9</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>np.arange 和 np.linspace 起到的作用是一样的，都是创建等差数组。这两个数组的结果 x1,x2 都是 [1 3 5 7 9]。结果相同，但是你能看出来创建的方式是不同的。</p>
<p>arange() 类似内置函数 range()，通过指定初始值、终值、步长来创建等差数列的一维数组，默认是不包括终值的。</p>
<p>linspace 是 linear space 的缩写，代表线性等分向量的含义。linspace() 通过指定<strong>初始值、终值、元素个数来创建等差数列的一维数组，默认是包括终值的。</strong></p>
<h3 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h3><p>通过 NumPy 可以自由地创建等差数组，同时也可以进行加、减、乘、除、求 n 次方和取余数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x1 = np.arange(<span class="number">1</span>,<span class="number">11</span>,<span class="number">2</span>)</span><br><span class="line">x2 = np.linspace(<span class="number">1</span>,<span class="number">9</span>,<span class="number">5</span>)</span><br><span class="line">print(np.add(x1, x2))</span><br><span class="line">print(np.subtract(x1, x2))</span><br><span class="line">print(np.multiply(x1, x2))</span><br><span class="line">print(np.divide(x1, x2))</span><br><span class="line">print(np.power(x1, x2))</span><br><span class="line">print(np.remainder(x1, x2))</span><br></pre></td></tr></table></figure>

<pre><code>[ 2.  6. 10. 14. 18.]
[0. 0. 0. 0. 0.]
[ 1.  9. 25. 49. 81.]
[1. 1. 1. 1. 1.]
[1.00000000e+00 2.70000000e+01 3.12500000e+03 8.23543000e+05
 3.87420489e+08]
[0. 0. 0. 0. 0.]</code></pre><p>我还以 x1, x2 数组为例，求这两个数组之间的加、减、乘、除、求 n 次方和取余数。在 n 次方中，x2 数组中的元素实际上是次方的次数，x1 数组的元素为基数。</p>
<p>在取余函数里，你既可以用 np.remainder(x1, x2)，也可以用 np.mod(x1, x2)，结果是一样的。</p>
<h3 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h3><p>如果你想要对一堆数据有更清晰的认识，就需要对这些数据进行描述性的统计分析，比如了解这些数据中的最大值、最小值、平均值，是否符合正态分布，方差、标准差多少等等。它们可以让你更清楚地对这组数据有认知。</p>
<p>下面我来介绍下在 NumPy 中如何使用这些统计函数。</p>
<h3 id="计数组-矩阵中的最大值函数-amax-，最小值函数-amin"><a href="#计数组-矩阵中的最大值函数-amax-，最小值函数-amin" class="headerlink" title="计数组 / 矩阵中的最大值函数 amax()，最小值函数 amin()"></a>计数组 / 矩阵中的最大值函数 amax()，最小值函数 amin()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line">print(np.amin(a))</span><br><span class="line">print(np.amin(a,<span class="number">0</span>))</span><br><span class="line">print(np.amin(a,<span class="number">1</span>))</span><br><span class="line">print(np.amax(a))</span><br><span class="line">print(np.amax(a,<span class="number">0</span>))</span><br><span class="line">print(np.amax(a,<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<pre><code>1
[1 2 3]
[1 4 7]
9
[7 8 9]
[3 6 9]</code></pre><p>amin() 用于计算数组中的元素沿指定轴的最小值。对于一个二维数组 a，amin(a) 指的是数组中全部元素的最小值，amin(a,0) 是延着 axis=0 轴的最小值，axis=0 轴是把元素看成了 [1,4,7], [2,5,8], [3,6,9] 三个元素，所以最小值为 [1,2,3]，amin(a,1) 是延着 axis=1 轴的最小值，axis=1 轴是把元素看成了 [1,2,3], [4,5,6], [7,8,9] 三个元素，所以最小值为 [1,4,7]。同理 amax() 是计算数组中元素沿指定轴的最大值。</p>
<h3 id="统计最大值与最小值之差-ptp"><a href="#统计最大值与最小值之差-ptp" class="headerlink" title="统计最大值与最小值之差 ptp()"></a>统计最大值与最小值之差 ptp()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line">print(np.ptp(a)) </span><br><span class="line">print(np.ptp(a,<span class="number">0</span>))</span><br><span class="line">print(np.ptp(a,<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<pre><code>8
[6 6 6]
[2 2 2]</code></pre><p>对于相同的数组 a，np.ptp(a) 可以统计数组中最大值与最小值的差，即 9-1=8。同样 ptp(a,0) 统计的是沿着 axis=0 轴的最大值与最小值之差，即 7-1=6（当然 8-2=6,9-3=6，第三行减去第一行的 ptp 差均为 6），ptp(a,1) 统计的是沿着 axis=1 轴的最大值与最小值之差，即 3-1=2（当然 6-4=2, 9-7=2，即第三列与第一列的 ptp 差均为 2）。</p>
<h3 id="统计数组的百分位数-percentile"><a href="#统计数组的百分位数-percentile" class="headerlink" title="统计数组的百分位数 percentile()"></a>统计数组的百分位数 percentile()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line"><span class="keyword">print</span> np.percentile(a, <span class="number">50</span>)</span><br><span class="line"><span class="keyword">print</span> np.percentile(a, <span class="number">50</span>, axis=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">print</span> np.percentile(a, <span class="number">50</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>同样，percentile() 代表着第 p 个百分位数，这里 p 的取值范围是 0-100，如果 p=0，那么就是求最小值，如果 p=50 就是求平均值，如果 p=100 就是求最大值。同样你也可以求得在 axis=0 和 axis=1 两个轴上的 p% 的百分位数。</p>
<h3 id="统计数组中的中位数-median-、平均数-mean"><a href="#统计数组中的中位数-median-、平均数-mean" class="headerlink" title="统计数组中的中位数 median()、平均数 mean()"></a>统计数组中的中位数 median()、平均数 mean()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line"><span class="comment"># 求中位数</span></span><br><span class="line"><span class="keyword">print</span> np.median(a)</span><br><span class="line"><span class="keyword">print</span> np.median(a, axis=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">print</span> np.median(a, axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 求平均数</span></span><br><span class="line"><span class="keyword">print</span> np.mean(a)</span><br><span class="line"><span class="keyword">print</span> np.mean(a, axis=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">print</span> np.mean(a, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>你可以用 median() 和 mean() 求数组的中位数、平均值，同样也可以求得在 axis=0 和 1 两个轴上的中位数、平均值。你可以自己练习下看看运行结果。</p>
<h3 id="统计数组中的加权平均值-average"><a href="#统计数组中的加权平均值-average" class="headerlink" title="统计数组中的加权平均值 average()"></a>统计数组中的加权平均值 average()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">wts = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="keyword">print</span> np.average(a)</span><br><span class="line"><span class="keyword">print</span> np.average(a,weights=wts)</span><br></pre></td></tr></table></figure>

<p>average() 函数可以求加权平均，加权平均的意思就是每个元素可以设置个权重，默认情况下每个元素的权重是相同的，所以 np.average(a)=(1+2+3+4)/4=2.5，你也可以指定权重数组 wts=[1,2,3,4]，这样加权平均 np.average(a,weights=wts)=(1<em>1+2</em>2+3<em>3+4</em>4)/(1+2+3+4)=3.0。</p>
<h3 id="统计数组中的标准差-std-、方差-var"><a href="#统计数组中的标准差-std-、方差-var" class="headerlink" title="统计数组中的标准差 std()、方差 var()"></a>统计数组中的标准差 std()、方差 var()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="keyword">print</span> np.std(a)</span><br><span class="line"><span class="keyword">print</span> np.var(a)</span><br></pre></td></tr></table></figure>

<p>方差的计算是指每个数值与平均值之差的平方求和的平均值，即 mean((x - x.mean())** 2)。标准差是方差的算术平方根。在数学意义上，代表的是一组数据离平均值的分散程度。所以 np.var(a)=1.25, np.std(a)=1.118033988749895。</p>
<h3 id="NumPy-排序"><a href="#NumPy-排序" class="headerlink" title="NumPy 排序"></a>NumPy 排序</h3><p>排序是算法中使用频率最高的一种，也是在数据分析工作中常用的方法，计算机专业的同学会在大学期间的算法课中学习。</p>
<p>那么这些排序算法在 NumPy 中实现起来其实非常简单，一条语句就可以搞定。这里你可以使用 sort 函数，sort(a, axis=-1, kind=‘quicksort’, order=None)，默认情况下使用的是快速排序；在 kind 里，可以指定 quicksort、mergesort、heapsort 分别表示快速排序、合并排序、堆排序。同样 axis 默认是 -1，即沿着数组的最后一个轴进行排序，也可以取不同的 axis 轴，或者 axis=None 代表采用扁平化的方式作为一个向量进行排序。另外 order 字段，对于结构化的数组可以指定按照某个字段进行排序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>]])</span><br><span class="line"><span class="keyword">print</span> np.sort(a)</span><br><span class="line"><span class="keyword">print</span> np.sort(a, axis=<span class="literal">None</span>)</span><br><span class="line"><span class="keyword">print</span> np.sort(a, axis=<span class="number">0</span>)  </span><br><span class="line"><span class="keyword">print</span> np.sort(a, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>你可以自己计算下这个运行结果，然后再跑一遍比对下。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在 NumPy 学习中，你重点要掌握的就是对数组的使用，因为这是 NumPy 和标准 Python 最大的区别。在 NumPy 中重新对数组进行了定义，同时提供了算术和统计运算，你也可以使用 NumPy 自带的排序功能，一句话就搞定各种排序算法。</p>
<p>当然要理解 NumPy 提供的数据结构为什么比 Python 自身的“更高级、更高效”，要从对数据指针的引用角度进行理解。</p>
<p>我今天重点讲了 NumPy 的数据结构，你能用自己的话说明一下为什么要用 NumPy 而不是 Python 的列表 list 吗？除此之外，你还知道那些数据结构类型？</p>
<h3 id="练习题：统计全班的成绩"><a href="#练习题：统计全班的成绩" class="headerlink" title="练习题：统计全班的成绩"></a>练习题：统计全班的成绩</h3><p>假设一个团队里有 5 名学员，成绩如下表所示。你可以用 NumPy 统计下这些人在语文、英语、数学中的平均成绩、最小成绩、最大成绩、方差、标准差。然后把这些人的总成绩排序，得出名次进行成绩输出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/19/00%20%7C%20%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E8%83%BD%E5%8A%9B%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/19/00%20%7C%20%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E8%83%BD%E5%8A%9B%EF%BC%9F/" itemprop="url">00 | 你为什么需要数据分析能力？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-19T20:13:07+08:00">
                2019-12-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%9845%E8%AE%B2/" itemprop="url" rel="index">
                    <span itemprop="name">数据分析实战45讲</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/19/00%20%7C%20%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E8%83%BD%E5%8A%9B%EF%BC%9F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/12/19/00%20%7C%20%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E8%83%BD%E5%8A%9B%EF%BC%9F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="数据分析的功能"><a href="#数据分析的功能" class="headerlink" title="数据分析的功能"></a>数据分析的功能</h3><ul>
<li><p>通过数据分析，我们可以更好地了解用户画像，为企业做留存率、流失率等指标分析，进而精细化产品运营。</p>
</li>
<li><p>如果你关注比特币，数据分析可以帮助你预测比特币的走势。</p>
</li>
<li><p>面对生活中遇到的种种麻烦，数据分析也可以提供解决方案，比如信用卡反欺诈，自动屏蔽垃圾邮件等。</p>
</li>
</ul>
<h3 id="如何学习"><a href="#如何学习" class="headerlink" title="如何学习"></a>如何学习</h3><p>总结一下，就是他找到了高效的学习方法，我把它称为MAS 方法。</p>
<ul>
<li><p>Multi-Dimension：想要掌握一个事物，就要从多个角度去认识它。</p>
</li>
<li><p>Ask：不懂就问，程序员大多都很羞涩，突破这一点，不懂就问最重要。</p>
</li>
<li><p>Sharing：最好的学习就是分享。用自己的语言讲出来，是对知识的进一步梳理。</p>
</li>
</ul>
<h3 id="多维度连接"><a href="#多维度连接" class="headerlink" title="多维度连接"></a>多维度连接</h3><p>怎么和数据分析建立多维度连接呢？我特意把内容分成了三个大类。</p>
<ul>
<li><p>第一类是基础概念。这是我们学习的基础，一定不能落下。</p>
</li>
<li><p>第二类是工具。这个部分可以很好地锻炼你的实操能力。</p>
</li>
<li><p>第三类是题库。题库的作用是帮你查漏补缺，在这个过程中，你会情不自禁地进行思考。</p>
</li>
</ul>
<p><strong>学习数据分析的核心就是培养数据思维，掌握挖掘工具，熟练实践并积累经验。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/18/1-Python%20%E5%B7%A5%E5%8C%A0%EF%BC%9A%E5%96%84%E7%94%A8%E5%8F%98%E9%87%8F%E6%9D%A5%E6%94%B9%E5%96%84%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/18/1-Python%20%E5%B7%A5%E5%8C%A0%EF%BC%9A%E5%96%84%E7%94%A8%E5%8F%98%E9%87%8F%E6%9D%A5%E6%94%B9%E5%96%84%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/" itemprop="url">1-Python 工匠：善用变量来改善代码质量</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-18T20:10:07+08:00">
                2019-12-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python%E5%B7%A5%E5%8C%A0/" itemprop="url" rel="index">
                    <span itemprop="name">Python工匠</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/18/1-Python%20%E5%B7%A5%E5%8C%A0%EF%BC%9A%E5%96%84%E7%94%A8%E5%8F%98%E9%87%8F%E6%9D%A5%E6%94%B9%E5%96%84%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/12/18/1-Python%20%E5%B7%A5%E5%8C%A0%EF%BC%9A%E5%96%84%E7%94%A8%E5%8F%98%E9%87%8F%E6%9D%A5%E6%94%B9%E5%96%84%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Python-工匠：善用变量来改善代码质量"><a href="#Python-工匠：善用变量来改善代码质量" class="headerlink" title="Python 工匠：善用变量来改善代码质量"></a>Python 工匠：善用变量来改善代码质量</h1><h2 id="『Python-工匠』是什么？"><a href="#『Python-工匠』是什么？" class="headerlink" title="『Python 工匠』是什么？"></a>『Python 工匠』是什么？</h2><p>我一直觉得编程某种意义上是一门『手艺』，因为优雅而高效的代码，就如同完美的手工艺品一样让人赏心悦目。</p>
<p>在雕琢代码的过程中，有大工程：比如应该用什么架构、哪种设计模式。也有更多的小细节，比如何时使用异常（Exceptions）、或怎么给变量起名。那些真正优秀的代码，正是由无数优秀的细节造就的。</p>
<p>『Python 工匠』这个系列文章，是我的一次小小尝试。它专注于分享 Python 编程中的一些偏<strong>『小』</strong>的东西。希望能够帮到每一位编程路上的匠人。</p>
<blockquote>
<p>这是 “Python 工匠”系列的第 1 篇文章。<a href="https://github.com/piglei/one-python-craftsman" target="_blank" rel="noopener">[查看系列所有文章]</a></p>
</blockquote>
<h2 id="变量和代码质量"><a href="#变量和代码质量" class="headerlink" title="变量和代码质量"></a>变量和代码质量</h2><p>作为『Python 工匠』系列文章的第一篇，我想先谈谈 『变量（Variables）』。因为如何定义和使用变量，一直都是学习任何一门编程语言最先要掌握的技能之一。</p>
<p>变量用的好或不好，和代码质量有着非常重要的联系。在关于变量的诸多问题中，为变量起一个好名字尤其重要。</p>
<h3 id="内容目录"><a href="#内容目录" class="headerlink" title="内容目录"></a>内容目录</h3><ul>
<li><a href="#如何为变量起名">如何为变量起名</a><ul>
<li><a href="#1-变量名要有描述性不能太宽泛">1. 变量名要有描述性，不能太宽泛</a></li>
<li><a href="#2-变量名最好让人能猜出类型">2. 变量名最好让人能猜出类型</a><ul>
<li><a href="#什么样的名字会被当成-bool-类型">『什么样的名字会被当成 bool 类型？』</a></li>
<li><a href="#什么样的名字会被当成-intfloat-类型">『什么样的名字会被当成 int/float 类型？』</a></li>
<li><a href="#其他类型">其他类型</a></li>
</ul>
</li>
<li><a href="#3-适当使用匈牙利命名法">3. 适当使用『匈牙利命名法』</a></li>
<li><a href="#4-变量名尽量短但是绝对不要太短">4. 变量名尽量短，但是绝对不要太短</a><ul>
<li><a href="#使用短名字的例外情况">使用短名字的例外情况</a></li>
</ul>
</li>
<li><a href="#5-其他注意事项">5. 其他注意事项</a></li>
</ul>
</li>
<li><a href="#更好的使用变量">更好的使用变量</a><ul>
<li><a href="#1-保持一致性">1. 保持一致性</a></li>
<li><a href="#2-尽量不要用-globalslocals">2. 尽量不要用 globals()/locals()</a></li>
<li><a href="#3-变量定义尽量靠近使用">3. 变量定义尽量靠近使用</a></li>
<li><a href="#4-合理使用-namedtupledict-来让函数返回多个值">4. 合理使用 namedtuple/dict 来让函数返回多个值</a></li>
<li><a href="#5-控制单个函数内的变量数量">5. 控制单个函数内的变量数量</a></li>
<li><a href="#6-及时删掉那些没用的变量">6. 及时删掉那些没用的变量</a></li>
<li><a href="#7-能不定义变量就不定义">7. 能不定义变量就不定义</a></li>
</ul>
</li>
<li><a href="#结语">结语</a></li>
</ul>
<h2 id="如何为变量起名"><a href="#如何为变量起名" class="headerlink" title="如何为变量起名"></a>如何为变量起名</h2><p>在计算机科学领域，有一句著名的格言（俏皮话）：</p>
<blockquote>
<p>There are only two hard things in Computer Science: cache invalidation and naming things.<br>在计算机科学领域只有两件难事：缓存过期 和 给东西起名字</p>
<p>– Phil Karlton</p>
</blockquote>
<p>第一个『缓存过期问题』的难度不用多说，任何用过缓存的人都会懂。至于第二个『给东西起名字』这事的难度，我也是深有体会。在我的职业生涯里，度过的最为黑暗的下午之一，就是坐在显示器前抓耳挠腮为一个新项目起一个合适的名字。</p>
<p>编程时起的最多的名字，还数各种变量。给变量起一个好名字很重要，<strong>因为好的变量命名可以极大提高代码的整体可读性。</strong></p>
<p>下面几点，是我总结的为变量起名时，最好遵守的基本原则。</p>
<h3 id="1-变量名要有描述性，不能太宽泛"><a href="#1-变量名要有描述性，不能太宽泛" class="headerlink" title="1. 变量名要有描述性，不能太宽泛"></a>1. 变量名要有描述性，不能太宽泛</h3><p>在<strong>可接受的长度范围内</strong>，变量名能把它所指向的内容描述的越精确越好。所以，尽量不要用那些过于宽泛的词来作为你的变量名：</p>
<ul>
<li><strong>BAD</strong>: <code>day</code>, <code>host</code>, <code>cards</code>, <code>temp</code></li>
<li><strong>GOOD</strong>:  <code>day_of_week</code>, <code>hosts_to_reboot</code>, <code>expired_cards</code></li>
</ul>
<h3 id="2-变量名最好让人能猜出类型"><a href="#2-变量名最好让人能猜出类型" class="headerlink" title="2. 变量名最好让人能猜出类型"></a>2. 变量名最好让人能猜出类型</h3><p>所有学习 Python 的人都知道，Python 是一门动态类型语言，它（至少在 <a href="https://www.python.org/dev/peps/pep-0484/" target="_blank" rel="noopener">PEP 484</a> 出现前）没有变量类型声明。所以当你看到一个变量时，除了通过上下文猜测，没法轻易知道它是什么类型。</p>
<p>不过，人们对于变量名和变量类型的关系，通常会有一些直觉上的约定，我把它们总结在了下面。</p>
<h4 id="『什么样的名字会被当成-bool-类型？』"><a href="#『什么样的名字会被当成-bool-类型？』" class="headerlink" title="『什么样的名字会被当成 bool 类型？』"></a>『什么样的名字会被当成 bool 类型？』</h4><p>布尔类型变量的最大特点是：它只存在两个可能的值<strong>『是』</strong> 或 <strong>『不是』</strong>。所以，用 <code>is</code>、<code>has</code> 等非黑即白的词修饰的变量名，会是个不错的选择。原则就是：<strong>让读到变量名的人觉得这个变量只会有『是』或『不是』两种值</strong>。</p>
<p>下面是几个不错的示例：</p>
<ul>
<li><code>is_superuser</code>：『是否超级用户』，只会有两种值：是/不是</li>
<li><code>has_error</code>：『有没有错误』，只会有两种值：有/没有</li>
<li><code>allow_vip</code>：『是否允许 VIP』，只会有两种值：允许/不允许</li>
<li><code>use_msgpack</code>：『是否使用 msgpack』，只会有两种值：使用/不使用</li>
<li><code>debug</code>：『是否开启调试模式』，被当做 bool 主要是因为约定俗成</li>
</ul>
<h4 id="『什么样的名字会被当成-int-float-类型？』"><a href="#『什么样的名字会被当成-int-float-类型？』" class="headerlink" title="『什么样的名字会被当成 int/float 类型？』"></a>『什么样的名字会被当成 int/float 类型？』</h4><p>人们看到和数字相关的名字，都会默认他们是 int/float 类型，下面这些是比较常见的：</p>
<ul>
<li>释义为数字的所有单词，比如：<code>port（端口号）</code>、<code>age（年龄）</code>、<code>radius（半径）</code> 等等</li>
<li>使用 _id 结尾的单词，比如：<code>user_id</code>、<code>host_id</code></li>
<li>使用 length/count 开头或者结尾的单词，比如： <code>length_of_username</code>、<code>max_length</code>、<code>users_count</code></li>
</ul>
<p><strong>注意：</strong>不要使用普通的复数来表示一个 int 类型变量，比如 <code>apples</code>、<code>trips</code>，最好用 <code>number_of_apples</code>、<code>trips_count</code> 来替代。</p>
<h4 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h4><p>对于 str、list、tuple、dict 这些复杂类型，很难有一个统一的规则让我们可以通过名字去猜测变量类型。比如 <code>headers</code>，既可能是一个头信息列表，也可能是包含头信息的 dict。</p>
<p>对于这些类型的变量名，最推荐的方式，就是编写规范的文档，在函数和方法的 document string 中，使用 sphinx 格式（<a href="http://www.sphinx-doc.org/en/stable/" target="_blank" rel="noopener">Python 官方文档使用的文档工具</a>）来标注所有变量的类型。 </p>
<h3 id="3-适当使用『匈牙利命名法』"><a href="#3-适当使用『匈牙利命名法』" class="headerlink" title="3. 适当使用『匈牙利命名法』"></a>3. 适当使用『匈牙利命名法』</h3><p>第一次知道『<a href="https://en.wikipedia.org/wiki/Hungarian_notation" target="_blank" rel="noopener">匈牙利命名法</a>』，是在 <a href="http://www.joelonsoftware.com/articles/Wrong.html" target="_blank" rel="noopener">Joel on Software 的一篇博文</a>中。简而言之，匈牙利命名法就是把变量的『类型』缩写，放到变量名的最前面。</p>
<p>关键在于，这里说的变量『类型』，并非指传统意义上的 int/str/list 这种类型，而是指那些和你的代码业务逻辑相关的类型。</p>
<p>比如，在你的代码中有两个变量：<code>students</code> 和 <code>teachers</code>，他们指向的内容都是一个包含 Person 对象的 list 。使用『匈牙利命名法』后，可以把这两个名字改写成这样：</p>
<p>students -&gt; <code>pl_students</code><br>teachers -&gt; <code>pl_teachers</code></p>
<p>其中 pl 是 <strong>person list</strong> 的首字母缩写。当变量名被加上前缀后，如果你看到以 <code>pl_</code> 打头的变量，就能知道它所指向的值类型了。</p>
<p>很多情况下，使用『匈牙利命名法』是个不错的主意，因为它可以改善你的代码可读性，尤其在那些变量众多、同一类型多次出现时。注意不要滥用就好。</p>
<h3 id="4-变量名尽量短，但是绝对不要太短"><a href="#4-变量名尽量短，但是绝对不要太短" class="headerlink" title="4. 变量名尽量短，但是绝对不要太短"></a>4. 变量名尽量短，但是绝对不要太短</h3><p>在前面，我们提到要让变量名有描述性。如果不给这条原则加上任何限制，那么你很有可能写出这种描述性极强的变量名：<code>how_much_points_need_for_level2</code>。如果代码中充斥着这种过长的变量名，对于代码可读性来说是个灾难。</p>
<p>一个好的变量名，长度应该控制在 <strong>两到三个单词左右</strong>。比如上面的名字，可以缩写为 <code>points_level2</code>。</p>
<p><strong>绝大多数情况下，都应该避免使用那些只有一两个字母的短名字</strong>，比如数组索引三剑客 <code>i</code>、<code>j</code>、<code>k</code>，用有明确含义的名字，比如 person_index 来代替它们总是会更好一些。</p>
<h4 id="使用短名字的例外情况"><a href="#使用短名字的例外情况" class="headerlink" title="使用短名字的例外情况"></a>使用短名字的例外情况</h4><p>有时，上面的原则也存在一些例外。当一些意义明确但是较长的变量名重复出现时，为了让代码更简洁，使用短名字缩写是完全可以的。但是为了降低理解成本，同一段代码内最好不要使用太多这种短名字。</p>
<p>比如在 Python 中导入模块时，就会经常用到短名字作为别名，像 Django i18n 翻译时常用的 <code>gettext</code> 方法通常会被缩写成 <code>_</code> 来使用<em>（from django.utils.translation import ugettext as _）</em></p>
<h3 id="5-其他注意事项"><a href="#5-其他注意事项" class="headerlink" title="5. 其他注意事项"></a>5. 其他注意事项</h3><p>其他一些给变量命名的注意事项：</p>
<ul>
<li>同一段代码内不要使用过于相似的变量名，比如同时出现 <code>users</code>、<code>users1</code>、 <code>user3</code> 这种序列</li>
<li>不要使用带否定含义的变量名，用 <code>is_special</code> 代替 <code>is_not_normal</code></li>
</ul>
<h2 id="更好的使用变量"><a href="#更好的使用变量" class="headerlink" title="更好的使用变量"></a>更好的使用变量</h2><p>前面讲了如何为变量取一个好名字，下面我们谈谈在日常使用变量时，应该注意的一些小细节。</p>
<h3 id="1-保持一致性"><a href="#1-保持一致性" class="headerlink" title="1. 保持一致性"></a>1. 保持一致性</h3><p>如果你在一个方法内里面把图片变量叫做 <code>photo</code>，在其他的地方就不要把它改成 <code>image</code>，这样只会让代码的阅读者困惑：『<code>image</code> 和 <code>photo</code> 到底是不是同一个东西？』</p>
<p>另外，虽然 Python 是动态类型语言，但那也不意味着你可以用同一个变量名一会表示 str 类型，过会又换成 list。<strong>同一个变量名指代的变量类型，也需要保持一致性。</strong></p>
<h3 id="2-尽量不要用-globals-locals"><a href="#2-尽量不要用-globals-locals" class="headerlink" title="2. 尽量不要用 globals()/locals()"></a>2. 尽量不要用 globals()/locals()</h3><p>也许你第一次发现 globals()/locals() 这对内建函数时很兴奋，迫不及待的写下下面这种极端『简洁』的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">render_trip_page</span><span class="params">(request, user_id, trip_id)</span>:</span></span><br><span class="line">    user = User.objects.get(id=user_id)</span><br><span class="line">    trip = get_object_or_404(Trip, pk=trip_id)</span><br><span class="line">    is_suggested = is_suggested(user, trip)</span><br><span class="line">    <span class="comment"># 利用 locals() 节约了三行代码，我是个天才！</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'trip.html'</span>, locals())</span><br></pre></td></tr></table></figure>

<p>千万不要这么做，这样只会让读到这段代码的人（包括三个月后的你自己）痛恨你，因为他需要记住这个函数内定义的所有变量（想想这个函数增长到两百行会怎么样？），更别提 locals() 还会把一些不必要的变量传递出去。</p>
<p>更何况， <a href="https://www.python.org/dev/peps/pep-0020/" target="_blank" rel="noopener">The Zen of Python（Python 之禅）</a> 说的清清楚楚：<strong>Explicit is better than implicit.（显式优于隐式）</strong>。所以，还是老老实实把代码写成这样吧：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> render(request, <span class="string">'trip.html'</span>, &#123;</span><br><span class="line">    <span class="string">'user'</span>: user,</span><br><span class="line">    <span class="string">'trip'</span>: trip,</span><br><span class="line">    <span class="string">'is_suggested'</span>: is_suggested</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="3-变量定义尽量靠近使用"><a href="#3-变量定义尽量靠近使用" class="headerlink" title="3. 变量定义尽量靠近使用"></a>3. 变量定义尽量靠近使用</h3><p>这个原则属于老生常谈了。很多人（包括我）在刚开始学习编程时，会有一个习惯。就是把所有的变量定义写在一起，放在函数或方法的最前面。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_trip_png</span><span class="params">(trip)</span>:</span></span><br><span class="line">    path = []</span><br><span class="line">    markers = []</span><br><span class="line">    photo_markers = []</span><br><span class="line">    text_markers = []</span><br><span class="line">    marker_count = <span class="number">0</span></span><br><span class="line">    point_count = <span class="number">0</span></span><br><span class="line">    ... ...</span><br></pre></td></tr></table></figure>

<p>这样做只会让你的代码『看上去很整洁』，但是对提高代码可读性没有任何帮助。</p>
<p>更好的做法是，<strong>让变量定义尽量靠近使用</strong>。那样当你阅读代码时，可以更好的理解代码的逻辑，而不是费劲的去想这个变量到底是什么、哪里定义的？</p>
<h3 id="4-合理使用-namedtuple-dict-来让函数返回多个值"><a href="#4-合理使用-namedtuple-dict-来让函数返回多个值" class="headerlink" title="4. 合理使用 namedtuple/dict 来让函数返回多个值"></a>4. 合理使用 namedtuple/dict 来让函数返回多个值</h3><p>Python 的函数可以返回多个值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">latlon_to_address</span><span class="params">(lat, lon)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> country, province, city</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用多返回值一次解包定义多个变量</span></span><br><span class="line">country, province, city = latlon_to_address(lat, lon)</span><br></pre></td></tr></table></figure>

<p>但是，这样的用法会产生一个小问题：如果某一天， <code>latlon_to_address</code> 函数需要返回『城区（District）』时怎么办？</p>
<p>如果是上面这种写法，你需要找到所有调用 <code>latlon_to_address</code> 的地方，补上多出来的这个变量，否则 <em>ValueError: too many values to unpack</em> 就会找上你：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">country, province, city, district = latlon_to_address(lat, lon)</span><br><span class="line"><span class="comment"># 或者使用 _ 忽略多出来的返回值</span></span><br><span class="line">country, province, city, _ = latlon_to_address(lat, lon)</span><br></pre></td></tr></table></figure>

<p>对于这种可能变动的多返回值函数，使用 namedtuple/dict 会更方便一些。当你新增返回值时，不会对之前的函数调用产生任何破坏性的影响：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 使用 dict</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">latlon_to_address</span><span class="params">(lat, lon)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">'country'</span>: country,</span><br><span class="line">        <span class="string">'province'</span>: province,</span><br><span class="line">        <span class="string">'city'</span>: city</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">addr_dict = latlon_to_address(lat, lon)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 使用 namedtuple</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Address = namedtuple(<span class="string">"Address"</span>, [<span class="string">'country'</span>, <span class="string">'province'</span>, <span class="string">'city'</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">latlon_to_address</span><span class="params">(lat, lon)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Address(</span><br><span class="line">        country=country,</span><br><span class="line">        province=province,</span><br><span class="line">        city=city</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">addr = latlon_to_address(lat, lon)</span><br></pre></td></tr></table></figure>

<p>不过这样做也有坏处，因为代码对变更的兼容性虽然变好了，但是你不能继续用之前 <code>x, y = f()</code> 的方式一次解包定义多个变量了。取舍在于你自己。</p>
<h3 id="5-控制单个函数内的变量数量"><a href="#5-控制单个函数内的变量数量" class="headerlink" title="5. 控制单个函数内的变量数量"></a>5. 控制单个函数内的变量数量</h3><p>人脑的能力是有限的，研究表明，人类的短期记忆只能同时记住不超过十个名字。所以，当你的某个函数过长（一般来说，超过一屏的的函数就会被认为有点过长了），包含了太多变量时。请及时把它拆分为多个小函数吧。</p>
<h3 id="6-及时删掉那些没用的变量"><a href="#6-及时删掉那些没用的变量" class="headerlink" title="6. 及时删掉那些没用的变量"></a>6. 及时删掉那些没用的变量</h3><p>这条原则非常简单，也很容易做到。但是如果没有遵守，那它对你的代码质量的打击是毁灭级的。会让阅读你代码的人有一种被愚弄的感觉。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fancy_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 读者心理：嗯，这里定义了一个 fancy_vars</span></span><br><span class="line">    fancy_vars = get_fancy()</span><br><span class="line">    ... ...（一大堆代码过后）</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读者心理：这里就结束了？之前的 fancy_vars 去哪了？被猫吃了吗？</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>所以，请打开 IDE 的智能提示，及时清理掉那些定义了但是没有使用的变量吧。</p>
<h3 id="7-能不定义变量就不定义"><a href="#7-能不定义变量就不定义" class="headerlink" title="7. 能不定义变量就不定义"></a>7. 能不定义变量就不定义</h3><p>有时候，我们定义变量时的心理活动是这样的：『嗯，这个值未来说不定会修改/二次使用』，让我们先把它定义成变量吧！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_best_trip_by_user_id</span><span class="params">(user_id)</span>:</span></span><br><span class="line">    user = get_user(user_id)</span><br><span class="line">    trip = get_best_trip(user_id)</span><br><span class="line">    result = &#123;</span><br><span class="line">        <span class="string">'user'</span>: user,</span><br><span class="line">        <span class="string">'trip'</span>: trip</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>其实，你所想的『未来』永远不会来，这段代码里的三个临时变量完全可以去掉，变成这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_best_trip_by_user_id</span><span class="params">(user_id)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">'user'</span>: get_user(user_id),</span><br><span class="line">        <span class="string">'trip'</span>: get_best_trip(user_id)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>没有必要为了那些可能出现的变动，牺牲代码当前的可读性。如果以后有定义变量的需求，那就以后再加吧。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>碎碎念了一大堆，不知道有多少人能够坚持到最后。变量作为程序语言的重要组成部分，值得我们在定义和使用它时，多花一丁点时间思考一下，那样会让你的代码变得更优秀。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/17/24%20%7C%20%E5%B8%A6%E4%BD%A0%E8%A7%A3%E6%9E%90%20Python%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/17/24%20%7C%20%E5%B8%A6%E4%BD%A0%E8%A7%A3%E6%9E%90%20Python%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" itemprop="url">24 | 带你解析 Python 垃圾回收机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-17T20:10:07+08:00">
                2019-12-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/" itemprop="url" rel="index">
                    <span itemprop="name">python核心技术与实战</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/17/24%20%7C%20%E5%B8%A6%E4%BD%A0%E8%A7%A3%E6%9E%90%20Python%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/12/17/24%20%7C%20%E5%B8%A6%E4%BD%A0%E8%A7%A3%E6%9E%90%20Python%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>众所周知，我们当代的计算机都是图灵机架构。图灵机架构的本质，就是一条无限长的纸带，对应着我们今天的存储器。在工程学的演化中，逐渐出现了寄存器、易失性存储器（内存）和永久性存储器（硬盘）等产品。其实，这本身来自一个矛盾：速度越快的存储器，单位价格也越昂贵。因此，妥善利用好每一寸高速存储器的空间，永远是系统设计的一个核心。</p>
<p>回到 Python 应用层。</p>
<p>我们知道，Python 程序在运行的时候，需要在内存中开辟出一块空间，用于存放运行时产生的临时变量；计算完成后，再将结果输出到永久性存储器中。如果数据量过大，内存空间管理不善就很容易出现 OOM（out of memory），俗称爆内存，程序可能被操作系统中止。</p>
<p>而对于服务器，这种设计为永不中断的系统来说，内存管理则显得更为重要，不然很容易引发内存泄漏。什么是内存泄漏呢？</p>
<ul>
<li>这里的泄漏，并不是说你的内存出现了信息安全问题，被恶意程序利用了，而是指程序本身没有设计好，导致程序未能释放已不再使用的内存。</li>
<li>内存泄漏也不是指你的内存在物理上消失了，而是意味着代码在分配了某段内存后，因为设计错误，失去了对这段内存的控制，从而造成了内存的浪费。<br>那么，Python 又是怎么解决这些问题的？换句话说，对于不会再用到的内存空间，Python 是通过什么机制来回收这些空间的呢？</li>
</ul>
<h3 id="计数引用"><a href="#计数引用" class="headerlink" title="计数引用"></a>计数引用</h3><p>我们反复提过好几次， Python 中一切皆对象。因此，你所看到的一切变量，本质上都是对象的一个指针。</p>
<p>那么，怎么知道一个对象，是否永远都不能被调用了呢？</p>
<p>我们上节课提到过的，也是非常直观的一个想法，就是当这个对象的引用计数（指针数）为 0 的时候，说明这个对象永不可达，自然它也就成为了垃圾，需要被回收。</p>
<p>我们来看一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> psutil</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 显示当前 python 程序占用的内存大小</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_memory_info</span><span class="params">(hint)</span>:</span></span><br><span class="line">    pid = os.getpid()</span><br><span class="line">    p = psutil.Process(pid)</span><br><span class="line">    </span><br><span class="line">    info = p.memory_full_info()</span><br><span class="line">    memory = info.uss / <span class="number">1024.</span> / <span class="number">1024</span></span><br><span class="line">    print(<span class="string">'&#123;&#125; memory used: &#123;&#125; MB'</span>.format(hint, memory))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    show_memory_info(<span class="string">'initial'</span>)</span><br><span class="line">    a = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000000</span>)]</span><br><span class="line">    show_memory_info(<span class="string">'after a created'</span>)</span><br><span class="line"> </span><br><span class="line">func()</span><br><span class="line">show_memory_info(<span class="string">'finished'</span>)</span><br></pre></td></tr></table></figure>

<pre><code>initial memory used: 34.12890625 MB
after a created memory used: 425.38671875 MB
finished memory used: 38.30859375 MB</code></pre><p>通过这个示例，你可以看到，调用函数 func()，在列表 a 被创建之后，内存占用迅速增加到了 433 MB：而在函数调用结束后，内存则返回正常。</p>
<p>这是因为，函数内部声明的列表 a 是局部变量，在函数返回后，局部变量的引用会注销掉；此时，列表 a 所指代对象的引用数为 0，Python 便会执行垃圾回收，因此之前占用的大量内存就又回来了。</p>
<p>明白了这个原理后，我们稍微修改一下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    show_memory_info(<span class="string">'initial'</span>)</span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    a = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000000</span>)]</span><br><span class="line">    show_memory_info(<span class="string">'after a created'</span>)</span><br><span class="line"> </span><br><span class="line">func()</span><br><span class="line">show_memory_info(<span class="string">'finished'</span>)</span><br></pre></td></tr></table></figure>

<pre><code>initial memory used: 38.06640625 MB
after a created memory used: 424.90625 MB
finished memory used: 424.91015625 MB</code></pre><p>新的这段代码中，global a 表示将 a 声明为全局变量。那么，即使函数返回后，列表的引用依然存在，于是对象就不会被垃圾回收掉，依然占用大量内存。</p>
<p>同样，如果我们把生成的列表返回，然后在主程序中接收，那么引用依然存在，垃圾回收就不会被触发，大量内存仍然被占用着：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    show_memory_info(<span class="string">'initial'</span>)</span><br><span class="line">    a = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000000</span>)]</span><br><span class="line">    show_memory_info(<span class="string">'after a created'</span>)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"> </span><br><span class="line">a = func()</span><br><span class="line">show_memory_info(<span class="string">'finished'</span>)</span><br></pre></td></tr></table></figure>

<pre><code>initial memory used: 425.5390625 MB
after a created memory used: 812.56640625 MB
finished memory used: 425.96875 MB</code></pre><p>这是最常见的几种情况。由表及里，下面，我们深入看一下 Python 内部的引用计数机制。老规矩，先来看代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line">a = []</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 两次引用，一次来自 a，一次来自 getrefcount</span></span><br><span class="line">print(sys.getrefcount(a))</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="comment"># 四次引用，a，python 的函数调用栈，函数参数，和 getrefcount</span></span><br><span class="line">    print(sys.getrefcount(a))</span><br><span class="line"> </span><br><span class="line">func(a)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 两次引用，一次来自 a，一次来自 getrefcount，函数 func 调用已经不存在</span></span><br><span class="line">print(sys.getrefcount(a))</span><br></pre></td></tr></table></figure>

<pre><code>2
4
2</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line">a = []</span><br><span class="line"> </span><br><span class="line">print(sys.getrefcount(a)) <span class="comment"># 两次</span></span><br><span class="line"> </span><br><span class="line">b = a</span><br><span class="line"> </span><br><span class="line">print(sys.getrefcount(a)) <span class="comment"># 三次</span></span><br><span class="line"> </span><br><span class="line">c = b</span><br><span class="line">d = b</span><br><span class="line">e = c</span><br><span class="line">f = e</span><br><span class="line">g = d</span><br><span class="line"> </span><br><span class="line">print(sys.getrefcount(a)) <span class="comment"># 八次</span></span><br><span class="line">print(sys.getrefcount(b)) <span class="comment"># 八次</span></span><br></pre></td></tr></table></figure>

<pre><code>2
3
8
8</code></pre><p>看到这段代码，需要你稍微注意一下，a、b、c、d、e、f、g 这些变量全部指代的是同一个对象，而 sys.getrefcount() 函数并不是统计一个指针，而是要统计一个对象被引用的次数，所以最后一共会有八次引用。</p>
<p>理解引用这个概念后，引用释放是一种非常自然和清晰的思想。相比 C 语言里，你需要使用 free 去手动释放内存，Python 的垃圾回收在这里可以说是省心省力了。</p>
<p>不过，我想还是会有人问，如果我偏偏想手动释放内存，应该怎么做呢？</p>
<p>方法同样很简单。你只需要先调用 del a 来删除一个对象；然后强制调用 gc.collect()，即可手动启动垃圾回收。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"> </span><br><span class="line">show_memory_info(<span class="string">'initial'</span>)</span><br><span class="line"> </span><br><span class="line">a = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000000</span>)]</span><br><span class="line"> </span><br><span class="line">show_memory_info(<span class="string">'after a created'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line">gc.collect()</span><br><span class="line"> </span><br><span class="line">show_memory_info(<span class="string">'finish'</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>

<pre><code>initial memory used: 34.25390625 MB
after a created memory used: 421.50390625 MB
finish memory used: 36.76953125 MB



---------------------------------------------------------------------------

NameError                                 Traceback (most recent call last)

&lt;ipython-input-10-d0af83fbc251&gt; in &lt;module&gt;
     11 
     12 show_memory_info(&apos;finish&apos;)
---&gt; 13 print(a)


NameError: name &apos;a&apos; is not defined</code></pre><p>到这里，是不是觉得垃圾回收非常简单呀？</p>
<p>我想，肯定有人觉得自己都懂了，那么，如果此时有面试官问：引用次数为 0 是垃圾回收启动的充要条件吗？还有没有其他可能性呢？</p>
<p>这个问题，你能回答的上来吗？</p>
<h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>如果你也被困住了，别急。我们不妨小步设问，先来思考这么一个问题：如果有两个对象，它们互相引用，并且不再被别的对象所引用，那么它们应该被垃圾回收吗？</p>
<p>请仔细观察下面这段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    show_memory_info(<span class="string">'initial'</span>)</span><br><span class="line">    a = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000000</span>)]</span><br><span class="line">    b = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000000</span>)]</span><br><span class="line">    show_memory_info(<span class="string">'after a, b created'</span>)</span><br><span class="line">    a.append(b)</span><br><span class="line">    b.append(a)</span><br><span class="line"> </span><br><span class="line">func()</span><br><span class="line">show_memory_info(<span class="string">'finished'</span>)</span><br></pre></td></tr></table></figure>

<pre><code>initial memory used: 30.015625 MB
after a, b created memory used: 566.953125 MB
finished memory used: 566.95703125 MB</code></pre><p>这里，a 和 b 互相引用，并且，作为局部变量，在函数 func 调用结束后，a 和 b 这两个指针从程序意义上已经不存在了。但是，很明显，依然有内存占用！为什么呢？因为互相引用，导致它们的引用数都不为 0。</p>
<p>试想一下，如果这段代码出现在生产环境中，哪怕 a 和 b 一开始占用的空间不是很大，但经过长时间运行后，Python 所占用的内存一定会变得越来越大，最终撑爆服务器，后果不堪设想。</p>
<p>当然，有人可能会说，互相引用还是很容易被发现的呀，问题不大。可是，更隐蔽的情况是出现一个引用环，在工程代码比较复杂的情况下，引用环还真不一定能被轻易发现。</p>
<p>那么，我们应该怎么做呢？</p>
<p>事实上，Python 本身能够处理这种情况，我们刚刚讲过的，可以显式调用 gc.collect() ，来启动垃圾回收。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    show_memory_info(<span class="string">'initial'</span>)</span><br><span class="line">    a = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000000</span>)]</span><br><span class="line">    b = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000000</span>)]</span><br><span class="line">    show_memory_info(<span class="string">'after a, b created'</span>)</span><br><span class="line">    a.append(b)</span><br><span class="line">    b.append(a)</span><br><span class="line"> </span><br><span class="line">func()</span><br><span class="line">gc.collect()</span><br><span class="line">show_memory_info(<span class="string">'finished'</span>)</span><br></pre></td></tr></table></figure>

<pre><code>initial memory used: 792.0390625 MB
after a, b created memory used: 1547.546875 MB
finished memory used: 36.73046875 MB</code></pre><p>所以你看，Python 的垃圾回收机制并没有那么弱。</p>
<p>Python 使用标记清除（mark-sweep）算法和分代收集（generational），来启用针对循环引用的自动垃圾回收。你可能不太熟悉这两个词，这里我简单介绍一下。</p>
<p>先来看标记清除算法。我们先用图论来理解不可达的概念。对于一个有向图，如果从一个节点出发进行遍历，并标记其经过的所有节点；那么，在遍历结束后，所有没有被标记的节点，我们就称之为不可达节点。显而易见，这些节点的存在是没有任何意义的，自然的，我们就需要对它们进行垃圾回收。</p>
<p>当然，每次都遍历全图，对于 Python 而言是一种巨大的性能浪费。所以，在 Python 的垃圾回收实现中，mark-sweep 使用双向链表维护了一个数据结构，并且只考虑容器类的对象（只有容器类对象才有可能产生循环引用）。具体算法这里我就不再多讲了，毕竟我们的重点是关注应用。</p>
<p>而分代收集算法，则是另一个优化手段。</p>
<p>Python 将所有对象分为三代。刚刚创立的对象是第 0 代；经过一次垃圾回收后，依然存在的对象，便会依次从上一代挪到下一代。而每一代启动自动垃圾回收的阈值，则是可以单独指定的。当垃圾回收器中新增对象减去删除对象达到相应的阈值时，就会对这一代对象启动垃圾回收。</p>
<p>事实上，分代收集基于的思想是，新生的对象更有可能被垃圾回收，而存活更久的对象也有更高的概率继续存活。因此，通过这种做法，可以节约不少计算量，从而提高 Python 的性能。</p>
<p>学了这么多，刚刚面试官的问题，你应该能回答得上来了吧！没错，引用计数是其中最简单的实现，不过切记，引用计数并非充要条件，它只能算作充分非必要条件；至于其他的可能性，我们所讲的循环引用正是其中一种。</p>
<h3 id="调试内存泄漏"><a href="#调试内存泄漏" class="headerlink" title="调试内存泄漏"></a>调试内存泄漏</h3><p>不过，虽然有了自动回收机制，但这也不是万能的，难免还是会有漏网之鱼。内存泄漏是我们不想见到的，而且还会严重影响性能。有没有什么好的调试手段呢？</p>
<p>答案当然是肯定的，接下来我就为你介绍一个“得力助手”。</p>
<p>它就是 objgraph，一个非常好用的可视化引用关系的包。在这个包中，我主要推荐两个函数，第一个是 show_refs()，它可以生成清晰的引用关系图。</p>
<p>通过下面这段代码和生成的引用调用图，你能非常直观地发现，有两个 list 互相引用，说明这里极有可能引起内存泄露。这样一来，再去代码层排查就容易多了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> objgraph</span><br><span class="line"> </span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"> </span><br><span class="line">a.append(b)</span><br><span class="line">b.append(a)</span><br><span class="line"> </span><br><span class="line">objgraph.show_refs([a])</span><br></pre></td></tr></table></figure>




<p><img src="/2019/12/17/24%20%7C%20%E5%B8%A6%E4%BD%A0%E8%A7%A3%E6%9E%90%20Python%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/24%20%7C%20%E5%B8%A6%E4%BD%A0%E8%A7%A3%E6%9E%90%20Python%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6_17_0.svg" alt="svg"></p>
<p>而另一个非常有用的函数，是 show_backrefs()。下面同样为示例代码和生成图，你可以自己先阅读一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> objgraph</span><br><span class="line"> </span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"> </span><br><span class="line">a.append(b)</span><br><span class="line">b.append(a)</span><br><span class="line"> </span><br><span class="line">objgraph.show_backrefs([a])</span><br></pre></td></tr></table></figure>




<p><img src="/2019/12/17/24%20%7C%20%E5%B8%A6%E4%BD%A0%E8%A7%A3%E6%9E%90%20Python%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/24%20%7C%20%E5%B8%A6%E4%BD%A0%E8%A7%A3%E6%9E%90%20Python%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6_19_0.svg" alt="svg"></p>
<p>相比刚才的引用调用图，这张图显得稍微复杂一些。不过，我仍旧推荐你掌握它，因为这个 API 有很多有用的参数，比如层数限制（max_depth）、宽度限制（too_many）、输出格式控制（filename output）、节点过滤（filter, extra_ignore）等。所以，建议你使用之前，先认真看一下文档。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后，带你来总结一下。今天这节课，我们深入了解了 Python 的垃圾回收机制，我主要强调下面这几点：</p>
<ol>
<li>垃圾回收是 Python 自带的机制，用于自动释放不会再用到的内存空间；</li>
<li>引用计数是其中最简单的实现，不过切记，这只是充分非必要条件，因为循环引用需要通过不可达判定，来确定是否可以回收；</li>
<li>Python 的自动回收算法包括标记清除和分代收集，主要针对的是循环引用的垃圾收集；</li>
<li>调试内存泄漏方面， objgraph 是很好的可视化分析工具。</li>
</ol>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>最后给你留一道思考题。你能否自己实现一个垃圾回收判定算法呢？我的要求很简单，输入是一个有向图，给定起点，表示程序入口点；给定有向边，输出不可达节点。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">&lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">LvYang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">35</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LvYang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    





  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'qcq1G35cOv9sG5BrpbdXJwtJ-gzGzoHsz',
        appKey: 'VtFEF7WhBgSXbcGzdO1GztzO',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
