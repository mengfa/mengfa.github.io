<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="LvYang">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="LvYang">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>LvYang</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LvYang</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/23/04%E4%B8%A8%E4%BD%BF%E7%94%A8DDL%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93&%E6%95%B0%E6%8D%AE%E8%A1%A8%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/23/04%E4%B8%A8%E4%BD%BF%E7%94%A8DDL%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93&%E6%95%B0%E6%8D%AE%E8%A1%A8%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F/" itemprop="url">04丨使用DDL创建数据库&数据表时需要注意什么？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-23T20:52:07+08:00">
                2020-03-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/" itemprop="url" rel="index">
                    <span itemprop="name">SQL必知必会</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/23/04%E4%B8%A8%E4%BD%BF%E7%94%A8DDL%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93&%E6%95%B0%E6%8D%AE%E8%A1%A8%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/03/23/04%E4%B8%A8%E4%BD%BF%E7%94%A8DDL%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93&%E6%95%B0%E6%8D%AE%E8%A1%A8%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>DDL 是 DBMS 的核心组件，也是 SQL 的重要组成部分，DDL 的正确性和稳定性是整个 SQL 运行的重要基础。面对同一个需求，不同的开发人员创建出来的数据库和数据表可能千差万别，那么在设计数据库的时候，究竟什么是好的原则？我们在创建数据表的时候需要注意什么？</p>
<p>今天的内容，你可以从以下几个角度来学习：</p>
<ol>
<li>了解 DDL 的基础语法，它如何定义数据库和数据表；</li>
<li>使用 DDL 定义数据表时，都有哪些约束性；</li>
<li>使用 DDL 设计数据库时，都有哪些重要原则。</li>
</ol>
<h3 id="DDL-的基础语法及设计工具"><a href="#DDL-的基础语法及设计工具" class="headerlink" title="DDL 的基础语法及设计工具"></a>DDL 的基础语法及设计工具</h3><p>DDL 的英文全称是 Data Definition Language，中文是数据定义语言。它定义了数据库的结构和数据表的结构。</p>
<p>在 DDL 中，我们常用的功能是增删改，分别对应的命令是 CREATE、DROP 和 ALTER。需要注意的是，在执行 DDL 的时候，不需要 COMMIT，就可以完成执行任务。</p>
<h4 id="1-对数据库进行定义"><a href="#1-对数据库进行定义" class="headerlink" title="1.对数据库进行定义"></a>1.对数据库进行定义</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE nba; // 创建一个名为 nba 的数据库</span><br><span class="line">DROP DATABASE nba; // 删除一个名为 nba 的数据库</span><br></pre></td></tr></table></figure>

<h4 id="2-对数据表进行定义"><a href="#2-对数据表进行定义" class="headerlink" title="2.对数据表进行定义"></a>2.对数据表进行定义</h4><p>创建表结构的语法是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name</span><br></pre></td></tr></table></figure>

<h3 id="创建表结构"><a href="#创建表结构" class="headerlink" title="创建表结构"></a>创建表结构</h3><p>比如我们想创建一个球员表，表名为 player，里面有两个字段，一个是 player_id，它是 int 类型，另一个 player_name 字段是varchar(255)类型。这两个字段都不为空，且 player_id 是递增的。</p>
<p>那么创建的时候就可以写为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE player  (</span><br><span class="line">  player_id int(<span class="number">11</span>) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  player_name varchar(<span class="number">255</span>) NOT NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>需要注意的是，语句最后以分号（;）作为结束符，最后一个字段的定义结束后没有逗号。数据类型中 int(11) 代表整数类型，显示长度为 11 位，括号中的参数 11 代表的是最大有效显示长度，与类型包含的数值范围大小无关。varchar(255)代表的是最大长度为 255 的可变字符串类型。NOT NULL表明整个字段不能是空值，是一种数据约束。AUTO_INCREMENT代表主键自动增长。</p>
<p>实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具来创建和操作数据库和数据表。在这里我推荐使用 Navicat，它是一个数据库管理和设计工具，跨平台，支持很多种数据库管理软件，比如 MySQL、Oracle、MariaDB 等。基本上专栏讲到的数据库软件都可以使用 Navicat 来管理。</p>
<p>假如还是针对 player 这张表，我们想设计以下的字段：</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">含义</th>
<th align="left">类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">player_id</td>
<td align="left">球员ID</td>
<td align="left">int整数类型,最大显示长度11</td>
</tr>
<tr>
<td align="left">team_id</td>
<td align="left">球队ID</td>
<td align="left">int整数类型,最大显示长度11</td>
</tr>
<tr>
<td align="left">player_name</td>
<td align="left">球员姓名</td>
<td align="left">varchar字符串类型,最大长度255</td>
</tr>
<tr>
<td align="left">height</td>
<td align="left">身高</td>
<td align="left">float浮点类型,一共存储3个有效数字,其中小数点长度为2.</td>
</tr>
</tbody></table>
<p>其中 player_id 是数据表 player 的主键，且自动增长，也就是 player_id 会从 1 开始，然后每次加 1。player_id、team_id、player_name 这三个字段均不为空，height 字段可以为空。</p>
<p>按照上面的设计需求，我们可以使用 Navicat 软件进行设计.<br>然后，我们还可以对 player_name 字段进行索引，索引类型为Unique。<br>这样一张 player 表就通过可视化工具设计好了。我们可以把这张表导出来，可以看看这张表对应的 SQL 语句是怎样的。方法是在 Navicat 左侧用右键选中 player 这张表，然后选择“转储 SQL 文件”→“仅结构”，这样就可以看到导出的 SQL 文件了，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS `player`;</span><br><span class="line">CREATE TABLE `player`  (</span><br><span class="line">  `player_id` int(<span class="number">11</span>) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `team_id` int(<span class="number">11</span>) NOT NULL,</span><br><span class="line">  `player_name` varchar(<span class="number">255</span>) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,</span><br><span class="line">  `height` float(<span class="number">3</span>, <span class="number">2</span>) NULL DEFAULT <span class="number">0.00</span>,</span><br><span class="line">  PRIMARY KEY (`player_id`) USING BTREE,</span><br><span class="line">  UNIQUE INDEX `player_name`(`player_name`) USING BTREE</span><br><span class="line">) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;</span><br></pre></td></tr></table></figure>

<p>你能看到整个 SQL 文件中的 DDL 处理，首先先删除 player 表（如果数据库中存在该表的话），然后再创建 player 表，里面的数据表和字段都使用了反引号，这是为了避免它们的名称与 MySQL 保留字段相同，对数据表和字段名称都加上了反引号。</p>
<p>其中 player_name 字段的字符集是 utf8，排序规则是utf8_general_ci，代表对大小写不敏感，如果设置为utf8_bin，代表对大小写敏感，还有许多其他排序规则这里不进行介绍。</p>
<p>因为 player_id 设置为了主键，因此在 DDL 中使用PRIMARY KEY进行规定，同时索引方法采用 BTREE。</p>
<p>因为我们对 player_name 字段进行索引，在设置字段索引时，我们可以设置为UNIQUE INDEX（唯一索引），也可以设置为其他索引方式，比如NORMAL INDEX（普通索引），这里我们采用UNIQUE INDEX。唯一索引和普通索引的区别在于它对字段进行了唯一性的约束。在索引方式上，你可以选择BTREE或者HASH，这里采用了BTREE方法进行索引。我会在后面介绍BTREE和HASH索引方式的区别。</p>
<p>整个数据表的存储规则采用 InnoDB。之前我们简单介绍过 InnoDB，它是 MySQL5.5 版本之后默认的存储引擎。同时，我们将字符集设置为 utf8，排序规则为utf8_general_ci，行格式为Dynamic，就可以定义数据表的最后约定了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;</span><br></pre></td></tr></table></figure>

<p>你能看出可视化工具还是非常方便的，它能直接帮我们将数据库的结构定义转化成 SQL 语言，方便数据库和数据表结构的导出和导入。不过在使用可视化工具前，你首先需要了解对于 DDL 的基础语法，至少能清晰地看出来不同字段的定义规则、索引方法，以及主键和外键的定义。</p>
<h3 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h3><p>在创建表结构之后，我们还可以对表结构进行修改，虽然直接使用 Navicat 可以保证重新导出的数据表就是最新的，但你也有必要了解，如何使用 DDL 命令来完成表结构的修改。</p>
<ol>
<li>添加字段，比如我在数据表中添加一个 age 字段，类型为int(11)</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE player ADD (age int(<span class="number">11</span>));</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改字段名，将 age 字段改成player_age</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE player RENAME COLUMN age to player_age</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>修改字段的数据类型，将player_age的数据类型设置为float(3,1)</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE player MODIFY (player_age float(<span class="number">3</span>,<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>删除字段, 删除刚才添加的player_age字段</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE player DROP COLUMN player_age;</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 数据表的常见约束</span></span><br><span class="line">当我们创建数据表的时候，还会对字段进行约束，约束的目的在于保证 RDBMS 里面数据的准确性和一致性。下面，我们来看下常见的约束有哪些。</span><br><span class="line"></span><br><span class="line">首先是主键约束。</span><br><span class="line"></span><br><span class="line">主键起的作用是唯一标识一条记录，不能重复，不能为空，即 UNIQUE+NOT NULL。一个数据表的主键只能有一个。主键可以是一个字段，也可以由多个字段复合组成。在上面的例子中，我们就把 player_id 设置为了主键。</span><br><span class="line"></span><br><span class="line">其次还有外键约束。</span><br><span class="line"></span><br><span class="line">外键确保了表与表之间引用的完整性。一个表中的外键对应另一张表的主键。外键可以是重复的，也可以为空。比如 player_id 在 player 表中是主键，如果你想设置一个球员比分表即 player_score，就可以在 player_score 中设置 player_id 为外键，关联到 player 表中。</span><br><span class="line"></span><br><span class="line">除了对键进行约束外，还有字段约束。</span><br><span class="line"></span><br><span class="line">唯一性约束。</span><br><span class="line"></span><br><span class="line">唯一性约束表明了字段在表中的数值是唯一的，即使我们已经有了主键，还可以对其他字段进行唯一性约束。比如我们在 player 表中给 player_name 设置唯一性约束，就表明任何两个球员的姓名不能相同。需要注意的是，唯一性约束和普通索引（NORMAL INDEX）之间是有区别的。唯一性约束相当于创建了一个约束和普通索引，目的是保证字段的正确性，而普通索引只是提升数据检索的速度，并不对字段的唯一性进行约束。</span><br><span class="line"></span><br><span class="line">NOT NULL 约束。对字段定义了 NOT NULL，即表明该字段不应为空，必须有取值。</span><br><span class="line"></span><br><span class="line">DEFAULT，表明了字段的默认值。如果在插入数据的时候，这个字段没有取值，就设置为默认值。比如我们将身高 height 字段的取值默认设置为 <span class="number">0.00</span>，即DEFAULT <span class="number">0.00</span>。</span><br><span class="line"></span><br><span class="line">CHECK 约束，用来检查特定字段取值范围的有效性，CHECK 约束的结果不能为 FALSE，比如我们可以对身高 height 的数值进行 CHECK 约束，必须≥<span class="number">0</span>，且＜<span class="number">3</span>，即CHECK(height&gt;=<span class="number">0</span> AND height&lt;<span class="number">3</span>)。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 设计数据表的原则</span></span><br><span class="line">我们在设计数据表的时候，经常会考虑到各种问题，比如：用户都需要什么数据？需要在数据表中保存哪些数据？哪些数据是经常访问的数据？如何提升检索效率？</span><br><span class="line"></span><br><span class="line">如何保证数据表中数据的正确性，当插入、删除、更新的时候该进行怎样的约束检查？</span><br><span class="line"></span><br><span class="line">如何降低数据表的数据冗余度，保证数据表不会因为用户量的增长而迅速扩张？</span><br><span class="line"></span><br><span class="line">如何让负责数据库维护的人员更方便地使用数据库？</span><br><span class="line"></span><br><span class="line">除此以外，我们使用数据库的应用场景也各不相同，可以说针对不同的情况，设计出来的数据表可能千差万别。那么有没有一种设计原则可以让我们来借鉴呢？这里我整理了一个“三少一多”原则：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>数据表的个数越少越好</span><br><span class="line"></span><br><span class="line">RDBMS 的核心在于对实体和联系的定义，也就是 E-R 图（Entity Relationship Diagram），数据表越少，证明实体和联系设计得越简洁，既方便理解又方便操作。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>数据表中的字段个数越少越好</span><br><span class="line"></span><br><span class="line">字段个数越多，数据冗余的可能性越大。设置字段个数少的前提是各个字段相互独立，而不是某个字段的取值可以由其他字段计算出来。当然字段个数少是相对的，我们通常会在数据冗余和检索效率中进行平衡。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>数据表中联合主键的字段个数越少越好</span><br><span class="line"></span><br><span class="line">设置主键是为了确定唯一性，当一个字段无法确定唯一性的时候，就需要采用联合主键的方式（也就是用多个字段来定义一个主键）。联合主键中的字段越多，占用的索引空间越大，不仅会加大理解难度，还会增加运行时间和索引空间，因此联合主键的字段个数越少越好。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>使用主键和外键越多越好</span><br><span class="line"></span><br><span class="line">数据库的设计实际上就是定义各种表，以及各种字段之间的关系。这些关系越多，证明这些实体之间的冗余度越低，利用度越高。这样做的好处在于不仅保证了数据表之间的独立性，还能提升相互之间的关联使用率。</span><br><span class="line"></span><br><span class="line">你应该能看出来“三少一多”原则的核心就是简单可复用。简单指的是用更少的表、更少的字段、更少的联合主键字段来完成数据表的设计。可复用则是通过主键、外键的使用来增强数据表之间的复用率。因为一个主键可以理解是一张表的代表。键设计得越多，证明它们之间的利用率越高。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 总结</span></span><br><span class="line">今天我们学习了 DDL 的基础语法，比如如何对数据库和数据库表进行定义，也了解了使用 Navicat 可视化管理工具来辅助我们完成数据表的设计，省去了手写 SQL 的工作量。</span><br><span class="line"></span><br><span class="line">在创建数据表的时候，除了对字段名及数据类型进行定义以外，我们考虑最多的就是关于字段的约束，我介绍了 <span class="number">7</span> 种常见的约束，它们都是数据表设计中会用到的约束：主键、外键、唯一性、NOT NULL、DEFAULT、CHECK 约束等。</span><br><span class="line"></span><br><span class="line">当然，了解了如何操作创建数据表之后，你还需要动脑思考，怎样才能设计出一个好的数据表？设计的原则都有哪些？针对这个，我整理出了“三少一多”原则，在实际使用过程中，你需要灵活掌握，因为这个原则并不是绝对的，有时候我们需要牺牲数据的冗余度来换取数据处理的效率。</span><br></pre></td></tr></table></figure>

<h3 id="我们在创建数据表的时候，会对数据表设置主键、外键和索引。你能说下这三者的作用和区别吗？"><a href="#我们在创建数据表的时候，会对数据表设置主键、外键和索引。你能说下这三者的作用和区别吗？" class="headerlink" title="我们在创建数据表的时候，会对数据表设置主键、外键和索引。你能说下这三者的作用和区别吗？"></a>我们在创建数据表的时候，会对数据表设置主键、外键和索引。你能说下这三者的作用和区别吗？</h3><p>主键：唯一标识一条记录，不能重复，不能为空。<br>外键：确保了表于表之间引用的完整性，可以重复，可以为空<br>索引：提升数据检索速度<br>区别：主键是索引的一种，而且是唯一索引的一种。而并非在是索引，是两表之间的链接</p>
<h3 id="外键多了会有很多维护问题吧？"><a href="#外键多了会有很多维护问题吧？" class="headerlink" title="外键多了会有很多维护问题吧？"></a>外键多了会有很多维护问题吧？</h3><p>作者回复: 是否使用外键确实会有一些争议。我来解释下关于外键的使用：<br>首先，外键本身是为了实现强一致性，所以如果需要正确性&gt;性能的话，还是建议使用外键，它可以让我们在数据库的层面保证数据的完整性和一致性。<br>当然不用外键，你也可以在业务层进行实现。不过，这样做也同样存在一定的风险，因为这样，就会让业务逻辑会与数据具备一定的耦合性。也就是业务逻辑和数据必须同时修改。而且在工作中，业务层可能会经常发生变化。</p>
<p>当然，很多互联网的公司，尤其是超大型的数据应用场景，大量的插入，更新和删除在外键的约束下会降低性能，同时数据库在水平拆分和分库的情况下，数据库端也做不到执行外键约束。另外，在高并发的情况下，外键的存在也会造成额外的开销。因为每次更新数据，都需要检查另外一张表的数据，也容易造成死锁。<br>所以在这种情况下，尤其是大型项目中后期，可以采用业务层来实现，取消外键提高效率。<br>不过在SQL学习之初，包括在系统最初设计的时候，还是建议你采用规范的数据库设计，也就是采用外键来对数据表进行约束。因为这样可以建立一个强一致性，可靠性高的数据库结构，也不需要在业务层来实现过多的检查。<br>当然在项目后期，业务量增大的情况下，你需要更多考虑到数据库性能问题，可以取消外键的约束，转移到业务层来实现。而且在大型互联网项目中，考虑到分库分表的情况，也会降低外键的使用。<br>不过在SQL学习，以及项目早期，还是建议你使用外键。在项目后期，你可以分析有哪些外键造成了过多的性能消耗。一般遵循2/8原则，会有20%的外键造成80%的资源效率，你可以只把这20%的外键进行开放，采用业务层逻辑来进行实现，当然你需要保证业务层的实现没有错误。不同阶段，考虑的问题不同。当用户和业务量增大的时候，对于大型互联网应用，也会通过减少外键的使用，来减低死锁发生的概率，提高并发处理能力。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/23/03%E4%B8%A8%E5%AD%A6%E4%BC%9A%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%96%B9%E5%BC%8F%E6%80%9D%E8%80%83SQL%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/23/03%E4%B8%A8%E5%AD%A6%E4%BC%9A%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%96%B9%E5%BC%8F%E6%80%9D%E8%80%83SQL%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/" itemprop="url">03丨学会用数据库的方式思考SQL是如何执行的</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-23T20:29:07+08:00">
                2020-03-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/" itemprop="url" rel="index">
                    <span itemprop="name">SQL必知必会</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/23/03%E4%B8%A8%E5%AD%A6%E4%BC%9A%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%96%B9%E5%BC%8F%E6%80%9D%E8%80%83SQL%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/03/23/03%E4%B8%A8%E5%AD%A6%E4%BC%9A%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%96%B9%E5%BC%8F%E6%80%9D%E8%80%83SQL%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>通过上一篇文章对不同的 DBMS 的介绍，你应该对它们有了一些基础的了解。虽然 SQL 是声明式语言，我们可以像使用英语一样使用它，不过在 RDBMS（关系型数据库管理系统）中，SQL 的实现方式还是有差别的。今天我们就从数据库的角度来思考一下 SQL 是如何被执行的。</p>
<p>关于今天的内容，你会从以下几个方面进行学习：</p>
<ol>
<li>Oracle 中的 SQL 是如何执行的，什么是硬解析和软解析；</li>
<li>MySQL 中的 SQL 是如何执行的，MySQL 的体系结构又是怎样的；</li>
<li>什么是存储引擎，MySQL 的存储引擎都有哪些？</li>
</ol>
<h3 id="Oracle-中的-SQL-是如何执行的"><a href="#Oracle-中的-SQL-是如何执行的" class="headerlink" title="Oracle 中的 SQL 是如何执行的"></a>Oracle 中的 SQL 是如何执行的</h3><p>我们先来看下 SQL 在 Oracle 中的执行过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">                     SQL语句</span><br><span class="line">                        |</span><br><span class="line">                        |                   硬解析</span><br><span class="line">语法检查----&gt;语义检查----&gt;权限检查----&gt;共享池检查-----&gt;优化器</span><br><span class="line">                                     |             |</span><br><span class="line">                              软解析  |             |</span><br><span class="line">                                    执行-------------</span><br><span class="line">                                   </span><br><span class="line">```                                   </span><br><span class="line"></span><br><span class="line">从上面这张图中可以看出，SQL 语句在 Oracle 中经历了以下的几个步骤。</span><br><span class="line"></span><br><span class="line">1. 语法检查：检查 SQL 拼写是否正确，如果不正确，Oracle 会报语法错误。</span><br><span class="line"></span><br><span class="line">2. 语义检查：检查 SQL 中的访问对象是否存在。比如我们在写 SELECT 语句的时候，列名写错了，系统就会提示错误。语法检查和语义检查的作用是保证 SQL 语句没有错误。</span><br><span class="line"></span><br><span class="line">3. 权限检查：看用户是否具备访问该数据的权限。</span><br><span class="line"></span><br><span class="line">4. 共享池检查：共享池（Shared Pool）是一块内存池，最主要的作用是缓存 SQL 语句和该语句的执行计划。Oracle 通过检查共享池是否存在 SQL 语句的执行计划，来判断进行软解析，还是硬解析。那软解析和硬解析又该怎么理解呢？</span><br><span class="line"></span><br><span class="line">在共享池中，Oracle 首先对 SQL 语句进行 Hash 运算，然后根据 Hash 值在库缓存（Library Cache）中查找，如果存在 SQL 语句的执行计划，就直接拿来执行，直接进入“执行器”的环节，这就是软解析。</span><br><span class="line"></span><br><span class="line">如果没有找到 SQL 语句和执行计划，Oracle 就需要创建解析树进行解析，生成执行计划，进入“优化器”这个步骤，这就是硬解析。</span><br><span class="line"></span><br><span class="line">5. 优化器：优化器中就是要进行硬解析，也就是决定怎么做，比如创建解析树，生成执行计划。</span><br><span class="line"></span><br><span class="line">6. 执行器：当有了解析树和执行计划之后，就知道了 SQL 该怎么被执行，这样就可以在执行器中执行语句了。</span><br><span class="line"></span><br><span class="line">共享池是 Oracle 中的术语，包括了库缓存，数据字典缓冲区等。我们上面已经讲到了库缓存区，它主要缓存 SQL 语句和执行计划。而数据字典缓冲区存储的是 Oracle 中的对象定义，比如表、视图、索引等对象。当对 SQL 语句进行解析的时候，如果需要相关的数据，会从数据字典缓冲区中提取。</span><br><span class="line"></span><br><span class="line">库缓存这一个步骤，决定了 SQL 语句是否需要进行硬解析。为了提升 SQL 的执行效率，我们应该尽量避免硬解析，因为在 SQL 的执行过程中，创建解析树，生成执行计划是很消耗资源的。</span><br><span class="line"></span><br><span class="line">你可能会问，如何避免硬解析，尽量使用软解析呢？在 Oracle 中，绑定变量是它的一大特色。绑定变量就是在 SQL 语句中使用变量，通过不同的变量取值来改变 SQL 的执行结果。这样做的好处是能提升软解析的可能性，不足之处在于可能会导致生成的执行计划不够优化，因此是否需要绑定变量还需要视情况而定。</span><br><span class="line"></span><br><span class="line">举个例子，我们可以使用下面的查询语句：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">SQL&gt; select * from player where player_id = 10001;</span><br></pre></td></tr></table></figure>

<p>你也可以使用绑定变量，如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * <span class="keyword">from</span> player where player_id = :player_id;</span><br></pre></td></tr></table></figure>

<p>这两个查询语句的效率在 Oracle 中是完全不同的。如果你在查询 player_id = 10001 之后，还会查询 10002、10003 之类的数据，那么每一次查询都会创建一个新的查询解析。而第二种方式使用了绑定变量，那么在第一次查询之后，在共享池中就会存在这类查询的执行计划，也就是软解析。</p>
<p>因此我们可以通过使用绑定变量来减少硬解析，减少 Oracle 的解析工作量。但是这种方式也有缺点，使用动态 SQL 的方式，因为参数不同，会导致 SQL 的执行效率不同，同时 SQL 优化也会比较困难。</p>
<h3 id="MySQL-中的-SQL-是如何执行的"><a href="#MySQL-中的-SQL-是如何执行的" class="headerlink" title="MySQL 中的 SQL 是如何执行的"></a>MySQL 中的 SQL 是如何执行的</h3><p>Oracle 中采用了共享池来判断 SQL 语句是否存在缓存和执行计划，通过这一步骤我们可以知道应该采用硬解析还是软解析。那么在 MySQL 中，SQL 是如何被执行的呢？</p>
<p>首先 MySQL 是典型的 C/S 架构，即 Client/Server 架构，服务器端程序使用的 mysqld。整体的 MySQL 流程如下图所示：</p>
<p>你能看到 MySQL 由三层组成：</p>
<ol>
<li>连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端；</li>
<li>SQL 层：对 SQL 语句进行查询处理；</li>
<li>存储引擎层：与数据库文件打交道，负责数据的存储和读取。</li>
</ol>
<p>其中 SQL 层与数据库文件的存储方式无关，我们来看下 SQL 层的结构：</p>
<p>SQL语句 —-&gt;解析器—-&gt;优化器—-&gt;执行器—|<br>    |        ^                           |-&gt;输出结果<br>    |        |没找到                      |<br>    |        |                           |<br>    |——-&gt;缓存查询&lt;——————–|找到</p>
<ol>
<li>询缓存：Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在 MySQL8.0 之后就抛弃了这个功能。</li>
<li>解析器：在解析器中对 SQL 语句进行语法分析、语义分析。</li>
<li>优化器：在优化器中会确定 SQL 语句的执行路径，比如是根据全表检索，还是根据索引来检索等。</li>
<li>执行器：在执行之前需要判断该用户是否具备权限，如果具备权限就执行 SQL 查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。</li>
</ol>
<p>你能看到 SQL 语句在 MySQL 中的流程是：SQL 语句→缓存查询→解析器→优化器→执行器。在一部分中，MySQL 和 Oracle 执行 SQL 的原理是一样的。</p>
<p>与 Oracle 不同的是，MySQL 的存储引擎采用了插件的形式，每个存储引擎都面向一种特定的数据库应用环境。同时开源的 MySQL 还允许开发人员设置自己的存储引擎，下面是一些常见的存储引擎：</p>
<ol>
<li>InnoDB 存储引擎：它是 MySQL 5.5 版本之后默认的存储引擎，最大的特点是支持事务、行级锁定、外键约束等。</li>
<li>MyISAM 存储引擎：在 MySQL 5.5 版本之前是默认的存储引擎，不支持事务，也不支持外键，最大的特点是速度快，占用资源少。</li>
<li>Memory 存储引擎：使用系统内存作为存储介质，以便得到更快的响应速度。不过如果 mysqld 进程崩溃，则会导致所有的数据丢失，因此我们只有当数据是临时的情况下才使用 Memory 存储引擎。</li>
<li>NDB 存储引擎：也叫做 NDB Cluster 存储引擎，主要用于 MySQL Cluster 分布式集群环境，类似于 Oracle 的 RAC 集群。</li>
<li>Archive 存储引擎：它有很好的压缩机制，用于文件归档，在请求写入时会进行压缩，所以也经常用来做仓库。</li>
</ol>
<p>需要注意的是，数据库的设计在于表的设计，而在 MySQL 中每个表的设计都可以采用不同的存储引擎，我们可以根据实际的数据处理需要来选择存储引擎，这也是 MySQL 的强大之处。</p>
<h3 id="数据库管理系统也是一种软件"><a href="#数据库管理系统也是一种软件" class="headerlink" title="数据库管理系统也是一种软件"></a>数据库管理系统也是一种软件</h3><p>我们刚才了解了 SQL 语句在 Oracle 和 MySQL 中的执行流程，实际上完整的 Oracle 和 MySQL 结构图要复杂得多：</p>
<p>如果你只是简单地把 MySQL 和 Oracle 看成数据库管理系统软件，从外部看难免会觉得“晦涩难懂”，毕竟组织结构太多了。我们在学习的时候，还需要具备抽象的能力，抓取最核心的部分：SQL 的执行原理。因为不同的 DBMS 的 SQL 的执行原理是相通的，只是在不同的软件中，各有各的实现路径。</p>
<p>既然一条 SQL 语句会经历不同的模块，那我们就来看下，在不同的模块中，SQL 执行所使用的资源（时间）是怎样的。下面我来教你如何在 MySQL 中对一条 SQL 语句的执行时间进行分析。</p>
<p>首先我们需要看下 profiling 是否开启，开启它可以让 MySQL 收集在 SQL 执行时所使用的资源情况，命令如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@profiling;</span><br></pre></td></tr></table></figure>

<p>profiling=0 代表关闭，我们需要把 profiling 打开，即设置为 1：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set profiling=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>然后我们执行一个 SQL 查询（你可以执行任何一个 SQL 查询）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * <span class="keyword">from</span> wucai.heros;</span><br></pre></td></tr></table></figure>

<p>查看当前会话所产生的所有 profiles：<br>你会发现我们刚才执行了两次查询，Query ID 分别为 1 和 2。如果我们想要获取上一次查询的执行时间，可以使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile;</span><br></pre></td></tr></table></figure>

<p>starting    0.000083    6.837<br>checking permissions    0.000011    0.906  权限检查<br>Opening tables    0.000088    7.249          打开表<br>init    0.00002    1.647                      初始化<br>System lock    0.000007    0.577              锁系统<br>optimizing    0.000005    0.412              优化查询<br>statistics    0.00001    0.824<br>preparing    0.000031    2.554              准备<br>Creating tmp table    0.000046    3.789      执行<br>Sorting result    0.000006    0.494<br>executing    0.000634    52.224<br>Sending data    0.000152    12.521<br>Creating sort index    0.000036    2.965<br>end    0.000004    0.329<br>query end    0.000004    0.329<br>removing tmp table    0.000007    0.577<br>query end    0.000002    0.165<br>closing tables    0.000002    0.165<br>removing tmp table    0.000008    0.659<br>closing tables    0.000003    0.247<br>freeing items    0.000034    2.801<br>cleaning up    0.000021    1.730<br>当然你也可以查询指定的 Query ID，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile <span class="keyword">for</span> query <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>查询 SQL 的执行时间结果和上面是一样的。</p>
<p>在 8.0 版本之后，MySQL 不再支持缓存的查询，原因我在上文已经说过。一旦数据表有更新，缓存都将清空，因此只有数据表是静态的时候，或者数据表很少发生变化时，使用缓存查询才有价值，否则如果数据表经常更新，反而增加了 SQL 的查询时间。</p>
<p>你可以使用 select version() 来查看 MySQL 的版本情况</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们在使用 SQL 的时候，往往只见树木，不见森林，不会注意到它在各种数据库软件中是如何执行的，今天我们从全貌的角度来理解这个问题。你能看到不同的 RDBMS 之间有相同的地方，也有不同的地方。</p>
<p>相同的地方在于 Oracle 和 MySQL 都是通过解析器→优化器→执行器这样的流程来执行 SQL 的。</p>
<p>但 Oracle 和 MySQL 在进行 SQL 的查询上面有软件实现层面的差异。Oracle 提出了共享池的概念，通过共享池来判断是进行软解析，还是硬解析。而在 MySQL 中，8.0 以后的版本不再支持查询缓存，而是直接执行解析器→优化器→执行器的流程，这一点从 MySQL 中的 show profile 里也能看到。同时 MySQL 的一大特色就是提供了各种存储引擎以供选择，不同的存储引擎有各自的使用场景，我们可以针对每张表选择适合的存储引擎。</p>
<p>今天的内容到这里就结束了，你能说一下 Oracle 中的绑定变量是什么吗？使用它有什么优缺点吗？MySQL 的存储引擎是一大特色，其中 MyISAM 和 InnoDB 都是常用的存储引擎，这两个搜索引擎的特性和使用场景分别是什么？</p>
<p>最后留一道选择题吧，解析后的 SQL 语句在 Oracle 的哪个区域中进行缓存？</p>
<p>A. 数据缓冲区<br>B. 日志缓冲区<br>C. 共享池<br>D. 大池</p>
<p>答案是:C<br>共享池检查：共享池（Shared Pool）是一块内存池，最主要的作用是缓存 SQL 语句和该语句的执行计划。Oracle 通过检查共享池是否存在 SQL 语句的执行计划，来判断进行软解析，还是硬解析。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/23/02%E4%B8%A8DBMS%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/23/02%E4%B8%A8DBMS%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/" itemprop="url">02丨DBMS的前世今生</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-23T20:01:07+08:00">
                2020-03-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/" itemprop="url" rel="index">
                    <span itemprop="name">SQL必知必会</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/23/02%E4%B8%A8DBMS%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/03/23/02%E4%B8%A8DBMS%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天的内容，你可以从以下几个方面进行思考：</p>
<ol>
<li>主流的 DBMS 都有哪些，它们各自都有哪些特点；</li>
<li>既然 SQL 是通用的标准语言，为什么能存在这么多 DBMS；</li>
<li>从这些 DBMS 的发展史中，你有哪些感悟。</li>
</ol>
<h3 id="DB、DBS-和-DBMS-的区别是什么"><a href="#DB、DBS-和-DBMS-的区别是什么" class="headerlink" title="DB、DBS 和 DBMS 的区别是什么"></a>DB、DBS 和 DBMS 的区别是什么</h3><p>说到 DBMS，有一些概念你需要了解。</p>
<p>DBMS 的英文全称是 DataBase Management System，数据库管理系统，实际上它可以对多个数据库进行管理，所以你可以理解为 DBMS = 多个数据库（DB） + 管理程序。</p>
<p>DB 的英文是 DataBase，也就是数据库。数据库是存储数据的集合，你可以把它理解为多个数据表。</p>
<p>DBS 的英文是 DataBase System，数据库系统。它是更大的概念，包括了数据库、数据库管理系统以及数据库管理人员 DBA。</p>
<p>这里需要注意的是，虽然我们有时候把 Oracle、MySQL 等称之为数据库，但确切讲，它们应该是数据库管理系统，即 DBMS。</p>
<h3 id="排名前-20-的-DBMS-都是那些"><a href="#排名前-20-的-DBMS-都是那些" class="headerlink" title="排名前 20 的 DBMS 都是那些"></a>排名前 20 的 DBMS 都是那些</h3><p>了解了 DBMS 的概念之后，我们来看下当前主流的 DBMS 都有哪些。下面这张表是 2019 年 5 月 DB-Engines 公布的 DBMS 的排名（每年的排名会有更新，主要依据这些 DBMS 在搜索引擎上的热度）：</p>
<p>从排名中我们能看出来，关系型数据库绝对是 DBMS 的主流，其中使用最多的 DBMS 分别是 Oracle、MySQL 和 SQL Server。</p>
<p>关系型数据库（RDBMS）就是建立在关系模型基础上的数据库，SQL 就是关系型数据库的查询语言。</p>
<p>相比于 SQL，NoSQL 泛指非关系型数据库，包括了榜单上的键值型数据库、文档型数据库、搜索引擎和列存储等，除此以外还包括图形数据库。</p>
<p>键值型数据库通过 Key-Value 键值的方式来存储数据，其中 Key 和 Value 可以是简单的对象，也可以是复杂的对象。Key 作为唯一的标识符，优点是查找速度快，在这方面明显优于关系型数据库，同时缺点也很明显，它无法像关系型数据库一样自由使用条件过滤（比如 WHERE），如果你不知道去哪里找数据，就要遍历所有的键，这就会消耗大量的计算。键值型数据库典型的使用场景是作为内容缓存。Redis 是最流行的键值型数据库。</p>
<p>文档型数据库用来管理文档，在数据库中文档作为处理信息的基本单位，一个文档就相当于一条记录，MongoDB 是最流行的文档型数据库。</p>
<p>搜索引擎也是数据库检索中的重要应用，常见的全文搜索引擎有 Elasticsearch、Splunk 和 Solr。虽然关系型数据库采用了索引提升检索效率，但是针对全文索引效率却较低。搜索引擎的优势在于采用了全文搜索的技术，核心原理是“倒排索引”。</p>
<p>列式数据库是相对于行式存储的数据库，Oracle、MySQL、SQL Server 等数据库都是采用的行式存储（Row-based），而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的 I/O，适合于分布式文件系统，不足在于功能相对有限。</p>
<p>图形数据库，利用了图这种数据结构存储了实体（对象）之间的关系。最典型的例子就是社交网络中人与人的关系，数据模型主要是以节点和边（关系）来实现，特点在于能高效地解决复杂的关系问题。</p>
<h3 id="SQL-阵营与-NoSQL-阵营"><a href="#SQL-阵营与-NoSQL-阵营" class="headerlink" title="SQL 阵营与 NoSQL 阵营"></a>SQL 阵营与 NoSQL 阵营</h3><p>NoSQL 的分类很多，刚才提到的键值型、文档型、搜索引擎、列式存储和图形数据库等都属于 NoSQL 阵营。也只有用 NoSQL 一词才能将这些技术囊括进来。即便如此，在 DBMS 排名中，还是 SQL 阵营的比重更大，影响力前 5 的 DBMS 中有 4 个是关系型数据库，而排名前 20 的 DBMS 中也有 12 个是关系型数据库。所以说，掌握 SQL 是非常有必要的。</p>
<p>由于 SQL 一直称霸 DBMS，因此许多人在思考是否有一种数据库技术能远离 SQL，于是 NoSQL 诞生了，但是随着发展却发现越来越离不开 SQL。到目前为止 NoSQL 阵营中的 DBMS 都会有实现类似 SQL 的功能。下面是“NoSQL”这个名词在不同时期的诠释，从这些释义的变化中可以看出 NoSQL 功能的演变：</p>
<p>1970：NoSQL = We have no SQL</p>
<p>1980：NoSQL = Know SQL</p>
<p>2000：NoSQL = No SQL!</p>
<p>2005：NoSQL = Not only SQL</p>
<p>2013：NoSQL = No, SQL!</p>
<p>NoSQL 对 SQL 做出了很好的补充，它可以让我们在云计算时代，更好地使用数据库技术，比如快速读写，这样可以用低廉的成本，更方便进行扩展。整个专栏的学习也将围绕 SQL 展开，同时你还需要了解 SQL 阵营中不同的 DBMS 之间的使用差异。这些 DBMS 除了支持 SQL 标准以外，还会有自己的“方言”，也就是自己独有的语法。在专栏中，我也会对近些年热门的 NoSQL 进行讲解，方便你在后续使用中更快上手。</p>
<h3 id="SQL-阵营中的-DBMS"><a href="#SQL-阵营中的-DBMS" class="headerlink" title="SQL 阵营中的 DBMS"></a>SQL 阵营中的 DBMS</h3><p>如果我们把数据互通作为当今数字化社会发展的大中台能力，那么 DBMS 无疑是一个巨大的市场。在这个市场中，排名前 20 的 DBMS 有 12 个属于 SQL 阵营，其中排名前 3 名的 DBMS 均为 SQL 阵营，它们分别是 Oracle、MySQL 和 SQL Server。这三家的市场份额远超其他 DBMS 的市场份额。</p>
<p>下面，我们来简单介绍下这三个主流 DBMS 的发展。</p>
<p>1979 年，Oracle 2 诞生，它是第一个商用的 RDBMS（关系型数据库管理系统），随后被卖给了军方客户。随着 Oracle 软件的名气越来越大，公司也改叫 Oracle 公司。20 世纪 90 年代，Oracle 的创始人埃里森成为继比尔·盖茨之后第二富有的人，可以说 IBM 缔造了两个帝国，一个是软件业的霸主微软，另一个是企业软件市场的霸主 Oracle。如今 Oracle 的年收入达到了 400 亿美金，足以证明商用数据库软件的价值。从这点我们也能看出，如果选择了一个大的赛道，就要尽早商业化，占据大型企业客户完全可以创建巨大的商业价值，也足以证明一个软件企业不需要靠卖硬件也可以挣到很多钱。</p>
<p>MySQL 是 1995 年诞生的开源数据库管理系统，因为免费开源的特性，得到了开发者的喜爱，用户量迅速增长，成为开源数据库的 No.1。但在发展过程中，MySQL 先后两次被易手，先是在 2008 年被 SUN 收购，然后在 2010 年 SUN 被 Oracle 收购，于是 Oracle 同时拥有了 MySQL 的管理权，至此 Oracle 在数据库领域中成为绝对的领导者。从这里我们也能看到，虽然 MySQL 是免费的产品，但是使用人数多，就足以证明巨大的用户价值。一个有巨大用户价值的产品，即使没有直接的商业价值，但作为基础设施也会被商业巨头看上。</p>
<p>不过在 Oracle 收购 MySQL 的同时，MySQL 的创造者担心 MySQL 有闭源的风险，因此创建了 MySQL 的分支项目 MariaDB，MariaDB 在绝大部分情况下都是与 MySQL 兼容的，并且增加了许多新的特性，比如支持更多的存储引擎类型。许多企业也由原来的 MySQL 纷纷转向了 MariaDB。</p>
<p>SQL Server 是微软开发的商业数据库，诞生于 1989 年。实际上微软还推出了 Access 数据库，它是一种桌面数据库，同时具备后台存储和前台界面开发的功能，更加轻量级，适合小型的应用场景。因为后台的存储空间有限，一般只有 2G，Access 的优势在于可以在前台便捷地进行界面开发。而 SQL Server 是大型数据库，用于后台的存储和查询，不具备界面开发的功能。从这里我们也能看出，即使 SQL 语言是通用的，但是为了满足不同用户的使用场景，会存在多个 DBMS。比如 Oracle 更适合大型跨国企业的使用，因为他们对费用不敏感，但是对性能要求以及安全性有更高的要求，而 MySQL 更受到许多互联网公司，尤其是早期创业公司的青睐。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>今天我们简单梳理了 DBMS 的发展。1974 年，SEQUEL 论文发表，1979 年，第一个商用关系型数据库 Oracle 2 诞生，1995 年，MySQL 开源数据库诞生，如今，NoSQL 得到了发展，并且围绕 SQL 标准展开的 DBMS 竞赛从来没有停止过。在这段发展史中，既有 SQL 阵营，又有 NoSQL 阵营，既有商业数据库软件，又有开源产品，在不同的应用场景下，同一家公司也会有不同的 DBMS 布局。</p>
<p>如果说不同的 DBMS 代表了不同公司的利益，那么作为使用者的我们更应该注重的是这些 DBMS 的使用场景。比如 Oracle 作为市场占有率最高的商用数据库软件，适合大型的跨国企业，而针对轻量级的桌面数据库，我们采用 Access 就可以了。对于免费开源的产品来说，可以选用 MySQL 或者 MariaDB。同时在 NoSQL 阵营中，我们也需要了解键值型、文档型、搜索引擎、列式数据库和图形数据库的区别。</p>
<p>我在文章中列举了排名前 20 的 DBMS，你都使用过哪些呢？可以说说你的使用体会吗？另外你有没有想过，虽然 SQL 是通用的标准语言，但为什么能存在这么多 DBMS 呢？</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/23/01%E4%B8%A8%E4%BA%86%E8%A7%A3SQL%EF%BC%9A%E4%B8%80%E9%97%A8%E5%8D%8A%E8%A1%B0%E6%9C%9F%E5%BE%88%E9%95%BF%E7%9A%84%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/23/01%E4%B8%A8%E4%BA%86%E8%A7%A3SQL%EF%BC%9A%E4%B8%80%E9%97%A8%E5%8D%8A%E8%A1%B0%E6%9C%9F%E5%BE%88%E9%95%BF%E7%9A%84%E8%AF%AD%E8%A8%80/" itemprop="url">1丨了解SQL：一门半衰期很长的语言</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-23T19:54:41+08:00">
                2020-03-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/" itemprop="url" rel="index">
                    <span itemprop="name">SQL必知必会</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/23/01%E4%B8%A8%E4%BA%86%E8%A7%A3SQL%EF%BC%9A%E4%B8%80%E9%97%A8%E5%8D%8A%E8%A1%B0%E6%9C%9F%E5%BE%88%E9%95%BF%E7%9A%84%E8%AF%AD%E8%A8%80/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/03/23/01%E4%B8%A8%E4%BA%86%E8%A7%A3SQL%EF%BC%9A%E4%B8%80%E9%97%A8%E5%8D%8A%E8%A1%B0%E6%9C%9F%E5%BE%88%E9%95%BF%E7%9A%84%E8%AF%AD%E8%A8%80/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在我们的日常工作中，使用的是类似 MySQL、Oracle 这种的数据库管理系统，实际上这些数据库管理系统都遵循 SQL 语言，这就意味着，我们在使用这些数据库的时候，都是通过 SQL 语言与它们打交道。所以对于从事编程或者互联网行业的人来说，最具有中台能力的语言便是 SQL 语言。自从 SQL 加入了 TIOBE 编程语言排行榜，就一直保持在 Top 10。</p>
<ol>
<li>SQL 语言无处不在，它对于不同职位的人来说都有价值。SQL 已经不仅仅是技术人员需要掌握的技能，产品经理、运营人员也同样需要掌握 SQL。</li>
<li>SQL 语言从诞生到现在，很少变化。这就意味着一旦你掌握了它，就可以一劳永逸，至少在你的职业生涯中，它都可以发挥作用。</li>
<li>SQL 入门并不难。</li>
</ol>
<h3 id="半衰期很长的-SQL"><a href="#半衰期很长的-SQL" class="headerlink" title="半衰期很长的 SQL"></a>半衰期很长的 SQL</h3><p>可以说在整个数字化的世界中，最重要而且最通用的元基础就是数据，而直接与数据打交道的语言就是 SQL 语言。很多人忽视了 SQL 语言的重要性，认为它不就是 SELECT 语句吗，掌握它应该是数据分析师的事。事实上在实际工作中，你不应该低估 SQL 的作用。如今互联网的很多业务处理离不开 SQL，因为它们都需要与数据打交道。</p>
<p>SQL 在各种技术和业务中无处不在，它的情况又是怎样的呢？45 年前，也就是 1974 年，IBM 研究员发布了一篇揭开数据库技术的论文《SEQUEL：一门结构化的英语查询语言》，直到今天这门结构化的查询语言并没有太大的变化，相比于其他语言，SQL 的半衰期可以说是非常长了。</p>
<p>SQL 有两个重要的标准，分别是 SQL92 和 SQL99，它们分别代表了 92 年和 99 年颁布的 SQL 标准，我们今天使用的 SQL 语言依然遵循这些标准。要知道 92 年是 Windows3.1 发布的时间，如今还有多少人记得它，但如果你从事数据分析，或者和数据相关的工作，依然会用到 SQL 语言。</p>
<p>作为技术和互联网行业的从业人员，我们总是希望能找到一个通用性强，变化相对少，上手相对容易的语言，SQL 正是为数不多的，可以满足这三个条件的语言。</p>
<h3 id="入门-SQL-并不难"><a href="#入门-SQL-并不难" class="headerlink" title="入门 SQL 并不难"></a>入门 SQL 并不难</h3><p>SQL 功能这么强大，那么学起来会很难吗？一点也不。SQL 不需要像其他语言那样，学习起来需要大量的程序语言基础，SQL 更像是一门英语，有一些简单的英语单词，当你使用它的时候，就好像在用英语与数据库进行对话。</p>
<p>我们可以把 SQL 语言按照功能划分成以下的 4 个部分：</p>
<ol>
<li>DDL，英文叫做 Data Definition Language，也就是数据定义语言，它用来定义我们的数据库对象，包括数据库、数据表和列。通过使用 DDL，我们可以创建，删除和修改数据库和表结构。</li>
<li>DML，英文叫做 Data Manipulation Language，数据操作语言，我们用它操作和数据库相关的记录，比如增加、删除、修改数据表中的记录。</li>
<li>DCL，英文叫做 Data Control Language，数据控制语言，我们用它来定义访问权限和安全级别。</li>
<li>DQL，英文叫做 Data Query Language，数据查询语言，我们用它查询想要的记录，它是 SQL 语言的重中之重。在实际的业务中，我们绝大多数情况下都是在和查询打交道，因此学会编写正确且高效的查询语句，是学习的重点。</li>
</ol>
<p>学习 SQL 就像学习英文语法一样。SQL 是为数不多的声明性语言，这种语言的特点就是，你只需要告诉计算机，你想从原始数据中获取什么样的数据结果即可。比如我想找主要角色定位是战士的英雄，以及他们的英雄名和最大生命值，就可以输入下面的语言：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT name, hp_max FROM heros WHERE role_main = <span class="string">'战士'</span></span><br></pre></td></tr></table></figure>


<pre><code>  File &quot;&lt;ipython-input-1-1d3f2e610d25&gt;&quot;, line 1
    SELECT name, hp_max FROM heros WHERE role_main = &apos;战士&apos;
              ^
SyntaxError: invalid syntax</code></pre><p>这里我定义了 heros 数据表，包括了 name、hp_max、role_main 等字段，具体的数据表我会在后面的课程中作为示例讲解，这里只是做个简单的说明。</p>
<p>你能从这段代码看出，我并没有告诉计算机该如何执行才能得到结果，这也是声明性语言最大的便捷性。我们不需要指定具体的执行步骤，比如先执行哪一步，再执行哪一步，在执行前是否要检查是否满足条件 A 等等这些传统的编程思维。</p>
<p>SQL 语言定义了我们的需求，而不同的 DBMS（数据库管理系统）则会按照指定的 SQL 帮我们提取想要的结果，这样是不是很棒！</p>
<h3 id="开启-SQL-之旅"><a href="#开启-SQL-之旅" class="headerlink" title="开启 SQL 之旅"></a>开启 SQL 之旅</h3><p>SQL 是我们与 DBMS 交流的语言，我们在创建 DBMS 之前，还需要对它进行设计，对于 RDBMS 来说采用的是 ER 图（Entity Relationship Diagram），即实体 - 关系图的方式进行设计。</p>
<p>ER 图评审通过后，我们再用 SQL 语句或者可视化管理工具（如 Navicat）创建数据表。</p>
<p>实体 - 关系图有什么用呢？它是我们用来描述现实世界的概念模型，在这个模型中有 3 个要素：实体、属性、关系。</p>
<p>实体就是我们要管理的对象，属性是标识每个实体的属性，关系则是对象之间的关系。比如我们创建了“英雄”这个实体，那么它下面的属性包括了姓名、职业、最大生命值、初始生命值、最大魔法值、初始魔法值和攻击范围等。同时，我们还有“用户”这个实体，它下面的属性包括用户 ID、登录名、密码、性别和头像等。</p>
<p>“英雄”和“用户”这两个实体之间就是多对多的关系，也就是说一个英雄可以从属多个用户，而一个用户也可以拥有多个英雄。</p>
<p>除了多对多之外，也有一对一和一对多的关系。</p>
<p>创建完数据表之后，我们就可以用 SQL 操作了。你能看到很多 SQL 语句的大小写不统一，虽然大小写不会影响 SQL 的执行，不过我还是推荐你采用统一的书写规范，因为好的代码规范是提高效率的关键。</p>
<p>关于 SQL 大小写的问题，我总结了下面两点：</p>
<ol>
<li>表名、表别名、字段名、字段别名等都小写；</li>
<li>SQL 保留字、函数名、绑定变量等都大写。</li>
</ol>
<p>比如下面这个 SQL 语句：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT name, hp_max FROM heros WHERE role_main = <span class="string">'战士'</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/10/39%20%7C%20Django%EF%BC%9A%E6%90%AD%E5%BB%BA%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/10/39%20%7C%20Django%EF%BC%9A%E6%90%AD%E5%BB%BA%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/" itemprop="url">39 | Django：搭建监控平台</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-10T20:10:07+08:00">
                2020-01-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/" itemprop="url" rel="index">
                    <span itemprop="name">python核心技术与实战</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/10/39%20%7C%20Django%EF%BC%9A%E6%90%AD%E5%BB%BA%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/01/10/39%20%7C%20Django%EF%BC%9A%E6%90%AD%E5%BB%BA%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Django-简介和安装"><a href="#Django-简介和安装" class="headerlink" title="Django 简介和安装"></a>Django 简介和安装</h3><p>Django 是用 Python 开发的一个免费开源的 Web 框架，可以用来快速搭建优雅的高性能网站。它采用的是“MVC”的框架模式，即模型 M、视图 V 和控制器 C。</p>
<p>Django 最大的特色，在于将网页和数据库中复杂的关系，转化为 Python 中对应的简单关系。它的设计目的，是使常见的 Web 开发任务变得快速而简单。Django 是开源的，不是商业项目或者科研项目，并且集中力量解决 Web 开发中遇到的一系列问题。所以，Django 每天都会在现有的基础上进步，以适应不断更迭的开发需求。这样既节省了开发时间，也提高了后期维护的效率。</p>
<p>说了这么多，接下来，我们通过上手使用进一步来了解。先来看一下，如何安装和使用 Django。你可以先按照下面代码块的内容来操作，安装 Django ：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install Django</span><br><span class="line">django-admin --version</span><br></pre></td></tr></table></figure>

<p>接着，我们来创建一个新的 Django 项目：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">django-admin startproject TradingMonitor</span><br><span class="line">cd TradingMonitor/</span><br><span class="line">python3 manage.py migrate</span><br></pre></td></tr></table></figure>

<p>这时，你能看到文件系统大概是下面这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TradingMonitor/</span><br><span class="line">├── TradingMonitor</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── settings.py</span><br><span class="line">│   ├── urls.py</span><br><span class="line">│   └── wsgi.py</span><br><span class="line">├── db.sqlite3</span><br><span class="line">└── manage.py</span><br></pre></td></tr></table></figure>
<p>我简单解释一下它的意思：</p>
<ul>
<li>TradingMonitor/TradingMonitor，表示项目最初的 Python 包；</li>
<li>TradingMonitor/init.py，表示一个空文件，声明所在目录的包为一个 Python 包；</li>
<li>TradingMonitor/settings.py，管理项目的配置信息；</li>
<li>TradingMonitor/urls.py，声明请求 URL 的映射关系；</li>
<li>TradingMonitor/wsgi.py，表示 Python 程序和 Web 服务器的通信协议；</li>
<li>manage.py，表示一个命令行工具，用来和 Django 项目进行交互；</li>
<li>Db.sqlite3，表示默认的数据库，可以在设置中替换成其他数据库。</li>
</ul>
<p>另外，你可能注意到了上述命令中的python3 manage.py migrate，这个命令表示创建或更新数据库模式。每当 model 源代码被改变后，如果我们要将其应用到数据库上，就需要执行一次这个命令。</p>
<p>接下来，我们为这个系统添加管理员账户：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 manage.py createsuperuser</span><br></pre></td></tr></table></figure>

<p>然后，我们来启动 Django 的 debugging 模式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 manage.py runserver</span><br></pre></td></tr></table></figure>

<p>最后，打开浏览器输入：<a href="http://127.0.0.1:8000。如果你能看到下面这个画面，就说明" target="_blank" rel="noopener">http://127.0.0.1:8000。如果你能看到下面这个画面，就说明</a> Django 已经部署成功了。</p>
<p>Django 的安装是不是非常简单呢？这其实也是 Python 一贯的理念，简洁，并简化入门的门槛。</p>
<p>OK，现在我们再定位到 <a href="http://127.0.0.1:8000/admin，你会看到" target="_blank" rel="noopener">http://127.0.0.1:8000/admin，你会看到</a> Django 的后台管理网页，这里我就不过多介绍了。<br>到此，Django 就已经成功安装，并且正常启动啦。</p>
<h3 id="MVC-架构"><a href="#MVC-架构" class="headerlink" title="MVC 架构"></a>MVC 架构</h3><p>刚刚我说过，MVC 架构是 Django 设计模式的精髓。接下来，我们就来具体看一下这个架构，并通过 Django 动手搭建一个服务端。</p>
<h3 id="设计模型-Model"><a href="#设计模型-Model" class="headerlink" title="设计模型 Model"></a>设计模型 Model</h3><p>在之前的日志和存储系统这节课中，我介绍过 peewee 这个库，它能避开通过繁琐的 SQL 语句来操作 MySQL，直接使用 Python 的 class 来进行转换。事实上，这也是 Django 采取的方式。</p>
<p>Django 无需数据库就可以使用，它通过对象关系映射器（object-relational mapping），仅使用 Python 代码就可以描述数据结构。</p>
<p>我们先来看下面这段 Model 代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  TradingMonitor/models.py</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Position</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    asset = models.CharField(max_length=<span class="number">10</span>)</span><br><span class="line">    timestamp = models.DateTimeField()</span><br><span class="line">    amount = models.DecimalField(max_digits=<span class="number">10</span>, decimal_places=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>models.py 文件主要用一个 Python 类来描述数据表，称为模型 。运用这个类，你可以通过简单的 Python 代码来创建、检索、更新、删除数据库中的记录，而不用写一条又一条的 SQL 语句，这也是我们之前所说的避免通过 SQL 操作数据库。</p>
<p>在这里，我们创建了一个 Position 模型，用来表示我们的交易仓位信息。其中，</p>
<ul>
<li>asset 表示当前持有资产的代码，例如 btc；</li>
<li>timestamp 表示时间戳；</li>
<li>amount 则表示时间戳时刻的持仓信息。</li>
</ul>
<h3 id="设计视图-Views"><a href="#设计视图-Views" class="headerlink" title="设计视图 Views"></a>设计视图 Views</h3><p>在模型被定义之后，我们便可以在视图中引用模型了。通常，视图会根据参数检索数据，加载一个模板，并使用检索到的数据呈现模板。</p>
<p>设计视图，则是我们用来实现业务逻辑的地方。我们来看 render_positions 这个代码，它接受 request 和 asset 两个参数，我们先不用管 request。这里的 asset 表示指定一个资产名称，例如 btc，然后这个函数返回一个渲染页面。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  TradingMonitor/views.py</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Position</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">render_positions</span><span class="params">(request, asset)</span>:</span></span><br><span class="line">    positions = Position.objects.filter(asset = asset)</span><br><span class="line">    context = &#123;<span class="string">'asset'</span>: asset, <span class="string">'positions'</span>: positions&#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'positions.html'</span>, context)</span><br></pre></td></tr></table></figure>

<p>不过，这个函数具体是怎么工作的呢？我们一行行来看。</p>
<p>positions = Position.objects.filter(asset = asset)，这行代码向数据库中执行一个查询操作，其中， filter 表示筛选，意思是从数据库中选出所有我们需要的 asset 的信息。不过，这里我只是为你举例做示范；真正做监控的时候，我们一般会更有针对性地从数据库中筛选读取信息，而不是一口气读取出所有的信息。</p>
<p>context = {‘asset’: asset, ‘positions’: positions}，这行代码没什么好说的，封装一个字典。至于这个字典的用处，下面的内容中可以体现。</p>
<p>return render(request, ‘positions.html’, context)，最后这行代码返回一个页面。这里我们采用的模板设计，这也是 Django 非常推荐的开发方式，也就是让模板和数据分离，这样，数据只需要向其中填充即可。</p>
<p>最后的模板文件是 position.html，你应该注意到了， context 作为变量传给了模板，下面我们就来看一下设计模板的内容。</p>
<h3 id="设计模板-Templates"><a href="#设计模板-Templates" class="headerlink" title="设计模板 Templates"></a>设计模板 Templates</h3><p>模板文件，其实就是 HTML 文件和部分代码的综合。你可以想象成，这个 HTML 在最终送给用户之前，需要被我们预先处理一下，而预先处理的方式就是找到对应的地方进行替换。</p>
<p>我们来看下面这段示例代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  TradingMonitor/templates/positions.html</span></span><br><span class="line"> </span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en-US"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Positions for &#123;&#123;asset&#125;&#125;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"> </span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Positions for &#123;&#123;asset&#125;&#125;&lt;/h1&gt;</span><br><span class="line"> </span><br><span class="line">&lt;table&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">    &lt;th&gt;Time&lt;/th&gt;</span><br><span class="line">    &lt;th&gt;Amount&lt;/th&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&#123;% <span class="keyword">for</span> position <span class="keyword">in</span> positions %&#125;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">    &lt;th&gt;&#123;&#123;position.timestamp&#125;&#125;&lt;/th&gt;</span><br><span class="line">    &lt;th&gt;&#123;&#123;position.amount&#125;&#125;&lt;/th&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p>我重点说一下几个地方。首先是<title>Positions for </title>，这里双大括号括住 asset 这个变量，这个变量对应的正是前面 context 字典中的 asset key。Django 的渲染引擎会将 asset ，替换成 context 中 asset 对应的内容，此处是替换成了 btc。</p>
<p>再来看，自然就表示结束了。这样，我们就将数据封装到了一个列表之中。</p>
<h3 id="设计链接-Urls"><a href="#设计链接-Urls" class="headerlink" title="设计链接 Urls"></a>设计链接 Urls</h3><p>最后，我们需要为我们的操作提供 URL 接口，具体操作我放在了下面的代码中，内容比较简单，我就不详细展开讲解了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  TradingMonitor/urls.py</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"> </span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">'positions/&lt;str:asset&gt;'</span>, views.render_positions),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>到这里，我们就可以通过 <a href="http://127.0.0.1:8000/positions/btc" target="_blank" rel="noopener">http://127.0.0.1:8000/positions/btc</a> 来访问啦！</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>当然，除了主要流程外，我还需要强调几个很简单但非常关键的细节，不然，我们这些改变就不能被真正地应用。</p>
<p>第一步，在 TradingMonitor/TradingMonitor 下，新建一个文件夹 migrations；并在这个文件夹中，新建一个空文件 <strong>init</strong>.py。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir TradingMonitor/migrations</span><br><span class="line">touch TradingMonitor/migrations/__init__.py</span><br></pre></td></tr></table></figure>

<p>此时，你的目录结构应该长成下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TradingMonitor/</span><br><span class="line">├── TradingMonitor</span><br><span class="line">│   ├── migrations</span><br><span class="line">│       └── __init__.py</span><br><span class="line">│   ├── templates</span><br><span class="line">│       └── positions.html</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── settings.py</span><br><span class="line">│   ├── urls.py</span><br><span class="line">│   ├── models.py</span><br><span class="line">│   ├── views.py</span><br><span class="line">│   └── wsgi.py</span><br><span class="line">├── db.sqlite3</span><br><span class="line">└── manage.py</span><br></pre></td></tr></table></figure>
<p>第二步，修改 TradingMonitor/settings.py：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">'django.contrib.admin'</span>,</span><br><span class="line">    <span class="string">'django.contrib.auth'</span>,</span><br><span class="line">    <span class="string">'django.contrib.contenttypes'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages'</span>,</span><br><span class="line">    <span class="string">'django.contrib.staticfiles'</span>,</span><br><span class="line">    <span class="string">'TradingMonitor'</span>,  <span class="comment"># 这里把我们的 app 加上</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'BACKEND'</span>: <span class="string">'django.template.backends.django.DjangoTemplates'</span>,</span><br><span class="line">        <span class="string">'DIRS'</span>: [os.path.join(BASE_DIR, <span class="string">'TradingMonitor/templates'</span>)],  <span class="comment"># 这里把 templates 的目录加上</span></span><br><span class="line">        <span class="string">'APP_DIRS'</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">'OPTIONS'</span>: &#123;</span><br><span class="line">            <span class="string">'context_processors'</span>: [</span><br><span class="line">                <span class="string">'django.template.context_processors.debug'</span>,</span><br><span class="line">                <span class="string">'django.template.context_processors.request'</span>,</span><br><span class="line">                <span class="string">'django.contrib.auth.context_processors.auth'</span>,</span><br><span class="line">                <span class="string">'django.contrib.messages.context_processors.messages'</span>,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>第三步，运行 python manage.py makemigrations：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations</span><br></pre></td></tr></table></figure>

<p>第四步，运行 python manage.py migrate：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>

<p>这几步的具体操作，我都用代码和注释表示了出来，你完全可以同步进行操作。操作完成后，现在，我们的数据结构就已经被成功同步到数据库中了。</p>
<p>最后，输入 python manage.py runserver，然后打开浏览器输入<a href="http://127.0.0.1:8000/positions/btc，你就能看到效果啦。" target="_blank" rel="noopener">http://127.0.0.1:8000/positions/btc，你就能看到效果啦。</a></p>
<p>现在，我们再回过头来看一下 MVC 模式，通过我画的这张图，你可以看到，M、V、C 这三者，以一种插件似的、松耦合的方式连接在一起：</p>
<p>当然，我带你写的只是一个简单的 Django 应用程序，对于真正的量化平台监控系统而言，这还只是一个简单的开始。</p>
<p>除此之外，对于监控系统来说，其实还有着非常多的开源插件可以使用。有一些界面非常酷炫，有一些可以做到很高的稳定性和易用性，它们很多都可以结合 Django 做出很好的效果来。比较典型的有：</p>
<ul>
<li>Graphite 是一款存储时间序列数据，并通过 Django Web 应用程序在图形中显示的插件；</li>
<li>Vimeo 则是一个基于 Graphite 的仪表板，具有附加功能和平滑的设计；</li>
<li>Scout 监控 Django 和 Flask 应用程序的性能，提供自动检测视图、SQL 查询、模板等。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这一节课的内容更靠近上游应用层，我们以 Django 这个 Python 后端为例，讲解了搭建一个服务端的过程。你应该发现了，使用 RESTful Framework 搭建服务器，是一个如此简单的过程，你可以去开一个自己的交易所了（笑）。相比起具体的技术，今天我所讲的 MVC 框架和 Django 的思想，更值得你去深入学习和领会。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/38%20%7C%20MySQL%EF%BC%9A%E6%97%A5%E5%BF%97%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/09/38%20%7C%20MySQL%EF%BC%9A%E6%97%A5%E5%BF%97%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/" itemprop="url">38 | MySQL：日志和数据存储系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-09T20:10:07+08:00">
                2020-01-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/" itemprop="url" rel="index">
                    <span itemprop="name">python核心技术与实战</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/09/38%20%7C%20MySQL%EF%BC%9A%E6%97%A5%E5%BF%97%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/01/09/38%20%7C%20MySQL%EF%BC%9A%E6%97%A5%E5%BF%97%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>于简单的、小规模的数据，例如 orderbook 信息，我们完全可以把数据存在 txt、csv 文件中，这样做简单高效。不过，缺点是，随着数据量上升，一个文件将会变得非常大，检索起来也不容易。这时，一个很直观的方式出现了，我们可以把每天的数据存在一个文件中，这样就暂时缓解了尴尬。</p>
<p>但是，随着数据量的上升，或者是你的算法逐渐来到高频交易领域时，简单地把数据存在文件上，已经不足以满足新的需求，更无法应对分布式量化交易系统的需求。于是，一个显而易见的想法就是，我们可以把日志存在数据库系统中。</p>
<p>这节课，我们就以 MySQL 这种传统型关系数据库为例，讲解一下数据库在日志中的运用。</p>
<p>快速理解 MySQL<br>担心一些同学没有数据库的基础，我先来简单介绍一下 MySQL 数据库。</p>
<p>MySQL 属于典型的关系型数据库（RDBMS），所谓的关系型数据库，就是指建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法，来处理数据库中的数据。基本上任何学习资料都会告诉你，它有着下面这几个特征：</p>
<p>数据是以表格的形式出现的；<br>每一行是各种记录名称；<br>每一列是记录名称所对应的数据域；<br>许多的行和列，组成一张表单；<br>若干的表单，组成数据库（database）这个整体。<br>不过，抛开这些抽象的特征不谈，你首先需要掌握的，是下面这些术语的概念。</p>
<p>数据库，是一些关联表的集合；而数据表则是数据的矩阵。在一个数据库中，数据表看起来就像是一个简单的电子表格。<br>在数据表中，每一列包含的是相同类型的数据；每一行则是一组相关的数据。<br>主键也是数据表中的一个列，只不过，这一列的每行元素都是唯一的，且一个数据表中只能包含一个主键；而外键则用于关联两个表。<br>除此之外，你还需要了解索引。索引是对数据库表中一列或多列的值进行排序的一种结构。使用索引，我们可以快速访问数据库表中的特定信息。一般来说，你可以对很多列设置索引，这样在检索指定列的时候，就大大加快了速度，当然，代价是插入数据会变得更慢。</p>
<p>至于操作 MySQL，一般用的是结构化查询语言 SQL。SQL 是一种典型的领域专用语言（domain-specific language，简称 DSL），这里我就不做过多介绍了，如果你感兴趣，可以学习极客时间平台上的“SQL 必知必会”专栏。</p>
<p>接下来，我们就来简单看一下，如何使用 Python 来操作 MySQL 数据库。</p>
<p>Python 连接数据库的方式有好多种，这里我简单介绍其中两种。我们以 Ubuntu 为例，假设你的系统中已经安装过 MySQL Server。（安装 MySQL 可以参考这篇文章 <a href="https://www.jianshu.com/p/3111290b87f4，或者你可以自行搜索解决）" target="_blank" rel="noopener">https://www.jianshu.com/p/3111290b87f4，或者你可以自行搜索解决）</a></p>
<h3 id="mysqlclient"><a href="#mysqlclient" class="headerlink" title="mysqlclient"></a>mysqlclient</h3><p>事实上， Python 连接 MySQL 最流行的一个驱动是 MySQL-python，又叫 MySQLdb，很多框架都也是基于此库进行开发。不过，遗憾的是，它只支持 Python2.x，而且安装的时候有很多前置条件。因为它是基于 C 开发的库，在 Windows 平台安装非常不友好，经常出现失败的情况。所以，现在我们基本不再推荐使用，取代者是它的衍生版本——mysqlclient。</p>
<p>mysqlclient 完全兼容 MySQLdb，同时支持 Python3.x，是 Django ORM 的依赖工具。如果你想使用原生 SQL 来操作数据库，那么我优先推荐使用这个框架。</p>
<p>它的安装方式很简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python3-dev</span><br><span class="line">pip install mysqlclient</span><br></pre></td></tr></table></figure>

<p>我们来看一个样例代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MySQLdb</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_pymysql</span><span class="params">()</span>:</span></span><br><span class="line">    conn = MySQLdb.connect(</span><br><span class="line">        host=<span class="string">'localhost'</span>,</span><br><span class="line">        port=<span class="number">3306</span>,</span><br><span class="line">        user=<span class="string">'your_username'</span>,</span><br><span class="line">        passwd=your_password’,</span><br><span class="line">        db=<span class="string">'mysql'</span></span><br><span class="line">    )</span><br><span class="line"> </span><br><span class="line">    cur = conn.cursor()</span><br><span class="line">    cur.execute(<span class="string">'''</span></span><br><span class="line"><span class="string">            CREATE TABLE price (</span></span><br><span class="line"><span class="string">                timestamp TIMESTAMP NOT NULL,</span></span><br><span class="line"><span class="string">                BTCUSD FLOAT(8,2),</span></span><br><span class="line"><span class="string">                PRIMARY KEY (timestamp)</span></span><br><span class="line"><span class="string">            );</span></span><br><span class="line"><span class="string">        '''</span>)</span><br><span class="line">    cur.execute(<span class="string">'''</span></span><br><span class="line"><span class="string">            INSERT INTO price VALUES(</span></span><br><span class="line"><span class="string">                "2019-07-14 14:12:17",</span></span><br><span class="line"><span class="string">                11234.56</span></span><br><span class="line"><span class="string">            );</span></span><br><span class="line"><span class="string">        '''</span>)</span><br><span class="line"> </span><br><span class="line">    conn.commit()</span><br><span class="line">    conn.close()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">test_pymy</span><br></pre></td></tr></table></figure>

<p>代码的思路很清晰明了，首先是通过 connect 命令连接数据库，来创建一个连接；之后，通过 conn.cursor() 函数创建一个游标。这里你可能会问，为什么要使用游标呢？</p>
<p>一个主要的原因就是，这样可以把集合操作转换成单个记录处理的方式。如果用 SQL 语言从数据库中检索数据，结果会放在内存的一块区域中，并且这个结果往往是一个含有多个记录的集合。而游标机制，则允许用户在 MySQL 内逐行地访问这些记录，这样你就可以按照自己的意愿，来显示和处理这些记录。</p>
<p>继续回到代码中，再往下走，我们创建了一个 price table，同时向里面插入一条 orderbook 数据。这里为了简化代码突出重点，我只保留了 timestamp 和 price。</p>
<p>最后，我们使用 conn.commit() 来提交更改，然后 close() 掉连接就可以了。</p>
<h3 id="peewee"><a href="#peewee" class="headerlink" title="peewee"></a>peewee</h3><p>不过，大家逐渐发现，写原生的 SQL 命令很麻烦。因为你需要根据特定的业务逻辑，来构造特定的插入和查询语句，这样可以说就完全抛弃了面向对象的思维。因此，又诞生了很多封装 wrapper 包和 ORM 框架。</p>
<p>这里所说的 ORM（Object Relational Mapping，简称 ORM） ，是 Python 对象与数据库关系表的一种映射关系，有了 ORM 后，我们就不再需要写 SQL 语句，而可以直接使用 Python 的数据结构了。</p>
<p>ORM 框架的优点，是提高了写代码的速度，同时兼容多种数据库系统，如 SQLite、MySQL、PostgreSQL 等这些数据库；而付出的代价，可能就是性能上的一些损失。</p>
<p>接下来要讲的 peewee，正是其中一种基于 Python 的 ORM 框架，它的学习成本非常低，可以说是 Python 中最流行的 ORM 框架。</p>
<p>它的安装方式也很简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install peewee</span><br></pre></td></tr></table></figure>

<p>我们来看一个样例代码：</p>
<p>import peewee<br>from peewee import *</p>
<p>db = MySQLDatabase(‘mysql’, user=’your_username’, passwd=your_password’)</p>
<p>class Price(peewee.Model):<br>    timestamp = peewee.DateTimeField(primary_key=True)<br>    BTCUSD = peewee.FloatField()</p>
<pre><code>class Meta:
    database = db</code></pre><p>def test_peewee():<br>    Price.create_table()<br>    price = Price(timestamp=’2019-06-07 13:17:18’, BTCUSD=’12345.67’)<br>    price.save()</p>
<p>test_p</p>
<p>如果你写过 Django，你会发现，这个写法和 Django 简直一摸一样。我们通过一个 Python class ，映射了 MySQL 中的一张数据表；只要对其中每一列数据格式进行定义，便可按照 Python 的方式进行操作。</p>
<p>显而易见，peewee 的最大优点，就是让 SQL 语言瞬间变成强类型语言，这样不仅极大地增强了可读性，也能有效减少出 bug 的概率。</p>
<p>不过，事实上，作为一名数据科学家，或者作为一名量化从业者（quant ），你要处理的数据远比这些复杂很多。互联网工业界有大量的脏数据，金融行业的信噪比更是非常之低，数据处理只能算是基本功。</p>
<p>如果你对数据分析有兴趣和志向，在学生时期就应该先打牢数学和统计的基础，之后在实习和工作中快速掌握数据处理的方法。当然，如果你已经错过学生时期的话，现在开始也是个不错的选择，毕竟，逐渐形成自己的核心竞争力，才是我们每个人的正道。</p>
<h3 id="量化数据分析系统"><a href="#量化数据分析系统" class="headerlink" title="量化数据分析系统"></a>量化数据分析系统</h3><p>数据库有了量化数据存入后，接下来，我们便可以开始进行一些量化分析了。这一块儿也是一个很大的学术领域，叫做时间序列分析，不过就今天这节课的主题来说，我们仅做抛砖引玉，列举一个非常简单的例子，即求过去一个小时 BTC/USD 的最高价和最低价。</p>
<p>我们来看下面这段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MySQLdb</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_pymysql</span><span class="params">()</span>:</span></span><br><span class="line">    conn = MySQLdb.connect(</span><br><span class="line">        host=<span class="string">'localhost'</span>,</span><br><span class="line">        port=<span class="number">3306</span>,</span><br><span class="line">        user=<span class="string">'your_username'</span>,</span><br><span class="line">        passwd=<span class="string">'your_password'</span>,</span><br><span class="line">        db=<span class="string">'mysql'</span></span><br><span class="line">    )</span><br><span class="line"> </span><br><span class="line">    cur = conn.cursor()</span><br><span class="line">    cur.execute(<span class="string">'''</span></span><br><span class="line"><span class="string">            SELECT</span></span><br><span class="line"><span class="string">              BTCUSD</span></span><br><span class="line"><span class="string">            FROM</span></span><br><span class="line"><span class="string">              price</span></span><br><span class="line"><span class="string">            WHERE</span></span><br><span class="line"><span class="string">              timestamp &gt; now() - interval 60 minute</span></span><br><span class="line"><span class="string">    '''</span>)</span><br><span class="line"> </span><br><span class="line">    BTCUSD = np.array(cur.fetchall())</span><br><span class="line">    print(BTCUSD.max(), BTCUSD.min())</span><br><span class="line"> </span><br><span class="line">    conn.close()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">test_pym</span><br></pre></td></tr></table></figure>

<p>代码看起来很简单吧！显然，通过 SQL 语句，我们可以抓取到过去一小时的时间序列片段，拿到我们想要的 BTC/USD 价格向量，然后通过 numpy 处理一下即可。不过这里需要注意一点，我们并不需要调用 conn.commit()，因为我们的操作是只读的，对数据库没有任何影响。</p>
<h3 id="分布式日志系统"><a href="#分布式日志系统" class="headerlink" title="分布式日志系统"></a>分布式日志系统</h3><p>明白了上面的内容后，我们现在来看一下分布式日志系统。</p>
<p>对量化交易而言，我们需要的模块主要有数据系统、策略系统、交易执行系统、线下模型训练、线上风控系统以及实时监控系统。它们之间的对应关系，我画了一张图，你可以参考来理解。</p>
<p>这里的每个子系统都是独立运行的，并且还有许多模块需要迭代更新，所以我们简单保存本地日志显然不是一个明智之举。于是，我们可以专门开一台服务器来运行 MySQL server，并且开放指定端口和其他系统进行交互。</p>
<p>另外，图中的收集系统，其实类似于上一节我们所讲的消息队列体系，在各个上游系统中运行代理工具，负责将各个模块的 log 收集起来，然后发送到收集系统中。收集系统整理过后，再将信息存到日志系统。当然，除了简单的消息队列，我们还能用很多工具，比如阿里云的 Logtail、 Apache 的 Flume Agent 等等。</p>
<p>而到了后期，对于日志系统来说，越来越需要注意的就是存储效率和分析效率。随着使用的增加，数据会越来越多，因此我们可以考虑对一些数据进行压缩和保存。而越是久远的数据，越是粗粒度的数据，被调用的概率也就越低，所以它们也就首当其冲，成了我们压缩、保存的目标。</p>
<h3 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h3><p>最后，我再来补充讲一讲日志的分析。前面提到过，分析一般分为两种，离线分析和在线分析。</p>
<p>在离线分析中，比较常见的是生成报告。</p>
<p>比如，总结某天某月或某季度内的，收益亏损情况（PnL）、最大回撤、夏普比率等数据。这种基于时间窗口的统计，在关系型数据库中也能得到很方便的支持。</p>
<p>而另一类常见的离线使用方式，则是回测系统。在一个新策略研发的周期中，我们需要对历史数据进行回测，这样就可以得到历史数据中交易的收益率等数据。回测系统对于评估一个新的策略非常重要，然而，回测往往需要大量的资源，所以选取好数据库、数据存储方式，优化数据连接和计算，就显得至关重要。</p>
<p>在线分析，则更多应用于风控和警报系统。这种方式，对数据的实时性要求更高一些，于是，一种方法就是，从消息队列中直接拿最快的数据进行操作。当然，这个前提是时间窗口较小，这样你就不需要风控系统来维护大量的本地数据。</p>
<p>至于实时警报，最关键的依然是数据。</p>
<ul>
<li>比如，数据系统异常停止，被监视的表没有更新；</li>
<li>或者，交易系统的连接出了故障，委托订单的某些状态超过了一定的阈值；</li>
<li>再或者，仓位信息出现了较大的、预计之外的变动。</li>
</ul>
<p>这些情况都需要进行报警，也就是硅谷大公司所说的“oncall”。一旦发生意外，负责人会迅速收到电话、短信和邮件，然后通过监控平台来确认，是真的出了事故还是监控误报。</p>
<p>当然，现在已经有了不少开源的工具可以在云端使用，其中 AWS 属于全球领先的云计算平台。如果你的服务器架设在美国，那就可以考虑选择它家的各种各样的云服务。这样做的好处是，对于小型量化交易团队而言，避免自己搭建复杂的日志系统，而是把主要精力放在策略的开发迭代之上，提高了不少效率。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这一节课，我从工程的角度，为你介绍了量化系统中的存储系统。我们从基础的 MySQL 的使用方法讲起，再讲到后面的量化系统框架。数据库和数据在绝大部分互联网行业都是核心，对量化从业者来说也是重要的生产资料。而搭建一套负载合理、数据可靠的数据系统，也需要一个量化团队长期打磨，并根据需求进行迭代。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/07/37%20%7C%20Kafka%20&%20ZMQ%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BA%A4%E6%98%93%E6%B5%81%E6%B0%B4%E7%BA%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/07/37%20%7C%20Kafka%20&%20ZMQ%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BA%A4%E6%98%93%E6%B5%81%E6%B0%B4%E7%BA%BF/" itemprop="url">37 | Kafka & ZMQ自动化交易流水线</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-07T20:10:07+08:00">
                2020-01-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/" itemprop="url" rel="index">
                    <span itemprop="name">python核心技术与实战</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/07/37%20%7C%20Kafka%20&%20ZMQ%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BA%A4%E6%98%93%E6%B5%81%E6%B0%B4%E7%BA%BF/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/01/07/37%20%7C%20Kafka%20&%20ZMQ%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BA%A4%E6%98%93%E6%B5%81%E6%B0%B4%E7%BA%BF/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>我们先来介绍一下中间件这个概念。中间件，是将技术底层工具和应用层进行连接的组件。它要实现的效果则是，让我们这些需要利用服务的工程师，不必去关心底层的具体实现。我们只需要拿着中间件的接口来用就好了。</p>
<p>这个概念听起来并不难理解，我们再举个例子让你彻底明白。比如拿数据库来说，底层数据库有很多很多种，从关系型数据库 MySQL 到非关系型数据库 NoSQL，从分布式数据库 Spanner 到内存数据库 Redis，不同的数据库有不同的使用场景，也有着不同的优缺点，更有着不同的调用方式。那么中间件起什么作用呢？</p>
<p>中间件，等于在这些不同的数据库上加了一层逻辑，这一层逻辑专门用来和数据库打交道，而对外只需要暴露同一个接口即可。这样一来，上层的程序员调用中间件接口时，只需要让中间件指定好数据库即可，其他参数完全一致，极大地方便了上层的开发；同时，下层技术栈在更新换代的时候，也可以做到和上层完全分离，不影响程序员的使用。</p>
<p>它们之间的逻辑关系，你可以参照下面我画的这张图。我习惯性把中间件的作用调侃为：没有什么事情是加一层解决不了的；如果有，那就加两层。</p>
<p>当然，这只是其中一个例子，也只是中间件的一种形式。事实上，比如在阿里，中间件主要有分布式关系型数据库 DRDS、消息队列和分布式服务这么三种形式。而我们今天，主要会用到消息队列，因为它非常符合量化交易系统的应用场景，即事件驱动模型。</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>那么，什么是消息队列呢？一如其名，消息，即互联网信息传递的个体；而队列，学过算法和数据结构的你，应该很清楚这个 FIFO（先进先出）的数据结构吧。（如果算法基础不太牢，建议你可以学习极客时间平台上王争老师的“数据结构与算法之美”专栏，第 09 讲即为队列知识）</p>
<p>简而言之，消息队列就是一个临时存放消息的容器，有人向消息队列中推送消息；有人则监听消息队列，发现新消息就会取走。根据我们刚刚对中间件的解释，清晰可见，消息队列也是一种中间件。</p>
<p>目前，市面上使用较多的消息队列有 RabbitMQ、Kafka、RocketMQ、ZMQ 等。不过今天，我只介绍最常用的 ZMQ 和 Kafka。</p>
<p>我们先来想想，消息队列作为中间件有什么特点呢？</p>
<p>首先是严格的时序性。刚刚说了，队列是一种先进先出的数据结构，你丢给它 1, 2, 3，然后另一个人从里面取数据，那么取出来的一定也是 1, 2, 3，严格保证了先进去的数据先出去，后进去的数据后出去。显然，这也是消息机制中必须要保证的一点，不然颠三倒四的结果一定不是我们想要的。</p>
<p>说到队列的特点，简单提一句，与“先进先出“相对的是栈这种数据结构，它是先进后出的，你丢给它 1, 2, 3，再从里面取出来的时候，拿到的就是3, 2, 1了，这一点一定要区分清楚。</p>
<p>其次，是分布式网络系统的老生常谈问题。如何保证消息不丢失？如何保证消息不重复？这一切，消息队列在设计的时候都已经考虑好了，你只需要拿来用就可以，不必过多深究。</p>
<p>不过，很重要的一点，消息队列是如何降低系统复杂度，起到中间件的解耦作用呢？<br>消息队列的模式是发布和订阅，一个或多个消息发布者可以发布消息，一个或多个消息接受者可以订阅消息。 从图中你可以看到，消息发布者和消息接受者之间没有直接耦合，其中，</p>
<ul>
<li>消息发布者将消息发送到分布式消息队列后，就结束了对消息的处理；</li>
<li>消息接受者从分布式消息队列获取该消息后，即可进行后续处理，并不需要探寻这个消息从何而来。<br>至于新增业务的问题，只要你对这类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，所以也就实现了业务的可扩展性设计。</li>
</ul>
<p>讲了这么多概念层的东西，想必你迫不及待地想看具体代码了吧。接下来，我们来看一下 ZMQ 的实现。</p>
<h3 id="ZMQ"><a href="#ZMQ" class="headerlink" title="ZMQ"></a>ZMQ</h3><p>先来看 ZMQ，这是一个非常轻量级的消息队列实现。<br>ZMQ 是一个简单好用的传输层，它有三种使用模式：</p>
<ul>
<li>Request - Reply 模式；</li>
<li>Publish - Subscribe 模式；</li>
<li>Parallel Pipeline 模式。</li>
</ul>
<p>第一种模式很简单，client 发消息给 server，server 处理后返回给 client，完成一次交互。这个场景你一定很熟悉吧，没错，和 HTTP 模式非常像，所以这里我就不重点介绍了。至于第三种模式，与今天内容无关，这里我也不做深入讲解。</p>
<p>我们需要详细来看的是第二种，即“PubSub”模式。下面是它的具体实现，代码很清晰，你应该很容易理解：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 订阅者 1</span></span><br><span class="line"><span class="keyword">import</span> zmq</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    context = zmq.Context()</span><br><span class="line">    socket = context.socket(zmq.SUB)</span><br><span class="line">    socket.connect(<span class="string">'tcp://127.0.0.1:6666'</span>)</span><br><span class="line">    socket.setsockopt_string(zmq.SUBSCRIBE, <span class="string">''</span>)</span><br><span class="line"> </span><br><span class="line">    print(<span class="string">'client 1'</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        msg = socket.recv()</span><br><span class="line">        print(<span class="string">"msg: %s"</span> % msg)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure>

<pre><code>client 1</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 订阅者 2</span></span><br><span class="line"><span class="keyword">import</span> zmq</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    context = zmq.Context()</span><br><span class="line">    socket = context.socket(zmq.SUB)</span><br><span class="line">    socket.connect(<span class="string">'tcp://127.0.0.1:6666'</span>)</span><br><span class="line">    socket.setsockopt_string(zmq.SUBSCRIBE, <span class="string">''</span>)</span><br><span class="line"> </span><br><span class="line">    print(<span class="string">'client 2'</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        msg = socket.recv()</span><br><span class="line">        print(<span class="string">"msg: %s"</span> % msg)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发布者</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> zmq</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    context = zmq.Context()</span><br><span class="line">    socket = context.socket(zmq.PUB)</span><br><span class="line">    socket.bind(<span class="string">'tcp://*:6666'</span>)</span><br><span class="line"> </span><br><span class="line">    cnt = <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        socket.send_string(<span class="string">'server cnt &#123;&#125;'</span>.format(cnt))</span><br><span class="line">        print(<span class="string">'send &#123;&#125;'</span>.format(cnt))</span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure>

<p>这里要注意的一点是，如果你想要运行代码，请先运行两个订阅者，然后再打开发布者。</p>
<p>接下来，我来简单讲解一下。</p>
<p>对于订阅者，我们要做的是创建一个 zmq Context，连接 socket 到指定端口。其中，setsockopt_string() 函数用来过滤特定的消息，而下面这行代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.setsockopt_string(zmq.SUBSCRIBE, <span class="string">''</span>)</span><br></pre></td></tr></table></figure>

<p>则表示不过滤任何消息。最后，我们调用 socket.recv() 来接受消息就行了，这条语句会阻塞在这里，直到有新消息来临。</p>
<p>对于发布者，我们同样要创建一个 zmq Context，绑定到指定端口，不过请注意，这里用的是 bind 而不是 connect。因为在任何情况下，同一个地址端口 bind 只能有一个，但却可以有很多个 connect 链接到这个地方。初始化完成后，再调用 socket.send_string ，即可将我们想要发送的内容发送给 ZMQ。</p>
<p>当然，这里还有几个需要注意的地方。首先，有了 send_string，我们其实已经可以通过 JSON 序列化，来传递几乎我们想要的所有数据结构，这里的数据流结构就已经很清楚了。</p>
<p>另外，把发布者的 time.sleep(1) 放在 while 循环的最后，严格来说应该是不影响结果的。这里你可以尝试做个实验，看看会发生什么。</p>
<p>你还可以思考下另一个问题，如果这里是多个发布者，那么 ZMQ 应该怎么做呢？</p>
<h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><p>接着我们再来看一下 Kafka。</p>
<p>通过代码实现你也可以发现，ZMQ 的优点主要在轻量、开源和方便易用上，但在工业级别的应用中，大部分人还是会转向 Kafka 这样的有充足支持的轮子上。</p>
<p>相比而言，Kafka 提供了点对点网络和发布订阅模型的支持，这也是用途最广泛的两种消息队列模型。而且和 ZMQ 一样，Kafka 也是完全开源的，因此你也能得到开源社区的充分支持。</p>
<p>Kafka 的代码实现，和 ZMQ 大同小异，这里我就不专门讲解了。关于 Kafka 的更多内容，极客时间平台也有对 Kafka 的专门详细的介绍，对此有兴趣的同学，可以在极客时间中搜索“Kafka 核心技术与实战”，这个专栏里，胡夕老师用详实的篇幅，讲解了 Kafka 的实战和内核，你可以加以学习和使用。</p>
<p>基于消息队列的 Orderbook 数据流<br>最后回到我们的量化交易系统上。</p>
<p>量化交易系统中，获取 orderbook 一般有两种用途：策略端获取实时数据，用来做决策；备份在文件或者数据库中，方便让策略和回测系统将来使用。</p>
<p>如果我们直接单机监听交易所的消息，风险将会变得很大，这在分布式系统中叫做 Single Point Failure。一旦这台机器出了故障，或者网络连接突然中断，我们的交易系统将立刻暴露于风险中。</p>
<p>于是，一个很自然的想法就是，我们可以在不同地区放置不同的机器，使用不同的网络同时连接到交易所，然后将这些机器收集到的信息汇总、去重，最后生成我们需要的准确数据。相应的拓扑图如下：</p>
<p>当然，这种做法也有很明显的缺点：因为要同时等待多个数据服务器的数据，再加上消息队列的潜在处理延迟和网络延迟，对策略服务器而言，可能要增加几十到数百毫秒的延迟。如果是一些高频或者滑点要求比较高的策略，这种做法需要谨慎考虑。</p>
<p>但是，对于低频策略、波段策略，这种延迟换来的整个系统的稳定性和架构的解耦性，还是非常值得的。不过，你仍然需要注意，这种情况下，消息队列服务器有可能成为瓶颈，也就是刚刚所说的 Single Point Failure，一旦此处断开，依然会将系统置于风险之中。</p>
<p>事实上，我们可以使用一些很成熟的系统，例如阿里的消息队列，AWS 的 Simple Queue Service 等等，使用这些非常成熟的消息队列系统，风险也将会最小化。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这节课，我们分析了现代化软件工程领域中的中间件系统，以及其中的主要应用——消息队列。我们讲解了最基础的消息队列的模式，包括点对点模型、发布者订阅者模型，和一些其他消息队列自己支持的模型。</p>
<p>在真实的项目设计中，我们要根据自己的产品需求，来选择使用不同的模型；同时也要在编程实践中，加深对不同技能点的了解，对系统复杂性进行解耦，这才是设计出高质量系统的必经之路。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/06/36%20%7C%20Pandas%20&%20Numpy%E7%AD%96%E7%95%A5%E4%B8%8E%E5%9B%9E%E6%B5%8B%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/06/36%20%7C%20Pandas%20&%20Numpy%E7%AD%96%E7%95%A5%E4%B8%8E%E5%9B%9E%E6%B5%8B%E7%B3%BB%E7%BB%9F/" itemprop="url">36 | Pandas & Numpy策略与回测系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-06T20:10:07+08:00">
                2020-01-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/" itemprop="url" rel="index">
                    <span itemprop="name">python核心技术与实战</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/06/36%20%7C%20Pandas%20&%20Numpy%E7%AD%96%E7%95%A5%E4%B8%8E%E5%9B%9E%E6%B5%8B%E7%B3%BB%E7%BB%9F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/01/06/36%20%7C%20Pandas%20&%20Numpy%E7%AD%96%E7%95%A5%E4%B8%8E%E5%9B%9E%E6%B5%8B%E7%B3%BB%E7%BB%9F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上节课，我们介绍了交易所的数据抓取，特别是 orderbook 和 tick 数据的抓取。今天这节课，我们考虑的是，怎么在这些历史数据上测试一个交易策略。</p>
<p>首先我们要明确，对于很多策略来说，我们上节课抓取的密集的 orderbook 和 tick 数据，并不能简单地直接使用。因为数据量太密集，包含了太多细节；而且长时间连接时，网络随机出现的不稳定，会导致丢失部分 tick 数据。因此，我们还需要进行合适的清洗、聚合等操作。</p>
<p>此外，为了进行回测，我们需要一个交易策略，还需要一个测试框架。目前已存在很多成熟的回测框架，但是为了 Python 学习，我决定带你搭建一个简单的回测框架，并且从中简单一窥 Pandas 的优势。</p>
<h3 id="OHLCV-数据"><a href="#OHLCV-数据" class="headerlink" title="OHLCV 数据"></a>OHLCV 数据</h3><p>了解过一些股票交易的同学，可能知道 K 线这种东西。K 线又称“蜡烛线”，是一种反映价格走势的图线。它的特色在于，一个线段内记录了多项讯息，相当易读易懂且实用有效，因此被广泛用于股票、期货、贵金属、数字货币等行情的技术分析。下面便是一个 K 线示意图。</p>
<p>其中，每一个小蜡烛，都代表着当天的开盘价（Open）、最高价（High）、最低价（Low）和收盘价（Close），也就是我画的第二张图表示的这样。</p>
<p>类似的，除了日 K 线之外，还有周 K 线、小时 K 线、分钟 K 线等等。那么这个 K 线是怎么计算来的呢？</p>
<p>我们以小时 K 线图为例，还记得我们当时抓取的 tick 数据吗？也就是每一笔交易的价格和数量。那么，如果从上午 10:00 开始，我们开始积累 tick 的交易数据，以 10:00 开始的第一个交易作为 Open 数据，11:00 前的最后一笔交易作为 Close 值，并把这一个小时最低和最高的成交价格分别作为 High 和 Low 的值，我们就可以绘制出这一个小时对应的“小蜡烛”形状了。</p>
<p>如果再加上这一个小时总的成交量（Volumn），就得到了 OHLCV 数据。</p>
<p>所以，如果我们一直抓取着 tick 底层原始数据，我们就能在上层聚合出 1 分钟 K 线、小时 K 线以及日、周 k 线等等。如果你对这一部分操作有兴趣，可以把此作为今天的课后作业来实践。</p>
<p>接下来，我们将使用 Gemini 从 2015 年到 2019 年 7 月这个时间内，BTC 对 USD 每个小时的 OHLCV 数据，作为策略和回测的输入。你可以在这里下载数据。</p>
<p>数据下载完成后，我们可以利用 Pandas 读取，比如下面这段代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">assert_msg</span><span class="params">(condition, msg)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> condition:</span><br><span class="line">        <span class="keyword">raise</span> Exception(msg)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_file</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="comment"># 获得文件绝对路径</span></span><br><span class="line">    filepath = path.join(path.dirname(__file__), filename)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 判定文件是否存在</span></span><br><span class="line">    assert_msg(path.exists(filepath), <span class="string">" 文件不存在 "</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 读取 CSV 文件并返回</span></span><br><span class="line">    <span class="keyword">return</span> pd.read_csv(filepath,</span><br><span class="line">                       index_col=<span class="number">0</span>, </span><br><span class="line">                       parse_dates=<span class="literal">True</span>,</span><br><span class="line">                       infer_datetime_format=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line">BTCUSD = read_file(<span class="string">'BTCUSD_GEMINI.csv'</span>)</span><br><span class="line">assert_msg(BTCUSD.__len__() &gt; <span class="number">0</span>, <span class="string">'读取失败'</span>)</span><br><span class="line">print(BTCUSD.head())</span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

NameError                                 Traceback (most recent call last)

&lt;ipython-input-1-de519e90fcc7&gt; in &lt;module&gt;
     16                        infer_datetime_format=True)
     17 
---&gt; 18 BTCUSD = read_file(&apos;BTCUSD_GEMINI.csv&apos;)
     19 assert_msg(BTCUSD.__len__() &gt; 0, &apos;读取失败&apos;)
     20 print(BTCUSD.head())


&lt;ipython-input-1-de519e90fcc7&gt; in read_file(filename)
      5 def read_file(filename):
      6     # 获得文件绝对路径
----&gt; 7     filepath = path.join(path.dirname(__file__), filename)
      8 
      9     # 判定文件是否存在


NameError: name &apos;path&apos; is not defined</code></pre><p>这段代码提供了两个工具函数。</p>
<ul>
<li>一个是 read_file，它的作用是，用 pandas 读取 csv 文件。</li>
<li>另一个是 assert_msg，它的作用类似于 assert，如果传入的条件（contidtion）为否，就会抛出异常。不过，你需要提供一个参数，用于指定要抛出的异常信息。</li>
</ul>
<h3 id="回测框架"><a href="#回测框架" class="headerlink" title="回测框架"></a>回测框架</h3><p>说完了数据，我们接着来看回测数据。常见的回测框架有两类。一类是向量化回测框架，它通常基于 Pandas+Numpy 来自己搭建计算核心；后端则是用 MySQL 或者 MongoDB 作为源。这种框架通过 Pandas+Numpy 对 OHLC 数组进行向量运算，可以在较长的历史数据上进行回测。不过，因为这类框架一般只用 OHLC，所以模拟会比较粗糙。</p>
<p>另一类则是事件驱动型回测框架。这类框架，本质上是针对每一个 tick 的变动或者 orderbook 的变动生成事件；然后，再把一个个事件交给策略进行执行。因此，虽然它的拓展性很强，可以允许更加灵活的策略，但回测速度是很慢的。</p>
<p>我们想要学习量化交易，使用大型成熟的回测框架，自然是第一选择。</p>
<ul>
<li>比如 Zipline，就是一个热门的事件驱动型回测框架，背后有大型社区和文档的支持。</li>
<li>PyAlgoTrade 也是事件驱动的回测框架，文档相对完整，整合了知名的技术分析（Techique Analysis）库 TA-Lib。在速度和灵活方面，它比 Zipline 强。不过，它的一大硬伤是不支持 Pandas 的模块和对象。</li>
</ul>
<p>显然，对于我们 Python 学习者来说，第一类也就是向量型回测框架，才是最适合我们练手的项目了。那么，我们就开始吧。</p>
<p>首先，我先为你梳理下回测流程，也就是下面五步：</p>
<ol>
<li>读取 OHLC 数据；</li>
<li>对 OHLC 进行指标运算；</li>
<li>策略根据指标向量决定买卖；</li>
<li>发给模拟的”交易所“进行交易；</li>
<li>最后，统计结果。</li>
</ol>
<p>对此，使用之前学到的面向对象思维方式，我们可以大致抽取三个类：</p>
<ul>
<li>交易所类（ ExchangeAPI）：负责维护账户的资金和仓位，以及进行模拟的买卖；</li>
<li>策略类（Strategy）：负责根据市场信息生成指标，根据指标决定买卖；</li>
<li>回测类框架（Backtest）：包含一个策略类和一个交易所类，负责迭代地对每个数据点调用策略执行。</li>
</ul>
<p>接下来，我们先从最外层的大框架开始。这样的好处在于，我们是从上到下、从外往内地思考，虽然还没有开始设计依赖项（Backtest 的依赖项是 ExchangeAPI 和 Strategy），但我们可以推测出它们应有的接口形式。推测接口的本质，其实就是推测程序的输入。</p>
<p>这也是我在一开始提到过的，对于程序这个“黑箱”，你在一开始设计的时候，就要想好输入和输出。</p>
<p>回到最外层 Backtest 类。我们需要知道，输出是最后的收益，那么显然，输入应该是初始输入的资金数量（cash）。</p>
<p>此外，为了模拟得更加真实，我们还要考虑交易所的手续费（commission）。手续费的多少取决于券商（broker）或者交易所，比如我们买卖股票的券商手续费可能是万七，那么就是 0.0007。但是在比特币交易领域，手续费通常会稍微高一点，可能是千分之二左右。当然，无论怎么多，一般也不会超过 5 %。否则我们大家交易几次就破产了，也就不会有人去交易了。</p>
<p>这里说一句题外话，不知道你有没有发现，无论数字货币的价格是涨还是跌，总有一方永远不亏，那就是交易所。因为只要有人交易，他们就有白花花的银子进账。</p>
<p>回到正题，至此，我们就确定了 Backtest 的输入和输出。</p>
<p>它的输入是：</p>
<ul>
<li>OHLC 数据；</li>
<li>初始资金；</li>
<li>手续费率；</li>
<li>交易所类；</li>
<li>策略类。</li>
</ul>
<p>输出则是：</p>
<ul>
<li>最后剩余市值。</li>
</ul>
<p>对此，你可以参考下面这段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Backtest</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Backtest 回测类，用于读取历史行情数据、执行策略、模拟交易并估计</span></span><br><span class="line"><span class="string">    收益。</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    初始化的时候调用 Backtest.run 来时回测</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    instance, or `backtesting.backtesting.Backtest.optimize` to</span></span><br><span class="line"><span class="string">    optimize it.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,</span></span></span><br><span class="line"><span class="function"><span class="params">                 data: pd.DataFrame,</span></span></span><br><span class="line"><span class="function"><span class="params">                 strategy_type: type<span class="params">(Strategy)</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 broker_type: type<span class="params">(ExchangeAPI)</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 cash: float = <span class="number">10000</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 commission: float = <span class="number">.0</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        构造回测对象。需要的参数包括：历史数据，策略对象，初始资金数量，手续费率等。</span></span><br><span class="line"><span class="string">        初始化过程包括检测输入类型，填充数据空值等。</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        参数：</span></span><br><span class="line"><span class="string">        :param data:            pd.DataFrame        pandas Dataframe 格式的历史 OHLCV 数据</span></span><br><span class="line"><span class="string">        :param broker_type:     type(ExchangeAPI)   交易所 API 类型，负责执行买卖操作以及账户状态的维护</span></span><br><span class="line"><span class="string">        :param strategy_type:   type(Strategy)      策略类型</span></span><br><span class="line"><span class="string">        :param cash:            float               初始资金数量</span></span><br><span class="line"><span class="string">        :param commission:       float               每次交易手续费率。如 2% 的手续费此处为 0.02</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"> </span><br><span class="line">        assert_msg(issubclass(strategy_type, Strategy), <span class="string">'strategy_type 不是一个 Strategy 类型'</span>)</span><br><span class="line">        assert_msg(issubclass(broker_type, ExchangeAPI), <span class="string">'strategy_type 不是一个 Strategy 类型'</span>)</span><br><span class="line">        assert_msg(isinstance(commission, Number), <span class="string">'commission 不是浮点数值类型'</span>)</span><br><span class="line"> </span><br><span class="line">        data = data.copy(<span class="literal">False</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 如果没有 Volumn 列，填充 NaN</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'Volume'</span> <span class="keyword">not</span> <span class="keyword">in</span> data:</span><br><span class="line">            data[<span class="string">'Volume'</span>] = np.nan</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 验证 OHLC 数据格式</span></span><br><span class="line">        assert_msg(len(data.columns &amp; &#123;<span class="string">'Open'</span>, <span class="string">'High'</span>, <span class="string">'Low'</span>, <span class="string">'Close'</span>, <span class="string">'Volume'</span>&#125;) == <span class="number">5</span>,</span><br><span class="line">                   (<span class="string">" 输入的`data`格式不正确，至少需要包含这些列："</span></span><br><span class="line">                    <span class="string">"'Open', 'High', 'Low', 'Close'"</span>))</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 检查缺失值</span></span><br><span class="line">        assert_msg(<span class="keyword">not</span> data[[<span class="string">'Open'</span>, <span class="string">'High'</span>, <span class="string">'Low'</span>, <span class="string">'Close'</span>]].max().isnull().any(),</span><br><span class="line">            (<span class="string">'部分 OHLC 包含缺失值，请去掉那些行或者通过差值填充. '</span>))</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 如果行情数据没有按照时间排序，重新排序一下</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data.index.is_monotonic_increasing:</span><br><span class="line">            data = data.sort_index()</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 利用数据，初始化交易所对象和策略对象。</span></span><br><span class="line">        self._data = data  <span class="comment"># type: pd.DataFrame</span></span><br><span class="line">        self._broker = broker_type(data, cash, commission)</span><br><span class="line">        self._strategy = strategy_type(self._broker, self._data)</span><br><span class="line">        self._results = <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        运行回测，迭代历史数据，执行模拟交易并返回回测结果。</span></span><br><span class="line"><span class="string">        Run the backtest. Returns `pd.Series` with results and statistics.</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        Keyword arguments are interpreted as strategy parameters.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        strategy = self._strategy</span><br><span class="line">        broker = self._broker</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 策略初始化</span></span><br><span class="line">        strategy.init()</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 设定回测开始和结束位置</span></span><br><span class="line">        start = <span class="number">100</span></span><br><span class="line">        end = len(self._data)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 回测主循环，更新市场状态，然后执行策略</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start, end):</span><br><span class="line">            <span class="comment"># 注意要先把市场状态移动到第 i 时刻，然后再执行策略。</span></span><br><span class="line">            broker.next(i)</span><br><span class="line">            strategy.next(i)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 完成策略执行之后，计算结果并返回</span></span><br><span class="line">        self._results = self._compute_result(broker)</span><br><span class="line">        <span class="keyword">return</span> self._results</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_compute_result</span><span class="params">(self, broker)</span>:</span></span><br><span class="line">        s = pd.Series()</span><br><span class="line">        s[<span class="string">'初始市值'</span>] = broker.initial_cash</span><br><span class="line">        s[<span class="string">'结束市值'</span>] = broker.market_value</span><br><span class="line">        s[<span class="string">'收益'</span>] = broker.market_value - broker.initial_cash</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>

<p>这段代码有点长，但是核心其实就两部分。</p>
<ul>
<li>初始化函数（init）：传入必要参数，对 OHLC 数据进行简单清洗、排序和验证。我们从不同地方下载的数据，可能格式不一样；而排序的方式也可能是从前往后。所以，这里我们把数据统一设置为按照时间从之前往现在的排序。</li>
<li>执行函数（run）：这是回测框架的主要循环部分，核心是更新市场还有更新策略的时间。迭代完成所有的历史数据后，它会计算收益并返回。</li>
</ul>
<p>你应该注意到了，此时，我们还没有定义策略和交易所 API 的结构。不过，通过回测的执行函数，我们可以确定这两个类的接口形式。</p>
<p>策略类（Strategy）的接口形式为：</p>
<ul>
<li>初始化函数 init()，根据历史数据进行指标（Indicator）计算。</li>
<li>步进函数 next()，根据当前时间和指标，决定买卖操作，并发给交易所类执行。</li>
</ul>
<p>交易所类（ExchangeAPI）的接口形式为：</p>
<ul>
<li>步进函数 next()，根据当前时间，更新最新的价格；</li>
<li>买入操作 buy()，买入资产；</li>
<li>卖出操作 sell()，卖出资产。</li>
</ul>
<h3 id="交易策略"><a href="#交易策略" class="headerlink" title="交易策略"></a>交易策略</h3><p>接下来我们来看交易策略。交易策略的开发是一个非常复杂的学问。为了达到学习的目的，我们来想一个简单的策略——移动均值交叉策略。</p>
<p>为了了解这个策略，我们先了解一下，什么叫做简单移动均值（Simple Moving Average，简称为 SMA，以下皆用 SMA 表示简单移动均值）。我们知道，N 个数的序列 x[0]、x[1] .…… x[N] 的均值，就是这 N 个数的和除以 N。</p>
<p>现在，我假设一个比较小的数 K，比 N 小很多。我们用一个 K 大小的滑动窗口，在原始的数组上滑动。通过对每次框住的 K 个元素求均值，我们就可以得到，原始数组的窗口大小为 K 的 SMA 了。</p>
<p>SMA，实质上就是对原始数组进行了一个简单平滑处理。比如，某支股票的价格波动很大，那么，我们用 SMA 平滑之后，就会得到下面这张图的效果。</p>
<p>你可以看出，如果窗口大小越大，那么 SMA 应该越平滑，变化越慢；反之，如果 SMA 比较小，那么短期的变化也会越快地反映在 SMA 上。</p>
<p>于是，我们想到，能不能对投资品的价格设置两个指标呢？这俩指标，一个是小窗口的 SMA，一个是大窗口的 SMA。</p>
<ul>
<li>如果小窗口的 SMA 曲线从下面刺破或者穿过大窗口 SMA，那么说明，这个投资品的价格在短期内快速上涨，同时这个趋势很强烈，可能是一个买入的信号；</li>
<li>反之，如果大窗口的 SMA 从下方突破小窗口 SMA，那么说明，投资品的价格在短期内快速下跌，我们应该考虑卖出。<br>下面这幅图，就展示了这两种情况。</li>
</ul>
<p>明白了这里的概念和原理后，接下来的操作就不难了。利用 Pandas，我们可以非常简单地计算 SMA 和 SMA 交叉。比如，你可以引入下面两个工具函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SMA</span><span class="params">(values, n)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    返回简单滑动平均</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> pd.Series(values).rolling(n).mean()</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crossover</span><span class="params">(series1, series2)</span> -&gt; bool:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    检查两个序列是否在结尾交叉</span></span><br><span class="line"><span class="string">    :param series1:  序列 1</span></span><br><span class="line"><span class="string">    :param series2:  序列 2</span></span><br><span class="line"><span class="string">    :return:         如果交叉返回 True，反之 False</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> series1[<span class="number">-2</span>] &lt; series2[<span class="number">-2</span>] <span class="keyword">and</span> series1[<span class="number">-1</span>] &gt; series2[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<p>如代码所示，对于输入的一个数组，Pandas 的 rolling(k) 函数，可以方便地计算窗内口大小为 K 的 SMA 数组；而想要检查某个时刻两个 SMA 是否交叉，你只需要查看两个数组末尾的两个元素即可。</p>
<p>那么，基于此，我们就可以开发出一个简单的策略了。下面这段代码表示策略的核心思想，我做了详细的注释，你理解起来应该没有问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self, tick)</span>:</span></span><br><span class="line">        <span class="comment"># 如果此时快线刚好越过慢线，买入全部</span></span><br><span class="line">        <span class="keyword">if</span> crossover(self.sma1[:tick], self.sma2[:tick]):</span><br><span class="line">            self.buy()</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 如果是慢线刚好越过快线，卖出全部</span></span><br><span class="line">        <span class="keyword">elif</span> crossover(self.sma2[:tick], self.sma1[:tick]):</span><br><span class="line">            self.sell()</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 否则，这个时刻不执行任何操作。</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>说完策略的核心思想，我们开始搭建策略类的框子。</p>
<p>首先，我们要考虑到，策略类 Strategy 应该是一个可以被继承的类，同时应该包含一些固定的接口。这样，回测器才能方便地调用。</p>
<p>于是，我们可以定义一个 Strategy 抽象类，包含两个接口方法 init 和 next，分别对应我们前面说的指标计算和步进函数。不过注意，抽象类是不能被实例化的。所以，我们必须定义一个具体的子类，同时实现了 init 和 next 方法才可以。</p>
<p>这个类的定义，你可以参考下面代码的实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Callable</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Strategy</span><span class="params">(metaclass=abc.ABCMeta)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    抽象策略类，用于定义交易策略。</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    如果要定义自己的策略类，需要继承这个基类，并实现两个抽象方法：</span></span><br><span class="line"><span class="string">    Strategy.init</span></span><br><span class="line"><span class="string">    Strategy.next</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, broker, data)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        构造策略对象。</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        @params broker:  ExchangeAPI    交易 API 接口，用于模拟交易</span></span><br><span class="line"><span class="string">        @params data:    list           行情数据数据</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._indicators = []</span><br><span class="line">        self._broker = broker  <span class="comment"># type: _Broker</span></span><br><span class="line">        self._data = data  <span class="comment"># type: _Data</span></span><br><span class="line">        self._tick = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">I</span><span class="params">(self, func: Callable, *args)</span> -&gt; np.ndarray:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        计算买卖指标向量。买卖指标向量是一个数组，长度和历史数据对应；</span></span><br><span class="line"><span class="string">        用于判定这个时间点上需要进行 " 买 " 还是 " 卖 "。</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        例如计算滑动平均：</span></span><br><span class="line"><span class="string">        def init():</span></span><br><span class="line"><span class="string">            self.sma = self.I(utils.SMA, self.data.Close, N)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        value = func(*args)</span><br><span class="line">        value = np.asarray(value)</span><br><span class="line">        assert_msg(value.shape[<span class="number">-1</span>] == len(self._data.Close), <span class="string">'指示器长度必须和 data 长度相同'</span>)</span><br><span class="line"> </span><br><span class="line">        self._indicators.append(value)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tick</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._tick</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        初始化策略。在策略回测 / 执行过程中调用一次，用于初始化策略内部状态。</span></span><br><span class="line"><span class="string">        这里也可以预计算策略的辅助参数。比如根据历史行情数据：</span></span><br><span class="line"><span class="string">        计算买卖的指示器向量；</span></span><br><span class="line"><span class="string">        训练模型 / 初始化模型参数</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self, tick)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        步进函数，执行第 tick 步的策略。tick 代表当前的 " 时间 "。比如 data[tick] 用于访问当前的市场价格。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buy</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._broker.buy()</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sell</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._broker.sell()</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._data</span><br></pre></td></tr></table></figure>

<p>为了方便访问成员，我们还定义了一些 Python property。同时，我们的买卖请求是由策略类发出、由交易所 API 来执行的，所以我们的策略类里依赖于 ExchangeAPI 类。</p>
<p>现在，有了这个框架，我们实现移动均线交叉策略就很简单了。你只需要在 init 函数中，定义计算大小窗口 SMA 的逻辑；同时，在 next 函数中完成交叉检测和买卖调用就行了。具体实现，你可以参考下面这段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> assert_msg, crossover, SMA</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmaCross</span><span class="params">(Strategy)</span>:</span></span><br><span class="line">    <span class="comment"># 小窗口 SMA 的窗口大小，用于计算 SMA 快线</span></span><br><span class="line">    fast = <span class="number">10</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 大窗口 SMA 的窗口大小，用于计算 SMA 慢线</span></span><br><span class="line">    slow = <span class="number">20</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 计算历史上每个时刻的快线和慢线</span></span><br><span class="line">        self.sma1 = self.I(SMA, self.data.Close, self.fast)</span><br><span class="line">        self.sma2 = self.I(SMA, self.data.Close, self.slow)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self, tick)</span>:</span></span><br><span class="line">        <span class="comment"># 如果此时快线刚好越过慢线，买入全部</span></span><br><span class="line">        <span class="keyword">if</span> crossover(self.sma1[:tick], self.sma2[:tick]):</span><br><span class="line">            self.buy()</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 如果是慢线刚好越过快线，卖出全部</span></span><br><span class="line">        <span class="keyword">elif</span> crossover(self.sma2[:tick], self.sma1[:tick]):</span><br><span class="line">            self.sell()</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 否则，这个时刻不执行任何操作。</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h3 id="模拟交易"><a href="#模拟交易" class="headerlink" title="模拟交易"></a>模拟交易</h3><p>到这里，我们的回测就只差最后一块儿了。胜利就在眼前，我们继续加油。</p>
<p>我们前面提到过，交易所类负责模拟交易，而模拟的基础，就是需要当前市场的价格。这里，我们可以用 OHLC 中的 Close，作为那个时刻的价格。</p>
<p>此外，为了简化设计，我们假设买卖操作都利用的是当前账户的所有资金、仓位，且市场容量足够大。这样，我们的下单请求就能够马上完全执行。</p>
<p>也别忘了手续费这个大头。考虑到有手续费的情况，此时，我们最核心的买卖函数应该怎么来写呢？</p>
<p>我们一起来想这个问题。假设，我们现在有 1000.0 元，此时 BTC 的价格是 100.00 元（当然没有这么好的事情啊，这里只是假设），并且交易手续费为 1%。那么，我们能买到多少 BTC 呢？</p>
<p>我们可以采用这种算法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">买到的数量 = 投入的资金 * (1.0 - 手续费) / 价格</span><br></pre></td></tr></table></figure>
<p>那么此时，你就能收到 9.9 个 BTC。</p>
<p>类似的，卖出的时候结算方式如下，也不难理解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">卖出的收益 = 持有的数量 * 价格 *  (1.0 - 手续费)</span><br></pre></td></tr></table></figure>
<p>所以，最终模拟交易所类的实现，你可以参考下面这段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> read_file, assert_msg, crossover, SMA</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExchangeAPI</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data, cash, commission)</span>:</span></span><br><span class="line">        assert_msg(<span class="number">0</span> &lt; cash, <span class="string">" 初始现金数量大于 0，输入的现金数量：&#123;&#125;"</span>.format(cash))</span><br><span class="line">        assert_msg(<span class="number">0</span> &lt;= commission &lt;= <span class="number">0.05</span>, <span class="string">" 合理的手续费率一般不会超过 5%，输入的费率：&#123;&#125;"</span>.format(commission))</span><br><span class="line">        self._inital_cash = cash</span><br><span class="line">        self._data = data</span><br><span class="line">        self._commission = commission</span><br><span class="line">        self._position = <span class="number">0</span></span><br><span class="line">        self._cash = cash</span><br><span class="line">        self._i = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cash</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :return: 返回当前账户现金数量</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self._cash</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">position</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :return: 返回当前账户仓位</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self._position</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initial_cash</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :return: 返回初始现金数量</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self._inital_cash</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">market_value</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :return: 返回当前市值</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self._cash + self._position * self.current_price</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">current_price</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :return: 返回当前市场价格</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self._data.Close[self._i]</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buy</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        用当前账户剩余资金，按照市场价格全部买入</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._position = float(self._cash / (self.current_price * (<span class="number">1</span> + self._commission)))</span><br><span class="line">        self._cash = <span class="number">0.0</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sell</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        卖出当前账户剩余持仓</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._cash += float(self._position * self.current_price * (<span class="number">1</span> - self._commission))</span><br><span class="line">        self._position = <span class="number">0.0</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self, tick)</span>:</span></span><br><span class="line">        self._i = tick</span><br></pre></td></tr></table></figure>

<p>其中的 current_price（当前价格），可以方便地获得模拟交易所当前时刻的商品价格；而 market_value，则可以获得当前总市值。在初始化函数的时候，我们检查手续费率和输入的现金数量，是不是在一个合理的范围。</p>
<p>有了所有的这些部分，我们就可以来模拟回测啦！</p>
<p>首先，我们设置初始资金量为 10000.00 美元，交易所手续费率为 0。这里你可以猜一下，如果我们从 2015 年到现在，都按照 SMA 来买卖，现在应该有多少钱呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    BTCUSD = read_file(<span class="string">'BTCUSD_GEMINI.csv'</span>)</span><br><span class="line">    ret = Backtest(BTCUSD, SmaCross, ExchangeAPI, <span class="number">10000.0</span>, <span class="number">0.00</span>).run()</span><br><span class="line">    print(ret)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>铛铛铛，答案揭晓，程序将输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">初始市值     10000.000000</span><br><span class="line">结束市值     576361.772884</span><br><span class="line">收益         566361.772884</span><br></pre></td></tr></table></figure>

<p>哇，结束时，我们将有 57 万美元，翻了整整 57 倍啊！简直不要太爽。不过，等等，这个手续费率为 0，实在是有点碍眼，因为根本不可能啊。我们现在来设一个比较真实的值吧，大概千分之三，然后再来试试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">初始市值    10000.000000</span><br><span class="line">结束市值     2036.562001</span><br><span class="line">收益      -7963.437999</span><br></pre></td></tr></table></figure>
<p>什么鬼？我们变成赔钱了，只剩下 2000 美元了！这是真的吗？</p>
<p>这是真的，也是假的。</p>
<p>我说的“真”是指，如果你真的用 SMA 交叉这种简单的方法去交易，那么手续费摩擦和滑点等因素，确实可能让你的高频策略赔钱。</p>
<p>而我说是“假”是指，这种模拟交易的方式非常粗糙。真实的市场情况，并非这么理想——比如买卖请求永远马上执行；再比如，我们在市场中进行交易的同时不会影响市场价格等，这些理想情况都是不可能的。所以，很多时候，回测永远赚钱，但实盘马上赔钱。</p>
<p>总结<br>这节课，我们继承上一节，介绍了回测框架的分类、数据的格式，并且带你从头开始写了一个简单的回测系统。你可以把今天的代码片段“拼”起来，这样就会得到一个简化的回测系统样例。同时，我们实现了一个简单的交易策略，并且在真实的历史数据上运行了回测结果。我们观察到，在加入手续费后，策略的收益情况发生了显著的变化。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/04/35%20%7C%20RESTful%20&%20Socket%E8%A1%8C%E6%83%85%E6%95%B0%E6%8D%AE%E5%AF%B9%E6%8E%A5%E5%92%8C%E6%8A%93%E5%8F%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/04/35%20%7C%20RESTful%20&%20Socket%E8%A1%8C%E6%83%85%E6%95%B0%E6%8D%AE%E5%AF%B9%E6%8E%A5%E5%92%8C%E6%8A%93%E5%8F%96/" itemprop="url">35 | RESTful & Socket行情数据对接和抓取</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-04T20:10:07+08:00">
                2020-01-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/" itemprop="url" rel="index">
                    <span itemprop="name">python核心技术与实战</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/04/35%20%7C%20RESTful%20&%20Socket%E8%A1%8C%E6%83%85%E6%95%B0%E6%8D%AE%E5%AF%B9%E6%8E%A5%E5%92%8C%E6%8A%93%E5%8F%96/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/01/04/35%20%7C%20RESTful%20&%20Socket%E8%A1%8C%E6%83%85%E6%95%B0%E6%8D%AE%E5%AF%B9%E6%8E%A5%E5%92%8C%E6%8A%93%E5%8F%96/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="行情数据"><a href="#行情数据" class="headerlink" title="行情数据"></a>行情数据</h3><p>回顾上一节我们提到的，交易所是一个买方、卖方之间的公开撮合平台。买卖方把需要 / 可提供的商品数量和愿意出 / 接受的价格提交给交易所，交易所按照公平原则进行撮合交易。</p>
<p>那么撮合交易是怎么进行的呢？假设你是一个人肉比特币交易所，大量的交易订单往你这里汇总，你应该如何选择才能让交易公平呢？</p>
<p>显然，最直观的操作就是，把买卖订单分成两个表，按照价格由高到低排列。下面的图，就是买入和卖出的委托表。</p>
<p>如果最高的买入价格小于最低的卖出价格，那就不会有任何交易发生。这通常是你看到的委托列表的常态。</p>
<p>如果最高的买入价格和最低的卖出价格相同，那么就尝试进行撮合。比如 BTC 在 9002.01 就会发生撮合，最后按照 9002.01 的价格，成交 0.0330 个 BTC。当然，交易完成后，小林未完成部分的订单（余下 0.1126 - 0.0330 = 0.0796 个 BTC 未卖出），还会继续在委托表里。</p>
<p>不过你可能会想，如果买入和卖出的价格有交叉，那么成交价格又是什么呢？事实上，这种情况并不会发生。我们来试想一下下面这样的场景。</p>
<p>如果你尝试给一个委托列表里加入一个新买入订单，它的价格比所有已有的最高买入价格高，也比所有的卖出价格高。那么此时，它会直接从最低的卖出价格撮合。等到最低价格的卖出订单吃完了，它便开始吃价格第二低的卖出订单，直到这个买入订单完全成交。反之亦然。所以，委托列表价格不会出现交叉。</p>
<p>当然，请注意，这里我说的只是限价订单的交易方式。而对于市价订单，交易规则会有一些轻微的区别，这里我就不详细解释了，主要是让你有个概念。</p>
<p>其实说到这里，所谓的“交易所行情”概念就呼之欲出了。交易所主要有两种行情数据：委托账本（Order Book）和活动行情（Tick data）。</p>
<p>我们把委托表里的具体用户隐去，相同价格的订单合并，就得到了下面这种委托账本。我们主要观察右边的数字部分，其中：</p>
<ul>
<li>上半部分里，第一列红色数字代表 BTC 的卖出价格，中间一列数字是这个价格区间的订单 BTC 总量，最右边一栏是从最低卖出价格到当前价格区间的积累订单量。</li>
<li>中间的大字部分，9994.10 USD 是当前的市场价格，也就是上一次成交交易的价格。</li>
<li>下面绿色部分的含义与上半部分类似，不过指的是买入委托和对应的数量。</li>
</ul>
<p>这张图中，最低的卖出价格比最高的买入价格要高 6.51 USD，这个价差通常被称为 Spread。这里验证了我们前面提到的，委托账本的价格永不交叉； 同时，Spread 很小也能说明这是一个非常活跃的交易所。</p>
<p>每一次撮合发生，意味着一笔交易（Trade）的发生。卖方买方都很开心，于是交易所也很开心地通知行情数据的订阅者：刚才发生了一笔交易，交易的价格是多少，成交数量是多少。这个数据就是活动行情 Tick。</p>
<p>有了这些数据，我们也就掌握了这个交易所的当前状态，可以开始搞事情了。</p>
<h3 id="Websocket-介绍"><a href="#Websocket-介绍" class="headerlink" title="Websocket 介绍"></a>Websocket 介绍</h3><p>在本文的开头我们提到过：行情数据很讲究时效性。所以，行情从交易所产生到传播给我们的程序之间的延迟，应该越低越好。通常，交易所也提供了 REST 的行情数据抓取接口。比如下面这段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_orderbook</span><span class="params">()</span>:</span></span><br><span class="line">  orderbook = requests.get(<span class="string">"https://api.gemini.com/v1/book/btcusd"</span>).json()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">n = <span class="number">10</span></span><br><span class="line">latency = timeit.timeit(<span class="string">'get_orderbook()'</span>, setup=<span class="string">'from __main__ import get_orderbook'</span>, number=n) * <span class="number">1.0</span> / n</span><br><span class="line">print(<span class="string">'Latency is &#123;&#125; ms'</span>.format(latency * <span class="number">1000</span>))</span><br></pre></td></tr></table></figure>

<pre><code>Latency is 1216.6739538000002 ms</code></pre><p>我在美国纽约附近城市的一个服务器上测试了这段代码，你可以看到，平均每次访问 orderbook 的延迟有 0.25 秒左右。显然，如果在国内，这个延迟只会更大。按理说，这两个美国城市的距离很短，为什么延迟会这么大呢？</p>
<p>这是因为，REST 接口本质上是一个 HTTP 接口，在这之下是 TCP/TSL 套接字（Socket）连接。每一次 REST 请求，通常都会重新建立一次 TCP/TSL 握手；然后，在请求结束之后，断开这个链接。这个过程，比我们想象的要慢很多。</p>
<p>举个例子来验证这一点，在同一个城市我们试验一下。我从纽约附近的服务器和 Gemini 在纽约的服务器进行连接，TCP/SSL 握手花了多少时间呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -w <span class="string">"TCP handshake: %&#123;time_connect&#125;s, SSL handshake: %&#123;time_appconnect&#125;s\n"</span> -so /dev/null https://www.gemini.com</span><br></pre></td></tr></table></figure>


<pre><code>  File &quot;&lt;ipython-input-2-946ae0cd5ce7&gt;&quot;, line 1
    curl -w &quot;TCP handshake: %{time_connect}s, SSL handshake: %{time_appconnect}s\n&quot; -so /dev/null https://www.gemini.com
                                                                                  ^
SyntaxError: invalid syntax</code></pre><p>结果显示，HTTP 连接构建的过程，就占了一大半时间！也就是说，我们每次用 REST 请求，都要浪费一大半的时间在和服务器建立连接上，这显然是非常低效的。很自然的你会想到，我们能否实现一次连接、多次通信呢？</p>
<p>事实上，Python 的某些 HTTP 请求库，也可以支持重用底层的 TCP/SSL 连接。但那种方法，一来比较复杂，二来也需要服务器的支持。该怎么办呢？其实，在有 WebSocket 的情况下，我们完全不需要舍近求远。</p>
<p>我先来介绍一下 WebSocket。WebSocket 是一种在单个 TCP/TSL 连接上，进行全双工、双向通信的协议。WebSocket 可以让客户端与服务器之间的数据交换变得更加简单高效，服务端也可以主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就可以直接创建持久性的连接，并进行双向数据传输。</p>
<p>概念听着很痛快，不过还是有些抽象。为了让你快速理解刚刚的这段话，我们还是来看两个简单的例子。二话不说，先看一段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> websocket</span><br><span class="line"><span class="keyword">import</span> thread</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 在接收到服务器发送消息时调用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span><span class="params">(ws, message)</span>:</span></span><br><span class="line">    print(<span class="string">'Received: '</span> + message)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 在和服务器建立完成连接时调用   </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_open</span><span class="params">(ws)</span>:</span></span><br><span class="line">    <span class="comment"># 线程运行函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gao</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="comment"># 往服务器依次发送 0-4，每次发送完休息 0.1 秒</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">            time.sleep(<span class="number">0.01</span>)</span><br><span class="line">            msg=<span class="string">"&#123;0&#125;"</span>.format(i)</span><br><span class="line">            ws.send(msg)</span><br><span class="line">            print(<span class="string">'Sent: '</span> + msg)</span><br><span class="line">        <span class="comment"># 休息 1 秒用于接受服务器回复的消息</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 关闭 Websocket 的连接</span></span><br><span class="line">        ws.close()</span><br><span class="line">        print(<span class="string">"Websocket closed"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 在另一个线程运行 gao() 函数</span></span><br><span class="line">    thread.start_new_thread(gao, ())</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    ws = websocket.WebSocketApp(<span class="string">"ws://echo.websocket.org/"</span>,</span><br><span class="line">                              on_message = on_message,</span><br><span class="line">                              on_open = on_open)</span><br><span class="line">    </span><br><span class="line">    ws.run_forever()</span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

ModuleNotFoundError                       Traceback (most recent call last)

&lt;ipython-input-1-f88baa1bc71c&gt; in &lt;module&gt;
      1 import websocket
----&gt; 2 import thread
      3 
      4 # 在接收到服务器发送消息时调用
      5 def on_message(ws, message):


ModuleNotFoundError: No module named &apos;thread&apos;</code></pre><p>这段代码尝试和wss://echo.websocket.org建立连接。当连接建立的时候，就会启动一条线程，连续向服务器发送 5 条消息。</p>
<p>通过输出可以看出，我们在连续发送的同时，也在不断地接受消息。这并没有像 REST 一样，每发送一个请求，要等待服务器完成请求、完全回复之后，再进行下一个请求。换句话说，我们在请求的同时也在接受消息，这也就是前面所说的”全双工“。</p>
<p>再来看第二段代码。为了解释”双向“，我们来看看获取 Gemini 的委托账单的例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line"><span class="keyword">import</span> websocket</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 全局计数器</span></span><br><span class="line">count = <span class="number">5</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span><span class="params">(ws, message)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> count</span><br><span class="line">    print(message)</span><br><span class="line">    count -= <span class="number">1</span></span><br><span class="line">    <span class="comment"># 接收了 5 次消息之后关闭 websocket 连接</span></span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">        ws.close()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    ws = websocket.WebSocketApp(</span><br><span class="line">        <span class="string">"wss://api.gemini.com/v1/marketdata/btcusd?top_of_book=true&amp;offers=true"</span>,</span><br><span class="line">        on_message=on_message)</span><br><span class="line">    ws.run_forever(sslopt=&#123;<span class="string">"cert_reqs"</span>: ssl.CERT_NONE&#125;)</span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

AttributeError                            Traceback (most recent call last)

&lt;ipython-input-4-00b6ecb101b9&gt; in &lt;module&gt;
     15 
     16 if __name__ == &quot;__main__&quot;:
---&gt; 17     ws = websocket.WebSocketApp(
     18         &quot;wss://api.gemini.com/v1/marketdata/btcusd?top_of_book=true&amp;offers=true&quot;,
     19         on_message=on_message)


AttributeError: module &apos;websocket&apos; has no attribute &apos;WebSocketApp&apos;</code></pre><p>可以看到，在和 Gemini 建立连接后，我们并没有向服务器发送任何消息，没有任何请求，但是服务器却源源不断地向我们推送数据。这可比 REST 接口“每请求一次获得一次回复”的沟通方式高效多了！</p>
<p>因此，相对于 REST 来说，Websocket 是一种更加实时、高效的数据交换方式。当然缺点也很明显：因为请求和回复是异步的，这让我们程序的状态控制逻辑更加复杂。这一点，后面的内容里我们会有更深刻的体会。</p>
<h3 id="行情抓取模块"><a href="#行情抓取模块" class="headerlink" title="行情抓取模块"></a>行情抓取模块</h3><p>有了 Websocket 的基本概念，我们就掌握了和交易所连接的第二种方式。</p>
<p>事实上，Gemini 提供了两种 Websocket 接口，一种是 Public 接口，一种为 Private 接口。</p>
<p>Public 接口，即公开接口，提供 orderbook 服务，即每个人都能看到的当前挂单价和深度，也就是我们这节课刚刚详细讲过的 orderbook。</p>
<p>而 Private 接口，和我们上节课讲的挂单操作有关，订单被完全执行、被部分执行等等其他变动，你都会得到通知。</p>
<p>我们以 orderbook 爬虫为例，先来看下如何抓取 orderbook 信息。下面的代码详细写了一个典型的爬虫，同时使用了类进行封装，希望你不要忘记我们这们课的目的，了解 Python 是如何应用于工程实践中的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> websocket</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderBook</span><span class="params">(object)</span>:</span></span><br><span class="line"> </span><br><span class="line">    BIDS = <span class="string">'bid'</span></span><br><span class="line">    ASKS = <span class="string">'ask'</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, limit=<span class="number">20</span>)</span>:</span></span><br><span class="line"> </span><br><span class="line">        self.limit = limit</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># (price, amount)</span></span><br><span class="line">        self.bids = &#123;&#125;</span><br><span class="line">        self.asks = &#123;&#125;</span><br><span class="line"> </span><br><span class="line">        self.bids_sorted = []</span><br><span class="line">        self.asks_sorted = []</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, price, amount, direction)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> direction == self.BIDS:</span><br><span class="line">            <span class="keyword">if</span> amount == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> price <span class="keyword">in</span> self.bids:</span><br><span class="line">                    <span class="keyword">del</span> self.bids[price]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.bids[price] = amount</span><br><span class="line">        <span class="keyword">elif</span> direction == self.ASKS:</span><br><span class="line">            <span class="keyword">if</span> amount == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> price <span class="keyword">in</span> self.asks:</span><br><span class="line">                    <span class="keyword">del</span> self.asks[price]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.asks[price] = amount</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'WARNING: unknown direction &#123;&#125;'</span>.format(direction))</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sort_and_truncate</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># sort</span></span><br><span class="line">        self.bids_sorted = sorted([(price, amount) <span class="keyword">for</span> price, amount <span class="keyword">in</span> self.bids.items()], reverse=<span class="literal">True</span>)</span><br><span class="line">        self.asks_sorted = sorted([(price, amount) <span class="keyword">for</span> price, amount <span class="keyword">in</span> self.asks.items()])</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># truncate</span></span><br><span class="line">        self.bids_sorted = self.bids_sorted[:self.limit]</span><br><span class="line">        self.asks_sorted = self.asks_sorted[:self.limit]</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># copy back to bids and asks</span></span><br><span class="line">        self.bids = dict(self.bids_sorted)</span><br><span class="line">        self.asks = dict(self.asks_sorted)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_copy_of_bids_and_asks</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> copy.deepcopy(self.bids_sorted), copy.deepcopy(self.asks_sorted)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crawler</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, symbol, output_file)</span>:</span></span><br><span class="line">        self.orderbook = OrderBook(limit=<span class="number">10</span>)</span><br><span class="line">        self.output_file = output_file</span><br><span class="line"> </span><br><span class="line">        self.ws = websocket.WebSocketApp(<span class="string">'wss://api.gemini.com/v1/marketdata/&#123;&#125;'</span>.format(symbol),</span><br><span class="line">                                         on_message = <span class="keyword">lambda</span> ws, message: self.on_message(message))</span><br><span class="line">        self.ws.run_forever(sslopt=&#123;<span class="string">'cert_reqs'</span>: ssl.CERT_NONE&#125;)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_message</span><span class="params">(self, message)</span>:</span></span><br><span class="line">        <span class="comment"># 对收到的信息进行处理，然后送给 orderbook</span></span><br><span class="line">        data = json.loads(message)</span><br><span class="line">        <span class="keyword">for</span> event <span class="keyword">in</span> data[<span class="string">'events'</span>]:</span><br><span class="line">            price, amount, direction = float(event[<span class="string">'price'</span>]), float(event[<span class="string">'remaining'</span>]), event[<span class="string">'side'</span>]</span><br><span class="line">            self.orderbook.insert(price, amount, direction)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 整理 orderbook，排序，只选取我们需要的前几个</span></span><br><span class="line">        self.orderbook.sort_and_truncate()</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 输出到文件</span></span><br><span class="line">        <span class="keyword">with</span> open(self.output_file, <span class="string">'a+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            bids, asks = self.orderbook.get_copy_of_bids_and_asks()</span><br><span class="line">            output = &#123;</span><br><span class="line">                <span class="string">'bids'</span>: bids,</span><br><span class="line">                <span class="string">'asks'</span>: asks,</span><br><span class="line">                <span class="string">'ts'</span>: int(time.time() * <span class="number">1000</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            f.write(json.dumps(output) + <span class="string">'\n'</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    crawler = Crawler(symbol=<span class="string">'BTCUSD'</span>, output_file=<span class="string">'BTCUSD.txt'</span>)</span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

AttributeError                            Traceback (most recent call last)

&lt;ipython-input-1-cec014539940&gt; in &lt;module&gt;
     86 
     87 if __name__ == &apos;__main__&apos;:
---&gt; 88     crawler = Crawler(symbol=&apos;BTCUSD&apos;, output_file=&apos;BTCUSD.txt&apos;)


&lt;ipython-input-1-cec014539940&gt; in __init__(self, symbol, output_file)
     60         self.output_file = output_file
     61 
---&gt; 62         self.ws = websocket.WebSocketApp(&apos;wss://api.gemini.com/v1/marketdata/{}&apos;.format(symbol),
     63                                          on_message = lambda ws, message: self.on_message(message))
     64         self.ws.run_forever(sslopt={&apos;cert_reqs&apos;: ssl.CERT_NONE})


AttributeError: module &apos;websocket&apos; has no attribute &apos;WebSocketApp&apos;</code></pre><p>代码比较长，接下来我们具体解释一下。</p>
<p>这段代码的最开始，封装了一个叫做 orderbook 的 class，专门用来存放与之相关的数据结构。其中的 bids 和 asks 两个字典，用来存储当前时刻下的买方挂单和卖方挂单。</p>
<p>此外，我们还专门维护了一个排过序的 bids_sorted 和 asks_sorted。构造函数有一个参数 limit，用来指示 orderbook 的 bids 和 asks 保留多少条数据。对于很多策略，top 5 的数据往往足够，这里我们选择的是前 10 个。</p>
<p>再往下看，insert() 函数用于向 orderbook 插入一条数据。需要注意，这里的逻辑是，如果某个 price 对应的 amount 是 0，那么意味着这一条数据已经不存在了，删除即可。insert 的数据可能是乱序的，因此在需要的时候，我们要对 bids 和 asks 进行排序，然后选取前面指定数量的数据。这其实就是 sort_and_truncate() 函数的作用，调用它来对 bids 和 asks 排序后截取，最后保存回 bids 和 asks。</p>
<p>接下来的 get_copy_of_bids_and_asks() 函数，用来返回排过序的 bids 和 asks 数组。这里使用深拷贝，是因为如果直接返回，将会返回 bids_sorted 和 asks_sorted 的指针；那么，在下一次调用 sort_and_truncate() 函数的时候，两个数组的内容将会被改变，这就造成了潜在的 bug。</p>
<p>最后来看一下 Crawler 类。构造函数声明 orderbook，然后定义 Websocket 用来接收交易所数据。这里需要注意的一点是，回调函数 on_message() 是一个类成员函数。因此，应该你注意到了，它的第一个参数是 self，这里如果直接写成 on_message = self.on_message 将会出错。</p>
<p>为了避免这个问题，我们需要将函数再次包装一下。这里我使用了前面学过的匿名函数，来传递中间状态，注意我们只需要 message，因此传入 message 即可。</p>
<p>剩下的部分就很清晰了，on_message 回调函数在收到一个新的 tick 时，先将信息解码，枚举收到的所有改变；然后插入 orderbook，排序；最后连同 timestamp 一并输出即可。</p>
<p>虽然这段代码看起来挺长，但是经过我这么一分解，是不是发现都是学过的知识点呢？这也是我一再强调基础的原因，如果对你来说哪部分内容变得陌生了（比如面向对象编程的知识点），一定要记得及时往前复习，这样你学起新的更复杂的东西，才能轻松很多。</p>
<p>回到正题。刚刚的代码，主要是为了抓取 orderbook 的信息。事实上，Gemini 交易所在建立数据流 Websocket 的时候，第一条信息往往非常大，因为里面包含了那个时刻所有的 orderbook 信息。这就叫做初始数据。之后的消息，都是基于初始数据进行修改的，直接处理即可。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这节课我们继承上一节，从委托账本讲起，然后讲述了 WebSocket 的定义、工作机制和使用方法，最后以一个例子收尾，带你学会如何爬取 Orderbook 的信息。希望你在学习这节课的内容时，能够和上节课的内容联系起来，仔细思考 Websocket 和 RESTFul 的区别，并试着总结网络编程中不同模型的适用范围。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/03/34%20%7C%20RESTful%20&%20Socket%E6%90%AD%E5%BB%BA%E4%BA%A4%E6%98%93%E6%89%A7%E8%A1%8C%E5%B1%82%E6%A0%B8%E5%BF%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/03/34%20%7C%20RESTful%20&%20Socket%E6%90%AD%E5%BB%BA%E4%BA%A4%E6%98%93%E6%89%A7%E8%A1%8C%E5%B1%82%E6%A0%B8%E5%BF%83/" itemprop="url">34 | RESTful & Socket搭建交易执行层核心</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-03T20:10:07+08:00">
                2020-01-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/" itemprop="url" rel="index">
                    <span itemprop="name">python核心技术与实战</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/03/34%20%7C%20RESTful%20&%20Socket%E6%90%AD%E5%BB%BA%E4%BA%A4%E6%98%93%E6%89%A7%E8%A1%8C%E5%B1%82%E6%A0%B8%E5%BF%83/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/01/03/34%20%7C%20RESTful%20&%20Socket%E6%90%AD%E5%BB%BA%E4%BA%A4%E6%98%93%E6%89%A7%E8%A1%8C%E5%B1%82%E6%A0%B8%E5%BF%83/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>从这节课开始，我们将实打实地从代码出发，一步步设计出一套清晰完整、易于理解的量化交易系统。</p>
<p>一个量化交易系统，可以说是一个黑箱。这个黑箱连接交易所获取到的数据，通过策略运算，然后再连接交易所进行下单操作。正如我们在输入输出那节课说的那样，黑箱的特性是输入和输出。每一个设计网络交互的同学，都需要在大脑中形成清晰的交互状态图：</p>
<p>知道包是怎样在网络间传递的；<br>知道每一个节点是如何处理不同的输入包，然后输出并分发给下一级的。<br>在你搞不明白的时候，可以先在草稿纸上画出交互拓扑图，标注清楚每个节点的输入和输出格式，然后想清楚网络是怎么流动的。这一点，对网络编程至关重要。</p>
<p>现在，我假设你对网络编程只有很基本的了解。所以接下来，我将先从 REST 的定义讲起，然后过渡到具体的交互方式——如何通过 Python 和交易所进行交互，从而执行下单、撤单、查询订单等网络交互方式。</p>
<h3 id="REST-简介"><a href="#REST-简介" class="headerlink" title="REST 简介"></a>REST 简介</h3><p>什么是 REST API？什么是 Socket？有过网络编程经验的同学，一定对这两个词汇不陌生。</p>
<p>REST 的全称是表征层状态转移（REpresentational State Transfer），本意是指一种操作资源方法。不过，你不用纠结于这个绕口的名字。换种方式来说，REST 的实质可以理解为：通过 URL 定位资源，用 GET、POST、PUT、DELETE 等动词来描述操作。而满足 REST 要求的接口，就被称为 RESTful 的接口。</p>
<p>为了方便你更容易理解这些概念，这里我举个例子来类比。小明同学不是很聪明但很懂事，每天会在他的妈妈下班回来后给妈妈泡茶。刚开始，他的妈妈会发出这样的要求：</p>
<p>这里的“茶”就是资源，“厨房的茶”就是资源的地址（URI）；“泡”是动词；后面的要求，都是接口参数。这样的一个接口，就是小明提供的一个 REST 接口。</p>
<p>如果小明是一台机器，那么解析这个请求就会非常容易；而我们作为维护者，查看小明的代码也很简单。当小明把这个接口暴露到网上时，这就是一个 RESTful 的接口。</p>
<p>总的来说，RESTful 接口通常以 HTTP GET 和 POST 形式出现。但并非所有的 GET、POST 请求接口，都是 RESTful 的接口。</p>
<p>这话可能有些拗口，我们举个例子来看。上节课中，我们获取了 Gemini 交易所中，BTC 对 USD 价格的 ticker 接口：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET https://api.gemini.com/v1/pubticker/btcusd</span><br></pre></td></tr></table></figure>

<p>这里的“GET“是动词，后边的 URI 是“Ticker“这个资源的地址。所以，这是一个 RESTful 的接口。</p>
<p>但下面这样的接口，就不是一个严格的 RESTful 接口：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST https://api.restful.cn/accounts/delete/:username</span><br></pre></td></tr></table></figure>

<p>因为 URI 中包含动词“delete”（删除），所以这个 URI 并不是指向一个资源。如果要修改成严格的 RESTful 接口，我们可以把它改成下面这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE https://api.rest.cn/accounts/:username</span><br></pre></td></tr></table></figure>

<p>然后，我们带着这个观念去看 Gemini 的取消订单接口：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST https://api.gemini.com/v1/order/cancel</span><br></pre></td></tr></table></figure>

<p>注：Private API Invocation 的网址链接为<a href="https://docs.gemini.com/rest-api/#private-api-invocation" target="_blank" rel="noopener">https://docs.gemini.com/rest-api/#private-api-invocation</a></p>
<p>你会发现，这个接口不够“RESTful”的地方有：</p>
<ul>
<li>动词设计不准确，接口使用“POST”而不是重用 HTTP 动词“DELETE”；</li>
<li>URI 里包含动词 cancel；</li>
<li>ID 代表的订单是资源，但订单 ID 是放在参数列表而不是URI里的，因此 URI 并没有指向资源。</li>
</ul>
<p>所以严格来说，这不是一个 RESTful 的接口。</p>
<p>此外，如果我们去检查 Gemini 的其他私有接口（Private，私有接口是指需要附加身份验证信息才能访问的接口），我们会发现，那些接口的设计都不是严格 RESTful 的。不仅如此，大部分的交易所，比如 Bitmex、Bitfinex、OKCoin 等等，它们提供的“REST 接口”，也都不是严格 RESTful 的。这些接口之所以还能被称为“REST 接口”，是因为他们大部分满足了 REST 接口的另一个重要要求：无状态。</p>
<p>无状态的意思是，每个 REST 请求都是独立的，不需要服务器在会话（Session）中缓存中间状态来完成这个请求。简单来说，如果服务器 A 接收到请求的时候宕机了，而此时把这个请求发送给交易所的服务器 B，也能继续完成，那么这个接口就是无状态的。</p>
<p>这里，我再给你举一个简单的有状态的接口的例子。服务器要求，在客户端请求取消订单的时候，必须发送两次不一样的 HTTP 请求。并且，第一次发送让服务器“等待取消”；第二次发送“确认取消”。那么，就算这个接口满足了 RESTful 的动词、资源分离原则，也不是一个 REST 接口。</p>
<p>当然，对于交易所的 REST 接口，你并不需要过于纠结“RESTful”这个概念，否则很容易就被这些名词给绕晕了。你只需要把握住最核心的一点：一个 HTTP 请求完成一次完整操作。</p>
<h3 id="交易所-API-简介"><a href="#交易所-API-简介" class="headerlink" title="交易所 API 简介"></a>交易所 API 简介</h3><p>现在，你对 REST 和 Web Socket 应该有一个大致了解了吧。接下来，我们就开始做点有意思的事情。</p>
<p>首先，我来介绍一下交易所是什么。区块链交易所是个撮合交易平台： 它兼容了传统撮合规则撮合引擎，将资金托管和交割方式替换为区块链。数字资产交易所，则是一个中心化的平台，通过 Web 页面或 PC、手机客户端的形式，让用户将数字资产充值到指定钱包地址（交易所创建的钱包），然后在平台挂买单、卖单以实现数字资产之间的兑换。</p>
<p>通俗来说，交易所就是一个买和卖的菜市场。有人在摊位上大声喊着：“二斤羊肉啊，二斤羊肉，四斤牛肉来换！”这种人被称为 maker（挂单者）。有的人则游走于不同摊位，不动声色地掏出两斤牛肉，顺手拿走一斤羊肉。这种人被称为 taker（吃单者）。</p>
<p>交易所存在的意义，一方面是为 maker 和 taker 提供足够的空间活动；另一方面，让一个名叫撮合引擎的玩意儿，尽可能地把单子撮合在一起，然后收取一定比例的保护费…啊不对，是手续费，从而保障游戏继续进行下去。</p>
<p>市场显然是个很伟大的发明，这里我们就不进行更深入的哲学讨论了。</p>
<p>然后，我再来介绍一个叫做 Gemini 的交易所。Gemini，双子星交易所，全球首个获得合法经营许可的、首个推出期货合约的、专注于撮合大宗交易的数字货币交易所。Gemini 位于纽约，是一家数字货币交易所和托管机构，允许客户交易和存储数字资产，并直接受纽约州金融服务部门（NYDFS）的监管。</p>
<p>Gemini 的界面清晰，API 完整而易用，更重要的是，还提供了完整的测试网络，也就是说，功能和正常的 Gemini 完全一样。但是他家的交易采用虚拟币，非常方便从业者在平台上进行对接测试。</p>
<p>另一个做得很好的交易所，是 Bitmex，他家的 API UI 界面和测试网络也是币圈一流。不过，鉴于这家是期货交易所，对于量化初学者来说有一定的门槛，我们还是选择 Gemini 更方便一些。</p>
<p>在进入正题之前，我们最后再以比特币和美元之间的交易为例，介绍四个基本概念（orderbook 的概念这里就不介绍了，你也不用深究，你只需要知道比特币的价格是什么就行了）。</p>
<ul>
<li>买（buy）：用美元买入比特币的行为。</li>
<li>卖（sell）：用比特币换取美元的行为。</li>
<li>市价单（market order）：给交易所一个方向（买或者卖）和一个数量，交易所把给定数量的美元（或者比特币）换成比特币（或者美元）的单子。</li>
<li>限价单（limit order）：给交易所一个价格、一个方向（买或者卖）和一个数量，交易所在价格达到给定价格的时候，把给定数量的美元（或者比特币）换成比特币（或者美元）的单子。</li>
</ul>
<p>这几个概念都不难懂。其中，市价单和限价单，最大的区别在于，限价单多了一个给定价格。如何理解这一点呢？我们可以来看下面这个例子。</p>
<p>大宝在某一天中午 12:00:00，告诉交易所，我要用一千美元买比特币。交易所收到消息，在 12:00:01 回复小明，现在你的账户多了 0.099 个比特币，少了 1000 美元，交易成功。这是一个市价买单。</p>
<p>而小宝在某一天中午 11:59:00，告诉交易所，我要挂一个单子，数量为 0.1 比特币，价格为 1000 美元，低于这个价格不卖。交易所收到消息，在 11:59:01 告诉小强，挂单成功，你的账户余额中 0.1 比特币的资金被冻结。又过了一分钟，交易所告诉小强，你的单子被完全执行了（fully executed），现在你的账户多了 1000 美元，少了 0.1 个比特币。这就是一个限价卖单。</p>
<p>（这里肯定有人发现不对了：貌似少了一部分比特币，到底去哪儿了呢？嘿嘿，你不妨自己猜猜看。）</p>
<p>显然，市价单，在交给交易所后，会立刻得到执行，当然执行价格也并不受你的控制。它很快，但是也非常不安全。而限价单，则限定了交易价格和数量，安全性相对高很多。缺点呢，自然就是如果市场朝相反方向走，你挂的单子可能没有任何人去接，也就变成了干吆喝却没人买。因为我没有讲解 orderbook，所以这里的说辞不完全严谨，但是对于初学者理解今天的内容，已经够用了。</p>
<p>储备了这么久的基础知识，想必你已经跃跃欲试了吧？下面，我们正式进入正题，手把手教你使用 API 下单。</p>
<h3 id="手把手教你使用-API-下单"><a href="#手把手教你使用-API-下单" class="headerlink" title="手把手教你使用 API 下单"></a>手把手教你使用 API 下单</h3><p>手动挂单显然太慢，也不符合量化交易的初衷。我们就来看看如何用代码实现自动化下单吧。</p>
<p>第一步，你需要做的是，注册一个 Gemini Sandbox 账号。请放心，这个测试账号不需要你充值任何金额，注册后即送大量虚拟现金。这口吻是不是听着特像网游宣传语，接下来就是“快来贪玩蓝月里找我吧”？哈哈，不过这个设定确实如此，所以赶紧来注册一个吧。</p>
<p>注册后，为了满足好奇，你可以先尝试着使用 web 界面自行下单。不过，事实上，未解锁的情况下是无法正常下单的，因此这样尝试并没啥太大意义。</p>
<p>所以第二步，我们需要来配置 API Key。User Settings，API Settings，然后点 GENERATE A NEW ACCOUNT API KEY.，记下 Key 和 Secret 这两串字符。因为窗口一旦消失，这两个信息就再也找不到了，需要你重新生成。</p>
<p>配置到此结束。接下来，我们来看具体实现。</p>
<p>先强调一点，在量化系统开发的时候，你的心中一定要有清晰的数据流图。下单逻辑是一个很简单的 RESTful 的过程，和你在网页操作的一样，构造你的请求订单、加密请求，然后 post 给 gemini 交易所即可。</p>
<p>不过，因为涉及到的知识点较多，带你一步一步从零来写代码显然不太现实。所以，我们采用“先读懂后记忆并使用”的方法来学，下面即为这段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line">base_url = <span class="string">"https://api.sandbox.gemini.com"</span></span><br><span class="line">endpoint = <span class="string">"/v1/order/new"</span></span><br><span class="line">url = base_url + endpoint</span><br><span class="line"> </span><br><span class="line">gemini_api_key = <span class="string">"account-zmidXEwP72yLSSybXVvn"</span></span><br><span class="line">gemini_api_secret = <span class="string">"375b97HfE7E4tL8YaP3SJ239Pky9"</span>.encode()</span><br><span class="line"> </span><br><span class="line">t = datetime.datetime.now()</span><br><span class="line">payload_nonce = str(int(time.mktime(t.timetuple())*<span class="number">1000</span>))</span><br><span class="line"> </span><br><span class="line">payload = &#123;</span><br><span class="line">   <span class="string">"request"</span>: <span class="string">"/v1/order/new"</span>,</span><br><span class="line">   <span class="string">"nonce"</span>: payload_nonce,</span><br><span class="line">   <span class="string">"symbol"</span>: <span class="string">"btcusd"</span>,</span><br><span class="line">   <span class="string">"amount"</span>: <span class="string">"5"</span>,</span><br><span class="line">   <span class="string">"price"</span>: <span class="string">"3633.00"</span>,</span><br><span class="line">   <span class="string">"side"</span>: <span class="string">"buy"</span>,</span><br><span class="line">   <span class="string">"type"</span>: <span class="string">"exchange limit"</span>,</span><br><span class="line">   <span class="string">"options"</span>: [<span class="string">"maker-or-cancel"</span>]</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">encoded_payload = json.dumps(payload).encode()</span><br><span class="line">b64 = base64.b64encode(encoded_payload)</span><br><span class="line">signature = hmac.new(gemini_api_secret, b64, hashlib.sha384).hexdigest()</span><br><span class="line"> </span><br><span class="line">request_headers = &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">"text/plain"</span>,</span><br><span class="line">    <span class="string">'Content-Length'</span>: <span class="string">"0"</span>,</span><br><span class="line">    <span class="string">'X-GEMINI-APIKEY'</span>: gemini_api_key,</span><br><span class="line">    <span class="string">'X-GEMINI-PAYLOAD'</span>: b64,</span><br><span class="line">    <span class="string">'X-GEMINI-SIGNATURE'</span>: signature,</span><br><span class="line">    <span class="string">'Cache-Control'</span>: <span class="string">"no-cache"</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">response = requests.post(url,</span><br><span class="line">                         data=<span class="literal">None</span>,</span><br><span class="line">                         headers=request_headers)</span><br><span class="line"> </span><br><span class="line">new_order = response.json()</span><br><span class="line">print(new_order)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">########## 输出 ##########</span></span><br><span class="line"> </span><br><span class="line">&#123;<span class="string">'order_id'</span>: <span class="string">'239088767'</span>, <span class="string">'id'</span>: <span class="string">'239088767'</span>, <span class="string">'symbol'</span>: <span class="string">'btcusd'</span>, <span class="string">'exchange'</span>: <span class="string">'gemini'</span>, <span class="string">'avg_execution_price'</span>: <span class="string">'0.00'</span>, <span class="string">'side'</span>: <span class="string">'buy'</span>, <span class="string">'type'</span>: <span class="string">'exchange limit'</span>, <span class="string">'timestamp'</span>: <span class="string">'1561956976'</span>, <span class="string">'timestampms'</span>: <span class="number">1561956976535</span>, <span class="string">'is_live'</span>: <span class="literal">True</span>, <span class="string">'is_cancelled'</span>: <span class="literal">False</span>, <span class="string">'is_hidden'</span>: <span class="literal">False</span>, <span class="string">'was_forced'</span>: <span class="literal">False</span>, <span class="string">'executed_amount'</span>: <span class="string">'0'</span>, <span class="string">'remaining_amount'</span>: <span class="string">'5'</span>, <span class="string">'options'</span>: [<span class="string">'maker-or-cancel'</span>], <span class="string">'price'</span>: <span class="string">'3633.00'</span>, <span class="string">'original_amount'</span>: <span class="string">'5'</span>&#125;</span><br></pre></td></tr></table></figure>

<p>我们来深入看一下这段代码。</p>
<p>RESTful 的 POST 请求，通过 requests.post 来实现。post 接受三个参数，url、data 和 headers。</p>
<p>这里的 url 等价于 <a href="https://api.sandbox.gemini.com/v1/order/new，但是在代码中分两部分写。第一部分是交易所" target="_blank" rel="noopener">https://api.sandbox.gemini.com/v1/order/new，但是在代码中分两部分写。第一部分是交易所</a> API 地址；第二部分，以斜杠开头，用来表示统一的 API endpoint。我们也可以在其他交易所的 API 中看到类似的写法，两者连接在一起，就构成了最终的 url。</p>
<p>而接下来大段命令的目的，是为了构造 request_headers。</p>
<p>这里我简单说一下 HTTP request，这是互联网中基于 TCP 的基础协议。HTTP 协议是 Hyper Text Transfer Protocol（超文本传输协议）的缩写，用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。而 TCP（Transmission Control Protocol）则是面向连接的、可靠的、基于字节流的传输层通信协议。</p>
<p>多提一句，如果你开发网络程序，建议利用闲暇时间认真读一读《计算机网络：自顶向下方法》这本书，它也是国内外计算机专业必修课中广泛采用的课本之一。一边学习，一边应用，对于初学者的能力提升是全面而充分的。</p>
<p>回到 HTTP，它的主要特点是，连接简单、灵活，可以使用“简单请求，收到回复，然后断开连接”的方式，也是一种无状态的协议，因此充分符合 RESTful 的思想。</p>
<p>HTTP 发送需要一个请求头（request header），也就是代码中的 request_headers，用 Python 的语言表示，就是一个 str 对 str 的字典。</p>
<p>这个字典里，有一些字段有特殊用途， ‘Content-Type’: “text/plain” 和 ‘Content-Length’: “0” 描述 Content 的类型和长度，这里的 Content 对应于参数 data。但是 Gemini 这里的 request 的 data 没有任何用处，因此长度为 0。</p>
<p>还有一些其他字段，例如 ‘keep-alive’ 来表示连接是否可持续化等，你也可以适当注意一下。要知道，网络编程很多 bug 都会出现在不起眼的细节之处。</p>
<p>继续往下走看代码。payload 是一个很重要的字典，它用来存储下单操作需要的所有的信息，也就是业务逻辑信息。这里我们可以下一个 limit buy，限价买单，价格为 3633 刀。</p>
<p>另外，请注意 nonce，这是个很关键并且在网络通信中很常见的字段。</p>
<p>因为网络通信是不可靠的，一个信息包有可能会丢失，也有可能重复发送，在金融操作中，这两者都会造成很严重的后果。丢包的话，我们重新发送就行了；但是重复的包，我们需要去重。虽然 TCP 在某种程度上可以保证，但为了在应用层面进一步减少错误发生的机会，Gemini 交易所要求所有的通信 payload 必须带有 nonce。</p>
<p>nonce 是个单调递增的整数。当某个后来的请求的 nonce，比上一个成功收到的请求的 nouce 小或者相等的时候，Gemini 便会拒绝这次请求。这样一来，重复的包就不会被执行两次了。另一方面，这样也可以在一定程度上防止中间人攻击：</p>
<ul>
<li>一则是因为 nonce 的加入，使得加密后的同样订单的加密文本完全混乱；</li>
<li>二则是因为，这会使得中间人无法通过“发送同样的包来构造重复订单“进行攻击。</li>
</ul>
<p>这样的设计思路是不是很巧妙呢？这就相当于每个包都增加了一个身份识别，可以极大地提高安全性。希望你也可以多注意，多思考一下这些巧妙的用法。</p>
<p>接下来的代码就很清晰了。我们要对 payload 进行 base64 和 sha384 算法非对称加密，其中 gemini_api_secret 为私钥；而交易所存储着公钥，可以对你发送的请求进行解密。最后，代码再将加密后的请求封装到 request_headers 中，发送给交易所，并收到 response，这个订单就完成了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这节课我们介绍了什么是 RESTFul API，带你了解了交易所的 RESTFul API 是如何工作的，以及如何通过 RESTFul API 来下单。同时，我简单讲述了网络编程中的一些技巧操作，希望你在网络编程中要注意思考每一个细节，尽可能在写代码之前，对业务逻辑和具体的技术细节有足够清晰的认识。</p>
<p>下一节，我们同样将从 Web Socket 的定义开始，讲解量化交易中数据模块的具体实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">&lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">LvYang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">43</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LvYang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    





  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'qcq1G35cOv9sG5BrpbdXJwtJ-gzGzoHsz',
        appKey: 'VtFEF7WhBgSXbcGzdO1GztzO',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
