<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="python," />










<meta name="description" content="Python 工匠：编写条件分支代码的技巧序言 这是 “Python 工匠”系列的第 2 篇文章。[查看系列所有文章]  编写条件分支代码是编码过程中不可或缺的一部分。 如果用道路来做比喻，现实世界中的代码从来都不是一条笔直的高速公路，而更像是由无数个岔路口组成的某个市区地图。我们编码者就像是驾驶员，需要告诉我们的程序，下个路口需要往左还是往右。 编写优秀的条件分支代码非常重要，因为糟糕、复杂的分">
<meta name="keywords" content="python">
<meta property="og:type" content="article">
<meta property="og:title" content="Python 工匠：2-编写条件分支代码的技巧">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;25&#x2F;2-Python%20%E5%B7%A5%E5%8C%A0%EF%BC%9A%E7%BC%96%E5%86%99%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8A%80%E5%B7%A7&#x2F;index.html">
<meta property="og:site_name" content="LvYang">
<meta property="og:description" content="Python 工匠：编写条件分支代码的技巧序言 这是 “Python 工匠”系列的第 2 篇文章。[查看系列所有文章]  编写条件分支代码是编码过程中不可或缺的一部分。 如果用道路来做比喻，现实世界中的代码从来都不是一条笔直的高速公路，而更像是由无数个岔路口组成的某个市区地图。我们编码者就像是驾驶员，需要告诉我们的程序，下个路口需要往左还是往右。 编写优秀的条件分支代码非常重要，因为糟糕、复杂的分">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-12-25T10:01:12.643Z">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/12/25/2-Python 工匠：编写条件分支代码的技巧/"/>





  <title>Python 工匠：2-编写条件分支代码的技巧 | LvYang</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LvYang</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/25/2-Python%20%E5%B7%A5%E5%8C%A0%EF%BC%9A%E7%BC%96%E5%86%99%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LvYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LvYang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Python 工匠：2-编写条件分支代码的技巧</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-25T20:10:07+08:00">
                2019-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python%E5%B7%A5%E5%8C%A0/" itemprop="url" rel="index">
                    <span itemprop="name">Python工匠</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/25/2-Python%20%E5%B7%A5%E5%8C%A0%EF%BC%9A%E7%BC%96%E5%86%99%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8A%80%E5%B7%A7/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count gitment-comments-count" data-xid="/2019/12/25/2-Python%20%E5%B7%A5%E5%8C%A0%EF%BC%9A%E7%BC%96%E5%86%99%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8A%80%E5%B7%A7/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Python-工匠：编写条件分支代码的技巧"><a href="#Python-工匠：编写条件分支代码的技巧" class="headerlink" title="Python 工匠：编写条件分支代码的技巧"></a>Python 工匠：编写条件分支代码的技巧</h1><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><blockquote>
<p>这是 “Python 工匠”系列的第 2 篇文章。<a href="https://github.com/piglei/one-python-craftsman" target="_blank" rel="noopener">[查看系列所有文章]</a></p>
</blockquote>
<p>编写条件分支代码是编码过程中不可或缺的一部分。</p>
<p>如果用道路来做比喻，现实世界中的代码从来都不是一条笔直的高速公路，而更像是由无数个岔路口组成的某个市区地图。我们编码者就像是驾驶员，需要告诉我们的程序，下个路口需要往左还是往右。</p>
<p>编写优秀的条件分支代码非常重要，因为糟糕、复杂的分支处理非常容易让人困惑，从而降低代码质量。所以，这篇文章将会种重点谈谈在 Python 中编写分支代码应该注意的地方。</p>
<h3 id="内容目录"><a href="#内容目录" class="headerlink" title="内容目录"></a>内容目录</h3><ul>
<li><a href="#最佳实践">最佳实践</a><ul>
<li><a href="#1-避免多层分支嵌套">1. 避免多层分支嵌套</a></li>
<li><a href="#2-封装那些过于复杂的逻辑判断">2. 封装那些过于复杂的逻辑判断</a></li>
<li><a href="#3-留意不同分支下的重复代码">3. 留意不同分支下的重复代码</a></li>
<li><a href="#4-谨慎使用三元表达式">4. 谨慎使用三元表达式</a></li>
</ul>
</li>
<li><a href="#常见技巧">常见技巧</a><ul>
<li><a href="#1-使用德摩根定律">1. 使用“德摩根定律”</a></li>
<li><a href="#2-自定义对象的布尔真假">2. 自定义对象的“布尔真假”</a></li>
<li><a href="#3-在条件判断中使用-all--any">3. 在条件判断中使用 all() / any()</a></li>
<li><a href="#4-使用-trywhilefor-中-else-分支">4. 使用 try/while/for 中 else 分支</a></li>
</ul>
</li>
<li><a href="#常见陷阱">常见陷阱</a><ul>
<li><a href="#1-与-none-值的比较">1. 与 None 值的比较</a></li>
<li><a href="#2-留意-and-和-or-的运算优先级">2. 留意 and 和 or 的运算优先级</a></li>
</ul>
</li>
<li><a href="#结语">结语</a></li>
<li><a href="#注解">注解</a></li>
</ul>
<h3 id="Python-里的分支代码"><a href="#Python-里的分支代码" class="headerlink" title="Python 里的分支代码"></a>Python 里的分支代码</h3><p>Python 支持最为常见的 <code>if/else</code> 条件分支语句，不过它缺少在其他编程语言中常见的 <code>switch/case</code> 语句。</p>
<p>除此之外，Python 还为 <code>for/while</code> 循环以及 <code>try/except</code> 语句提供了 else 分支，在一些特殊的场景下，它们可以大显身手。</p>
<p>下面我会从 <code>最佳实践</code>、<code>常见技巧</code>、<code>常见陷阱</code> 三个方面讲一下如果编写优秀的条件分支代码。</p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="1-避免多层分支嵌套"><a href="#1-避免多层分支嵌套" class="headerlink" title="1. 避免多层分支嵌套"></a>1. 避免多层分支嵌套</h3><p>如果这篇文章只能删减成一句话就结束，那么那句话一定是<strong>“要竭尽所能的避免分支嵌套”</strong>。</p>
<p>过深的分支嵌套是很多编程新手最容易犯的错误之一。假如有一位新手 JavaScript 程序员写了很多层分支嵌套，那么你可能会看到一层又一层的大括号：<code>if { if { if { ... }}}</code>。俗称<em>“嵌套 if 地狱（Nested If Statement Hell）”</em>。</p>
<p>但是因为 Python 使用了缩进来代替 <code>{}</code>，所以过深的嵌套分支会产生比其他语言下更为严重的后果。比如过多的缩进层次很容易就会让代码超过 <a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">PEP8</a> 中规定的每行字数限制。让我们看看这段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buy_fruit</span><span class="params">(nerd, store)</span>:</span></span><br><span class="line">    <span class="string">"""去水果店买苹果</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    - 先得看看店是不是在营业</span></span><br><span class="line"><span class="string">    - 如果有苹果的话，就买 1 个</span></span><br><span class="line"><span class="string">    - 如果钱不够，就回家取钱再来</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> store.is_open():</span><br><span class="line">        <span class="keyword">if</span> store.has_stocks(<span class="string">"apple"</span>):</span><br><span class="line">            <span class="keyword">if</span> nerd.can_afford(store.price(<span class="string">"apple"</span>, amount=<span class="number">1</span>)):</span><br><span class="line">                nerd.buy(store, <span class="string">"apple"</span>, amount=<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nerd.go_home_and_get_money()</span><br><span class="line">                <span class="keyword">return</span> buy_fruit(nerd, store)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> MadAtNoFruit(<span class="string">"no apple in store!"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> MadAtNoFruit(<span class="string">"store is closed!"</span>)</span><br></pre></td></tr></table></figure>

<p>上面这段代码最大的问题，就是过于直接翻译了原始的条件分支要求，导致短短十几行代码包含了有三层嵌套分支。</p>
<p>这样的代码可读性和维护性都很差。不过我们可以用一个很简单的技巧：<strong>“提前结束”</strong> 来优化这段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buy_fruit</span><span class="params">(nerd, store)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> store.is_open():</span><br><span class="line">        <span class="keyword">raise</span> MadAtNoFruit(<span class="string">"store is closed!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> store.has_stocks(<span class="string">"apple"</span>):</span><br><span class="line">        <span class="keyword">raise</span> MadAtNoFruit(<span class="string">"no apple in store!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> nerd.can_afford(store.price(<span class="string">"apple"</span>, amount=<span class="number">1</span>)):</span><br><span class="line">        nerd.buy(store, <span class="string">"apple"</span>, amount=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        nerd.go_home_and_get_money()</span><br><span class="line">        <span class="keyword">return</span> buy_fruit(nerd, store)</span><br></pre></td></tr></table></figure>

<p>“提前结束”指：<strong>在函数内使用 <code>return</code> 或 <code>raise</code> 等语句提前在分支内结束函数。</strong>比如，在新的 <code>buy_fruit</code> 函数里，当分支条件不满足时，我们直接抛出异常，结束这段这代码分支。这样的代码没有嵌套分支，更直接也更易读。</p>
<h3 id="2-封装那些过于复杂的逻辑判断"><a href="#2-封装那些过于复杂的逻辑判断" class="headerlink" title="2. 封装那些过于复杂的逻辑判断"></a>2. 封装那些过于复杂的逻辑判断</h3><p>如果条件分支里的表达式过于复杂，出现了太多的 <code>not/and/or</code>，那么这段代码的可读性就会大打折扣，比如下面这段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果活动还在开放，并且活动剩余名额大于 10，为所有性别为女性，或者级别大于 3</span></span><br><span class="line"><span class="comment"># 的活跃用户发放 10000 个金币</span></span><br><span class="line"><span class="keyword">if</span> activity.is_active <span class="keyword">and</span> activity.remaining &gt; <span class="number">10</span> <span class="keyword">and</span> \</span><br><span class="line">        user.is_active <span class="keyword">and</span> (user.sex == <span class="string">'female'</span> <span class="keyword">or</span> user.level &gt; <span class="number">3</span>):</span><br><span class="line">    user.add_coins(<span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>对于这样的代码，我们可以考虑将具体的分支逻辑封装成函数或者方法，来达到简化代码的目的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> activity.allow_new_user() <span class="keyword">and</span> user.match_activity_condition():</span><br><span class="line">    user.add_coins(<span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>事实上，将代码改写后，之前的注释文字其实也可以去掉了。<strong>因为后面这段代码已经达到了自说明的目的。</strong>至于具体的 <em>什么样的用户满足活动条件？</em> 这种问题，就应由具体的 <code>match_activity_condition()</code> 方法来回答了。</p>
<blockquote>
<p><strong>Hint:</strong> 恰当的封装不光直接改善了代码的可读性，事实上，如果上面的活动判断逻辑在代码中出现了不止一次的话，封装更是必须的。不然重复代码会极大的破坏这段逻辑的可维护性。</p>
</blockquote>
<h3 id="3-留意不同分支下的重复代码"><a href="#3-留意不同分支下的重复代码" class="headerlink" title="3. 留意不同分支下的重复代码"></a>3. 留意不同分支下的重复代码</h3><p>重复代码是代码质量的天敌，而条件分支语句又非常容易成为重复代码的重灾区。所以，当我们编写条件分支语句时，需要特别留意，不要生产不必要的重复代码。</p>
<p>让我们看下这个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于新用户，创建新的用户资料，否则更新旧资料</span></span><br><span class="line"><span class="keyword">if</span> user.no_profile_exists:</span><br><span class="line">    create_user_profile(</span><br><span class="line">        username=user.username,</span><br><span class="line">        email=user.email,</span><br><span class="line">        age=user.age,</span><br><span class="line">        address=user.address,</span><br><span class="line">        <span class="comment"># 对于新建用户，将用户的积分置为 0</span></span><br><span class="line">        points=<span class="number">0</span>,</span><br><span class="line">        created=now(),</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    update_user_profile(</span><br><span class="line">        username=user.username,</span><br><span class="line">        email=user.email,</span><br><span class="line">        age=user.age,</span><br><span class="line">        address=user.address,</span><br><span class="line">        updated=now(),</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们可以一眼看出，在不同的分支下，程序调用了不同的函数，做了不一样的事情。但是，因为那些重复代码的存在，<strong>我们却很难简单的区分出，二者的不同点到底在哪。</strong></p>
<p>其实，得益于 Python 的动态特性，我们可以简单的改写一下上面的代码，让可读性可以得到显著的提升：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> user.no_profile_exists:</span><br><span class="line">    profile_func = create_user_profile</span><br><span class="line">    extra_args = &#123;<span class="string">'points'</span>: <span class="number">0</span>, <span class="string">'created'</span>: now()&#125;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    profile_func = update_user_profile</span><br><span class="line">    extra_args = &#123;<span class="string">'updated'</span>: now()&#125;</span><br><span class="line"></span><br><span class="line">profile_func(</span><br><span class="line">    username=user.username,</span><br><span class="line">    email=user.email,</span><br><span class="line">    age=user.age,</span><br><span class="line">    address=user.address,</span><br><span class="line">    **extra_args</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>当你编写分支代码时，请额外关注<strong>由分支产生的重复代码块</strong>，如果可以简单的消灭它们，那就不要迟疑。</p>
<h3 id="4-谨慎使用三元表达式"><a href="#4-谨慎使用三元表达式" class="headerlink" title="4. 谨慎使用三元表达式"></a>4. 谨慎使用三元表达式</h3><p>三元表达式是 Python 2.5 版本后才支持的语法。在那之前，Python 社区一度认为三元表达式没有必要，我们需要使用 <code>x and a or b</code> 的方式来模拟它。<a href="#annot1">[注]</a></p>
<p>事实是，在很多情况下，使用普通的 <code>if/else</code> 语句的代码可读性确实更好。盲目追求三元表达式很容易诱惑你写出复杂、可读性差的代码。</p>
<p>所以，请记得只用三元表达式处理简单的逻辑分支。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">language = <span class="string">"python"</span> <span class="keyword">if</span> you.favor(<span class="string">"dynamic"</span>) <span class="keyword">else</span> <span class="string">"golang"</span></span><br></pre></td></tr></table></figure>

<p>对于绝大多数情况，还是使用普通的 <code>if/else</code> 语句吧。</p>
<h2 id="常见技巧"><a href="#常见技巧" class="headerlink" title="常见技巧"></a>常见技巧</h2><h3 id="1-使用“德摩根定律”"><a href="#1-使用“德摩根定律”" class="headerlink" title="1. 使用“德摩根定律”"></a>1. 使用“德摩根定律”</h3><p>在做分支判断时，我们有时候会写成这样的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果用户没有登录或者用户没有使用 chrome，拒绝提供服务</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> user.has_logged_in <span class="keyword">or</span> <span class="keyword">not</span> user.is_from_chrome:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"our service is only available for chrome logged in user"</span></span><br></pre></td></tr></table></figure>

<p>第一眼看到代码时，是不是需要思考一会才能理解它想干嘛？这是因为上面的逻辑表达式里面出现了 2 个 <code>not</code> 和 1 个 <code>or</code>。而我们人类恰好不擅长处理过多的“否定”以及“或”这种逻辑关系。</p>
<p>这个时候，就该 <a href="https://zh.wikipedia.org/wiki/%E5%BE%B7%E6%91%A9%E6%A0%B9%E5%AE%9A%E5%BE%8B" target="_blank" rel="noopener">德摩根定律</a> 出场了。通俗的说，德摩根定律就是 <code>not A or not B</code> 等价于 <code>not (A and B)</code>。通过这样的转换，上面的代码可以改写成这样：</p>
<p>if not (user.has_logged_in and user.is_from_chrome):<br>    return “our service is only available for chrome logged in user”</p>
<p>怎么样，代码是不是易读了很多？记住德摩根定律，很多时候它对于简化条件分支里的代码逻辑非常有用。</p>
<h3 id="2-自定义对象的“布尔真假”"><a href="#2-自定义对象的“布尔真假”" class="headerlink" title="2. 自定义对象的“布尔真假”"></a>2. 自定义对象的“布尔真假”</h3><p>我们常说，在 Python 里，“万物皆对象”。其实，不光“万物皆对象”，我们还可以利用很多魔法方法<em>（文档中称为：<a href="https://docs.python.org/3/reference/datamodel.html" target="_blank" rel="noopener">user-defined method</a>）</em>，来自定义对象的各种行为。我们可以用很多在别的语言里面无法做到、有些魔法的方式来影响代码的执行。</p>
<p>比如，Python 的所有对象都有自己的“布尔真假”：</p>
<ul>
<li>布尔值为假的对象：<code>None</code>, <code>0</code>, <code>False</code>, <code>[]</code>, <code>()</code>, <code>{}</code>, <code>set()</code>, <code>frozenset()</code>, … …</li>
<li>布尔值为真的对象：非 <code>0</code> 的数值、<code>True</code>，非空的序列、元组，普通的用户类实例，… …</li>
</ul>
<p>通过内建函数 <code>bool()</code>，你可以很方便的查看某个对象的布尔真假。而 Python 进行条件分支判断时用到的也是这个值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool(object())</span><br></pre></td></tr></table></figure>




<pre><code>True</code></pre><p>重点来了，虽然所有用户类实例的布尔值都是真。但是 Python 提供了改变这个行为的办法：<strong>自定义类的 <code>__bool__</code> 魔法方法</strong> <em>（在 Python 2.X 版本中为 <code>__nonzero__</code>）</em>。当类定义了 <code>__bool__</code> 方法后，它的返回值将会被当作类实例的布尔值。</p>
<p>另外，<code>__bool__</code> 不是影响实例布尔真假的唯一方法。如果类没有定义 <code>__bool__</code> 方法，Python 还会尝试调用 <code>__len__</code> 方法<em>（也就是对任何序列对象调用 <code>len</code> 函数）</em>，通过结果是否为 <code>0</code> 判断实例真假。</p>
<p>那么这个特性有什么用呢？看看下面这段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserCollection</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, users)</span>:</span></span><br><span class="line">        self._users = users</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">users = UserCollection([piglei, raymond])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(users._users) &gt; <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">"There's some users in collection!"</span>)</span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

NameError                                 Traceback (most recent call last)

&lt;ipython-input-4-057c2af4e558&gt; in &lt;module&gt;
      5 
      6 
----&gt; 7 users = UserCollection([piglei, raymond])
      8 
      9 if len(users._users) &gt; 0:


NameError: name &apos;piglei&apos; is not defined</code></pre><p>上面的代码里，判断 <code>UserCollection</code> 是否有内容时用到了 <code>users._users</code> 的长度。其实，通过为 <code>UserCollection</code> 添加 <code>__len__</code> 魔法方法，上面的分支可以变得更简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserCollection</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, users)</span>:</span></span><br><span class="line">        self._users = users</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._users)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">users = UserCollection([piglei, raymond])</span><br><span class="line"><span class="comment"># 定义了 __len__ 方法后，UserCollection 对象本身就可以被用于布尔判断了</span></span><br><span class="line"><span class="keyword">if</span> users:</span><br><span class="line">    print(<span class="string">"There's some users in collection!"</span>)</span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

NameError                                 Traceback (most recent call last)

&lt;ipython-input-6-6468765412e2&gt; in &lt;module&gt;
      8 
      9 
---&gt; 10 users = UserCollection([piglei, raymond])
     11 # 定义了 __len__ 方法后，UserCollection 对象本身就可以被用于布尔判断了
     12 if users:


NameError: name &apos;piglei&apos; is not defined</code></pre><p>通过定义魔法方法 <code>__len__</code> 和 <code>__bool__</code> ，我们可以让类自己控制想要表现出的布尔真假值，让代码变得更 pythonic。</p>
<h3 id="3-在条件判断中使用-all-any"><a href="#3-在条件判断中使用-all-any" class="headerlink" title="3. 在条件判断中使用 all() / any()"></a>3. 在条件判断中使用 all() / any()</h3><p><code>all()</code> 和 <code>any()</code> 两个函数非常适合在条件判断中使用。这两个函数接受一个可迭代对象，返回一个布尔值，其中：</p>
<ul>
<li><code>all(seq)</code>：仅当 <code>seq</code> 中所有对象都为布尔真时返回 <code>True</code>，否则返回 <code>False</code></li>
<li><code>any(seq)</code>：只要 <code>seq</code> 中任何一个对象为布尔真就返回 <code>True</code>，否则返回 <code>False</code></li>
</ul>
<p>假如我们有下面这段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">all_numbers_gt_10</span><span class="params">(numbers)</span>:</span></span><br><span class="line">    <span class="string">"""仅当序列中所有数字大于 10 时，返回 True</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> numbers:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>如果使用 <code>all()</code> 内建函数，再配合一个简单的生成器表达式，上面的代码可以写成这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">all_numbers_gt_10_2</span><span class="params">(numbers)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> bool(numbers) <span class="keyword">and</span> all(n &gt; <span class="number">10</span> <span class="keyword">for</span> n <span class="keyword">in</span> numbers)</span><br></pre></td></tr></table></figure>

<p>简单、高效，同时也没有损失可用性。</p>
<h3 id="4-使用-try-while-for-中-else-分支"><a href="#4-使用-try-while-for-中-else-分支" class="headerlink" title="4. 使用 try/while/for 中 else 分支"></a>4. 使用 try/while/for 中 else 分支</h3><p>让我们看看这个函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_stuff</span><span class="params">()</span>:</span></span><br><span class="line">    first_thing_successed = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        do_the_first_thing()</span><br><span class="line">        first_thing_successed = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"Error while calling do_some_thing"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 仅当 first_thing 成功完成时，做第二件事</span></span><br><span class="line">    <span class="keyword">if</span> first_thing_successed:</span><br><span class="line">        <span class="keyword">return</span> do_the_second_thing()</span><br></pre></td></tr></table></figure>

<p>在函数 <code>do_stuff</code> 中，我们希望只有当 <code>do_the_first_thing()</code> 成功调用后<em>（也就是不抛出任何异常）</em>，才继续做第二个函数调用。为了做到这一点，我们需要定义一个额外的变量 <code>first_thing_successed</code> 来作为标记。</p>
<p>其实，我们可以用更简单的方法达到同样的效果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_stuff</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        do_the_first_thing()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"Error while calling do_some_thing"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> do_the_second_thing()</span><br></pre></td></tr></table></figure>

<p>在 <code>try</code> 语句块最后追加上 <code>else</code> 分支后，分支下的<code>do_the_second_thing()</code> 便只会在 <strong>try 下面的所有语句正常执行（也就是没有异常，没有 return、break 等）完成后执行</strong>。</p>
<p>类似的，Python 里的 <code>for/while</code> 循环也支持添加 <code>else</code> 分支，它们表示：当循环使用的迭代对象被正常耗尽、或 while 循环使用的条件变量变为 False 后才执行 else 分支下的代码。</p>
<h2 id="常见陷阱"><a href="#常见陷阱" class="headerlink" title="常见陷阱"></a>常见陷阱</h2><h3 id="1-与-None-值的比较"><a href="#1-与-None-值的比较" class="headerlink" title="1. 与 None 值的比较"></a>1. 与 None 值的比较</h3><p>在 Python 中，有两种比较变量的方法：<code>==</code> 和 <code>is</code>，二者在含义上有着根本的区别：</p>
<ul>
<li><code>==</code>：表示二者所指向的的<strong>值</strong>是否一致</li>
<li><code>is</code>：表示二者是否指向内存中的同一份内容，也就是 <code>id(x)</code> 是否等于 <code>id(y)</code></li>
</ul>
<p><code>None</code> 在 Python 语言中是一个单例对象，如果你要判断某个变量是否为 None 时，记得使用 <code>is</code> 而不是 <code>==</code>，因为只有 <code>is</code> 才能在严格意义上表示某个变量是否是 None。</p>
<p>否则，可能出现下面这样的情况：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">foo = Foo()</span><br><span class="line">foo == <span class="literal">None</span></span><br></pre></td></tr></table></figure>




<pre><code>True</code></pre><p>在上面代码中，Foo 这个类通过自定义 <code>__eq__</code> 魔法方法的方式，很容易就满足了 <code>== None</code> 这个条件。</p>
<p><strong>所以，当你要判断某个变量是否为 None 时，请使用 <code>is</code> 而不是 <code>==</code>。</strong></p>
<h3 id="2-留意-and-和-or-的运算优先级"><a href="#2-留意-and-和-or-的运算优先级" class="headerlink" title="2. 留意 and 和 or 的运算优先级"></a>2. 留意 and 和 or 的运算优先级</h3><p>看看下面这两个表达式，猜猜它们的值一样吗？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print((<span class="literal">True</span> <span class="keyword">or</span> <span class="literal">False</span>) <span class="keyword">and</span> <span class="literal">False</span>)</span><br><span class="line">print(<span class="literal">True</span> <span class="keyword">or</span> <span class="literal">False</span> <span class="keyword">and</span> <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>




<pre><code>True</code></pre><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上就是『Python 工匠』系列文章的第二篇。不知道文章的内容是否对你的胃口。</p>
<p>代码内的分支语句不可避免，我们在编写代码时，需要尤其注意它的可读性，避免对其他看到代码的人造成困扰。</p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><ol>
<li><a id="annot1"></a>事实上 <code>x and a or b</code> 不是总能给你正确的结果，只有当 a 与 b 的布尔值为真时，这个表达式才能正常工作，这是由逻辑运算的短路特性决定的。你可以在命令行中运行 <code>True and None or 0</code> 试试看，结果是 0 而非 None。</li>
</ol>
<blockquote>
<p>文章更新记录：</p>
<ul>
<li>2018.04.08：在与 @geishu 的讨论后，调整了“运算优先符”使用的代码样例</li>
<li>2018.04.10：根据 @dongweiming 的建议，添加注解说明 “x and y or c” 表达式的陷阱</li>
</ul>
</blockquote>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/python/" rel="tag"># python</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/24/29%20%7C%20%E5%B7%A7%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8%E5%92%8CWith%E8%AF%AD%E5%8F%A5%E7%B2%BE%E7%AE%80%E4%BB%A3%E7%A0%81/" rel="next" title="29 | 巧用上下文管理器和With语句精简代码">
                <i class="fa fa-chevron-left"></i> 29 | 巧用上下文管理器和With语句精简代码
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/01/02/33%20%7C%20%E5%B8%A6%E4%BD%A0%E5%88%9D%E6%8E%A2%E9%87%8F%E5%8C%96%E4%B8%96%E7%95%8C/" rel="prev" title="33 | 带你初探量化世界">
                33 | 带你初探量化世界 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      
        <div id="gitment-container"></div>
      
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">LvYang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">58</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Python-工匠：编写条件分支代码的技巧"><span class="nav-number">1.</span> <span class="nav-text">Python 工匠：编写条件分支代码的技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#序言"><span class="nav-number">1.1.</span> <span class="nav-text">序言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内容目录"><span class="nav-number">1.1.1.</span> <span class="nav-text">内容目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Python-里的分支代码"><span class="nav-number">1.1.2.</span> <span class="nav-text">Python 里的分支代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最佳实践"><span class="nav-number">1.2.</span> <span class="nav-text">最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-避免多层分支嵌套"><span class="nav-number">1.2.1.</span> <span class="nav-text">1. 避免多层分支嵌套</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-封装那些过于复杂的逻辑判断"><span class="nav-number">1.2.2.</span> <span class="nav-text">2. 封装那些过于复杂的逻辑判断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-留意不同分支下的重复代码"><span class="nav-number">1.2.3.</span> <span class="nav-text">3. 留意不同分支下的重复代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-谨慎使用三元表达式"><span class="nav-number">1.2.4.</span> <span class="nav-text">4. 谨慎使用三元表达式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见技巧"><span class="nav-number">1.3.</span> <span class="nav-text">常见技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-使用“德摩根定律”"><span class="nav-number">1.3.1.</span> <span class="nav-text">1. 使用“德摩根定律”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-自定义对象的“布尔真假”"><span class="nav-number">1.3.2.</span> <span class="nav-text">2. 自定义对象的“布尔真假”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-在条件判断中使用-all-any"><span class="nav-number">1.3.3.</span> <span class="nav-text">3. 在条件判断中使用 all() / any()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-使用-try-while-for-中-else-分支"><span class="nav-number">1.3.4.</span> <span class="nav-text">4. 使用 try/while/for 中 else 分支</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见陷阱"><span class="nav-number">1.4.</span> <span class="nav-text">常见陷阱</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-与-None-值的比较"><span class="nav-number">1.4.1.</span> <span class="nav-text">1. 与 None 值的比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-留意-and-和-or-的运算优先级"><span class="nav-number">1.4.2.</span> <span class="nav-text">2. 留意 and 和 or 的运算优先级</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结语"><span class="nav-number">1.5.</span> <span class="nav-text">结语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注解"><span class="nav-number">1.6.</span> <span class="nav-text">注解</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LvYang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    
      <script type="text/javascript">
      function renderGitment(){
        var gitment = new Gitmint({
            id: window.location.pathname, 
            owner: 'mengfa',
            repo: 'blogcomments',
            
            lang: "" || navigator.language || navigator.systemLanguage || navigator.userLanguage,
            
            oauth: {
            
            
                client_secret: 'b715de6e1ca56e27e404f3764f7a58cc1f3d4b22',
            
                client_id: 'Iv1.b0b9f79f82846ce7'
            }});
        gitment.render('gitment-container');
      }

      
      renderGitment();
      
      </script>
    





  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'qcq1G35cOv9sG5BrpbdXJwtJ-gzGzoHsz',
        appKey: 'VtFEF7WhBgSXbcGzdO1GztzO',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
